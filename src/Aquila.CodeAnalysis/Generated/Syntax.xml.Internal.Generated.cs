// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;

namespace Aquila.CodeAnalysis.Syntax.InternalSyntax
{
    using Microsoft.CodeAnalysis;

    internal abstract partial class ExprSyntax : AquilaSyntaxNode
    {
        internal ExprSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ExprSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ExprSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal abstract partial class StmtSyntax : AquilaSyntaxNode
    {
        internal StmtSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal StmtSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected StmtSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class ModuleDecl : AquilaSyntaxNode
    {
        internal readonly SyntaxToken moduleKeyword;
        internal readonly NameEx name;
        internal readonly SyntaxToken semicolonToken;

        internal ModuleDecl(SyntaxKind kind, SyntaxToken moduleKeyword, NameEx name, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(moduleKeyword);
            this.moduleKeyword = moduleKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ModuleDecl(SyntaxKind kind, SyntaxToken moduleKeyword, NameEx name, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(moduleKeyword);
            this.moduleKeyword = moduleKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ModuleDecl(SyntaxKind kind, SyntaxToken moduleKeyword, NameEx name, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(moduleKeyword);
            this.moduleKeyword = moduleKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken ModuleKeyword => this.moduleKeyword;
        public NameEx Name => this.name;
        /// <summary>SyntaxToken representing the semicolon token.</summary>
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.moduleKeyword,
                1 => this.name,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ModuleDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitModuleDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitModuleDecl(this);

        public ModuleDecl Update(SyntaxToken moduleKeyword, NameEx name, SyntaxToken semicolonToken)
        {
            if (moduleKeyword != this.ModuleKeyword || name != this.Name || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ModuleDecl(moduleKeyword, name, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ModuleDecl(this.Kind, this.moduleKeyword, this.name, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ModuleDecl(this.Kind, this.moduleKeyword, this.name, this.semicolonToken, GetDiagnostics(), annotations);

        internal ModuleDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var moduleKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(moduleKeyword);
            this.moduleKeyword = moduleKeyword;
            var name = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.moduleKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.semicolonToken);
        }

        static ModuleDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(ModuleDecl), r => new ModuleDecl(r));
        }
    }

    internal sealed partial class CompilationUnitSyntax : AquilaSyntaxNode
    {
        internal readonly ModuleDecl? module;
        internal readonly GreenNode? imports;
        internal readonly GreenNode? htmlNodes;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken endOfFileToken;

        internal CompilationUnitSyntax(SyntaxKind kind, ModuleDecl? module, GreenNode? imports, GreenNode? htmlNodes, GreenNode? members, SyntaxToken endOfFileToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (module != null)
            {
                this.AdjustFlagsAndWidth(module);
                this.module = module;
            }
            if (imports != null)
            {
                this.AdjustFlagsAndWidth(imports);
                this.imports = imports;
            }
            if (htmlNodes != null)
            {
                this.AdjustFlagsAndWidth(htmlNodes);
                this.htmlNodes = htmlNodes;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal CompilationUnitSyntax(SyntaxKind kind, ModuleDecl? module, GreenNode? imports, GreenNode? htmlNodes, GreenNode? members, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (module != null)
            {
                this.AdjustFlagsAndWidth(module);
                this.module = module;
            }
            if (imports != null)
            {
                this.AdjustFlagsAndWidth(imports);
                this.imports = imports;
            }
            if (htmlNodes != null)
            {
                this.AdjustFlagsAndWidth(htmlNodes);
                this.htmlNodes = htmlNodes;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal CompilationUnitSyntax(SyntaxKind kind, ModuleDecl? module, GreenNode? imports, GreenNode? htmlNodes, GreenNode? members, SyntaxToken endOfFileToken)
          : base(kind)
        {
            this.SlotCount = 5;
            if (module != null)
            {
                this.AdjustFlagsAndWidth(module);
                this.module = module;
            }
            if (imports != null)
            {
                this.AdjustFlagsAndWidth(imports);
                this.imports = imports;
            }
            if (htmlNodes != null)
            {
                this.AdjustFlagsAndWidth(htmlNodes);
                this.htmlNodes = htmlNodes;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        public ModuleDecl? Module => this.module;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ImportDecl> Imports => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ImportDecl>(this.imports);
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> HtmlNodes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax>(this.htmlNodes);
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl>(this.members);
        public SyntaxToken EndOfFileToken => this.endOfFileToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.module,
                1 => this.imports,
                2 => this.htmlNodes,
                3 => this.members,
                4 => this.endOfFileToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CompilationUnitSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCompilationUnit(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCompilationUnit(this);

        public CompilationUnitSyntax Update(ModuleDecl module, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ImportDecl> imports, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> htmlNodes, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> members, SyntaxToken endOfFileToken)
        {
            if (module != this.Module || imports != this.Imports || htmlNodes != this.HtmlNodes || members != this.Members || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.CompilationUnit(module, imports, htmlNodes, members, endOfFileToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CompilationUnitSyntax(this.Kind, this.module, this.imports, this.htmlNodes, this.members, this.endOfFileToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CompilationUnitSyntax(this.Kind, this.module, this.imports, this.htmlNodes, this.members, this.endOfFileToken, GetDiagnostics(), annotations);

        internal CompilationUnitSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var module = (ModuleDecl?)reader.ReadValue();
            if (module != null)
            {
                AdjustFlagsAndWidth(module);
                this.module = module;
            }
            var imports = (GreenNode?)reader.ReadValue();
            if (imports != null)
            {
                AdjustFlagsAndWidth(imports);
                this.imports = imports;
            }
            var htmlNodes = (GreenNode?)reader.ReadValue();
            if (htmlNodes != null)
            {
                AdjustFlagsAndWidth(htmlNodes);
                this.htmlNodes = htmlNodes;
            }
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var endOfFileToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.module);
            writer.WriteValue(this.imports);
            writer.WriteValue(this.htmlNodes);
            writer.WriteValue(this.members);
            writer.WriteValue(this.endOfFileToken);
        }

        static CompilationUnitSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CompilationUnitSyntax), r => new CompilationUnitSyntax(r));
        }
    }

    internal sealed partial class ImportDecl : AquilaSyntaxNode
    {
        internal readonly SyntaxToken importKeyword;
        internal readonly SyntaxToken? clrKeyword;
        internal readonly NameEx name;
        internal readonly SyntaxToken semicolonToken;

        internal ImportDecl(SyntaxKind kind, SyntaxToken importKeyword, SyntaxToken? clrKeyword, NameEx name, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            if (clrKeyword != null)
            {
                this.AdjustFlagsAndWidth(clrKeyword);
                this.clrKeyword = clrKeyword;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ImportDecl(SyntaxKind kind, SyntaxToken importKeyword, SyntaxToken? clrKeyword, NameEx name, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            if (clrKeyword != null)
            {
                this.AdjustFlagsAndWidth(clrKeyword);
                this.clrKeyword = clrKeyword;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ImportDecl(SyntaxKind kind, SyntaxToken importKeyword, SyntaxToken? clrKeyword, NameEx name, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            if (clrKeyword != null)
            {
                this.AdjustFlagsAndWidth(clrKeyword);
                this.clrKeyword = clrKeyword;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken ImportKeyword => this.importKeyword;
        public SyntaxToken? ClrKeyword => this.clrKeyword;
        public NameEx Name => this.name;
        /// <summary>SyntaxToken representing the semicolon token.</summary>
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.importKeyword,
                1 => this.clrKeyword,
                2 => this.name,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ImportDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitImportDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitImportDecl(this);

        public ImportDecl Update(SyntaxToken importKeyword, SyntaxToken clrKeyword, NameEx name, SyntaxToken semicolonToken)
        {
            if (importKeyword != this.ImportKeyword || clrKeyword != this.ClrKeyword || name != this.Name || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ImportDecl(importKeyword, clrKeyword, name, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImportDecl(this.Kind, this.importKeyword, this.clrKeyword, this.name, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImportDecl(this.Kind, this.importKeyword, this.clrKeyword, this.name, this.semicolonToken, GetDiagnostics(), annotations);

        internal ImportDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var importKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(importKeyword);
            this.importKeyword = importKeyword;
            var clrKeyword = (SyntaxToken?)reader.ReadValue();
            if (clrKeyword != null)
            {
                AdjustFlagsAndWidth(clrKeyword);
                this.clrKeyword = clrKeyword;
            }
            var name = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.importKeyword);
            writer.WriteValue(this.clrKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.semicolonToken);
        }

        static ImportDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImportDecl), r => new ImportDecl(r));
        }
    }

    /// <summary>Member declaration syntax.</summary>
    internal abstract partial class MemberDecl : AquilaSyntaxNode
    {
        internal MemberDecl(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal MemberDecl(SyntaxKind kind)
          : base(kind)
        {
        }

        protected MemberDecl(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

        /// <summary>Gets the modifier list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }
    }

    internal sealed partial class TypeDecl : MemberDecl
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken typeKeyword;
        internal readonly NameEx name;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? fields;
        internal readonly SyntaxToken closeBraceToken;

        internal TypeDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken typeKeyword, NameEx name, SyntaxToken openBraceToken, GreenNode? fields, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(typeKeyword);
            this.typeKeyword = typeKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal TypeDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken typeKeyword, NameEx name, SyntaxToken openBraceToken, GreenNode? fields, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 7;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(typeKeyword);
            this.typeKeyword = typeKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal TypeDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken typeKeyword, NameEx name, SyntaxToken openBraceToken, GreenNode? fields, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 7;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(typeKeyword);
            this.typeKeyword = typeKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public SyntaxToken TypeKeyword => this.typeKeyword;
        public NameEx Name => this.name;
        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<FieldDecl> Fields => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<FieldDecl>(this.fields);
        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.typeKeyword,
                3 => this.name,
                4 => this.openBraceToken,
                5 => this.fields,
                6 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.TypeDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeDecl(this);

        public TypeDecl Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken typeKeyword, NameEx name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<FieldDecl> fields, SyntaxToken closeBraceToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || typeKeyword != this.TypeKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || fields != this.Fields || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TypeDecl(attributeLists, modifiers, typeKeyword, name, openBraceToken, fields, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeDecl(this.Kind, this.attributeLists, this.modifiers, this.typeKeyword, this.name, this.openBraceToken, this.fields, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeDecl(this.Kind, this.attributeLists, this.modifiers, this.typeKeyword, this.name, this.openBraceToken, this.fields, this.closeBraceToken, GetDiagnostics(), annotations);

        internal TypeDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var typeKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(typeKeyword);
            this.typeKeyword = typeKeyword;
            var name = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var fields = (GreenNode?)reader.ReadValue();
            if (fields != null)
            {
                AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.typeKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.fields);
            writer.WriteValue(this.closeBraceToken);
        }

        static TypeDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeDecl), r => new TypeDecl(r));
        }
    }

    internal sealed partial class FieldDecl : MemberDecl
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeEx type;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken semicolonToken;

        internal FieldDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx type, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal FieldDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx type, SyntaxToken identifier, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal FieldDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx type, SyntaxToken identifier, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the type of syntax.</summary>
        public TypeEx Type => this.type;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>Gets the semicolon token.</summary>
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                3 => this.identifier,
                4 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.FieldDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitFieldDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitFieldDecl(this);

        public FieldDecl Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx type, SyntaxToken identifier, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.FieldDecl(attributeLists, modifiers, type, identifier, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FieldDecl(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FieldDecl(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.semicolonToken, GetDiagnostics(), annotations);

        internal FieldDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.semicolonToken);
        }

        static FieldDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(FieldDecl), r => new FieldDecl(r));
        }
    }

    /// <summary>Base type for method declaration syntax.</summary>
    internal sealed partial class MethodDecl : MemberDecl
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeEx returnType;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameterList;
        internal readonly BlockStmt? body;
        internal readonly ArrowExClause? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal MethodDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal MethodDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal MethodDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the return type syntax.</summary>
        public TypeEx ReturnType => this.returnType;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>Gets the parameter list.</summary>
        public ParameterListSyntax ParameterList => this.parameterList;
        public BlockStmt? Body => this.body;
        public ArrowExClause? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.returnType,
                3 => this.identifier,
                4 => this.typeParameterList,
                5 => this.parameterList,
                6 => this.body,
                7 => this.expressionBody,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.MethodDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMethodDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitMethodDecl(this);

        public MethodDecl Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, BlockStmt body, ArrowExClause expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.MethodDecl(attributeLists, modifiers, returnType, identifier, typeParameterList, parameterList, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MethodDecl(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MethodDecl(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal MethodDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var returnType = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var body = (BlockStmt?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExClause?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static MethodDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(MethodDecl), r => new MethodDecl(r));
        }
    }

    internal sealed partial class FuncOwnerSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly SyntaxToken identifier;
        internal readonly TypeEx ownerType;
        internal readonly SyntaxToken? closeParenToken;

        internal FuncOwnerSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxToken identifier, TypeEx ownerType, SyntaxToken? closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(ownerType);
            this.ownerType = ownerType;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        internal FuncOwnerSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxToken identifier, TypeEx ownerType, SyntaxToken? closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(ownerType);
            this.ownerType = ownerType;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        internal FuncOwnerSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxToken identifier, TypeEx ownerType, SyntaxToken? closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(ownerType);
            this.ownerType = ownerType;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public TypeEx OwnerType => this.ownerType;
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken? CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.identifier,
                2 => this.ownerType,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.FuncOwnerSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitFuncOwner(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitFuncOwner(this);

        public FuncOwnerSyntax Update(SyntaxToken openParenToken, SyntaxToken identifier, TypeEx ownerType, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || identifier != this.Identifier || ownerType != this.OwnerType || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.FuncOwner(openParenToken, identifier, ownerType, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FuncOwnerSyntax(this.Kind, this.openParenToken, this.identifier, this.ownerType, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FuncOwnerSyntax(this.Kind, this.openParenToken, this.identifier, this.ownerType, this.closeParenToken, GetDiagnostics(), annotations);

        internal FuncOwnerSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var ownerType = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(ownerType);
            this.ownerType = ownerType;
            var closeParenToken = (SyntaxToken?)reader.ReadValue();
            if (closeParenToken != null)
            {
                AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.ownerType);
            writer.WriteValue(this.closeParenToken);
        }

        static FuncOwnerSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FuncOwnerSyntax), r => new FuncOwnerSyntax(r));
        }
    }

    /// <summary>Base type for method declaration syntax.</summary>
    internal sealed partial class FuncDecl : MemberDecl
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken fnKeyword;
        internal readonly FuncOwnerSyntax? funcOwner;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameterList;
        internal readonly TypeEx? returnType;
        internal readonly BlockStmt? body;
        internal readonly ArrowExClause? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal FuncDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken fnKeyword, FuncOwnerSyntax? funcOwner, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, TypeEx? returnType, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(fnKeyword);
            this.fnKeyword = fnKeyword;
            if (funcOwner != null)
            {
                this.AdjustFlagsAndWidth(funcOwner);
                this.funcOwner = funcOwner;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (returnType != null)
            {
                this.AdjustFlagsAndWidth(returnType);
                this.returnType = returnType;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal FuncDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken fnKeyword, FuncOwnerSyntax? funcOwner, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, TypeEx? returnType, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(fnKeyword);
            this.fnKeyword = fnKeyword;
            if (funcOwner != null)
            {
                this.AdjustFlagsAndWidth(funcOwner);
                this.funcOwner = funcOwner;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (returnType != null)
            {
                this.AdjustFlagsAndWidth(returnType);
                this.returnType = returnType;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal FuncDecl(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken fnKeyword, FuncOwnerSyntax? funcOwner, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, TypeEx? returnType, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(fnKeyword);
            this.fnKeyword = fnKeyword;
            if (funcOwner != null)
            {
                this.AdjustFlagsAndWidth(funcOwner);
                this.funcOwner = funcOwner;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (returnType != null)
            {
                this.AdjustFlagsAndWidth(returnType);
                this.returnType = returnType;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public SyntaxToken FnKeyword => this.fnKeyword;
        public FuncOwnerSyntax? FuncOwner => this.funcOwner;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>Gets the parameter list.</summary>
        public ParameterListSyntax ParameterList => this.parameterList;
        /// <summary>Gets the return type syntax.</summary>
        public TypeEx? ReturnType => this.returnType;
        public BlockStmt? Body => this.body;
        public ArrowExClause? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.fnKeyword,
                3 => this.funcOwner,
                4 => this.identifier,
                5 => this.typeParameterList,
                6 => this.parameterList,
                7 => this.returnType,
                8 => this.body,
                9 => this.expressionBody,
                10 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.FuncDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitFuncDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitFuncDecl(this);

        public FuncDecl Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken fnKeyword, FuncOwnerSyntax funcOwner, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, TypeEx returnType, BlockStmt body, ArrowExClause expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || fnKeyword != this.FnKeyword || funcOwner != this.FuncOwner || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || returnType != this.ReturnType || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.FuncDecl(attributeLists, modifiers, fnKeyword, funcOwner, identifier, typeParameterList, parameterList, returnType, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FuncDecl(this.Kind, this.attributeLists, this.modifiers, this.fnKeyword, this.funcOwner, this.identifier, this.typeParameterList, this.parameterList, this.returnType, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FuncDecl(this.Kind, this.attributeLists, this.modifiers, this.fnKeyword, this.funcOwner, this.identifier, this.typeParameterList, this.parameterList, this.returnType, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal FuncDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 11;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var fnKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(fnKeyword);
            this.fnKeyword = fnKeyword;
            var funcOwner = (FuncOwnerSyntax?)reader.ReadValue();
            if (funcOwner != null)
            {
                AdjustFlagsAndWidth(funcOwner);
                this.funcOwner = funcOwner;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var returnType = (TypeEx?)reader.ReadValue();
            if (returnType != null)
            {
                AdjustFlagsAndWidth(returnType);
                this.returnType = returnType;
            }
            var body = (BlockStmt?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExClause?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.fnKeyword);
            writer.WriteValue(this.funcOwner);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static FuncDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(FuncDecl), r => new FuncDecl(r));
        }
    }

    internal sealed partial class ExtendDecl : AquilaSyntaxNode
    {
        internal readonly SyntaxToken extendKeyword;
        internal readonly NameEx name;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? methods;
        internal readonly SyntaxToken closeBraceToken;

        internal ExtendDecl(SyntaxKind kind, SyntaxToken extendKeyword, NameEx name, SyntaxToken openBraceToken, GreenNode? methods, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(extendKeyword);
            this.extendKeyword = extendKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (methods != null)
            {
                this.AdjustFlagsAndWidth(methods);
                this.methods = methods;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal ExtendDecl(SyntaxKind kind, SyntaxToken extendKeyword, NameEx name, SyntaxToken openBraceToken, GreenNode? methods, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(extendKeyword);
            this.extendKeyword = extendKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (methods != null)
            {
                this.AdjustFlagsAndWidth(methods);
                this.methods = methods;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal ExtendDecl(SyntaxKind kind, SyntaxToken extendKeyword, NameEx name, SyntaxToken openBraceToken, GreenNode? methods, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(extendKeyword);
            this.extendKeyword = extendKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (methods != null)
            {
                this.AdjustFlagsAndWidth(methods);
                this.methods = methods;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public SyntaxToken ExtendKeyword => this.extendKeyword;
        public NameEx Name => this.name;
        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MethodDecl> Methods => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MethodDecl>(this.methods);
        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.extendKeyword,
                1 => this.name,
                2 => this.openBraceToken,
                3 => this.methods,
                4 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ExtendDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitExtendDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitExtendDecl(this);

        public ExtendDecl Update(SyntaxToken extendKeyword, NameEx name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MethodDecl> methods, SyntaxToken closeBraceToken)
        {
            if (extendKeyword != this.ExtendKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || methods != this.Methods || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.ExtendDecl(extendKeyword, name, openBraceToken, methods, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExtendDecl(this.Kind, this.extendKeyword, this.name, this.openBraceToken, this.methods, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExtendDecl(this.Kind, this.extendKeyword, this.name, this.openBraceToken, this.methods, this.closeBraceToken, GetDiagnostics(), annotations);

        internal ExtendDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var extendKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(extendKeyword);
            this.extendKeyword = extendKeyword;
            var name = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var methods = (GreenNode?)reader.ReadValue();
            if (methods != null)
            {
                AdjustFlagsAndWidth(methods);
                this.methods = methods;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.extendKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.methods);
            writer.WriteValue(this.closeBraceToken);
        }

        static ExtendDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExtendDecl), r => new ExtendDecl(r));
        }
    }

    internal sealed partial class ComponentDecl : AquilaSyntaxNode
    {
        internal readonly SyntaxToken componentKeyword;
        internal readonly NameEx name;
        internal readonly GreenNode? extends;

        internal ComponentDecl(SyntaxKind kind, SyntaxToken componentKeyword, NameEx name, GreenNode? extends, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(componentKeyword);
            this.componentKeyword = componentKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (extends != null)
            {
                this.AdjustFlagsAndWidth(extends);
                this.extends = extends;
            }
        }

        internal ComponentDecl(SyntaxKind kind, SyntaxToken componentKeyword, NameEx name, GreenNode? extends, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(componentKeyword);
            this.componentKeyword = componentKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (extends != null)
            {
                this.AdjustFlagsAndWidth(extends);
                this.extends = extends;
            }
        }

        internal ComponentDecl(SyntaxKind kind, SyntaxToken componentKeyword, NameEx name, GreenNode? extends)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(componentKeyword);
            this.componentKeyword = componentKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (extends != null)
            {
                this.AdjustFlagsAndWidth(extends);
                this.extends = extends;
            }
        }

        public SyntaxToken ComponentKeyword => this.componentKeyword;
        public NameEx Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExtendDecl> Extends => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExtendDecl>(this.extends);

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.componentKeyword,
                1 => this.name,
                2 => this.extends,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ComponentDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitComponentDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitComponentDecl(this);

        public ComponentDecl Update(SyntaxToken componentKeyword, NameEx name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExtendDecl> extends)
        {
            if (componentKeyword != this.ComponentKeyword || name != this.Name || extends != this.Extends)
            {
                var newNode = SyntaxFactory.ComponentDecl(componentKeyword, name, extends);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ComponentDecl(this.Kind, this.componentKeyword, this.name, this.extends, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ComponentDecl(this.Kind, this.componentKeyword, this.name, this.extends, GetDiagnostics(), annotations);

        internal ComponentDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var componentKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(componentKeyword);
            this.componentKeyword = componentKeyword;
            var name = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var extends = (GreenNode?)reader.ReadValue();
            if (extends != null)
            {
                AdjustFlagsAndWidth(extends);
                this.extends = extends;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.componentKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.extends);
        }

        static ComponentDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(ComponentDecl), r => new ComponentDecl(r));
        }
    }

    /// <summary>Class representing one or more attributes applied to a language construct.</summary>
    internal sealed partial class AttributeListSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken closeBracketToken;

        internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? attributes, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? attributes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? attributes, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>Gets the attribute declaration list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.attributes));
        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.attributes,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.AttributeListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttributeList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeList(this);

        public AttributeListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.AttributeList(openBracketToken, attributes, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeListSyntax(this.Kind, this.openBracketToken, this.attributes, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeListSyntax(this.Kind, this.openBracketToken, this.attributes, this.closeBracketToken, GetDiagnostics(), annotations);

        internal AttributeListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.closeBracketToken);
        }

        static AttributeListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeListSyntax), r => new AttributeListSyntax(r));
        }
    }

    /// <summary>Attribute syntax.</summary>
    internal sealed partial class AttributeSyntax : AquilaSyntaxNode
    {
        internal readonly NameEx name;
        internal readonly AttributeArgumentListSyntax? argumentList;

        internal AttributeSyntax(SyntaxKind kind, NameEx name, AttributeArgumentListSyntax? argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        internal AttributeSyntax(SyntaxKind kind, NameEx name, AttributeArgumentListSyntax? argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        internal AttributeSyntax(SyntaxKind kind, NameEx name, AttributeArgumentListSyntax? argumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        /// <summary>Gets the name.</summary>
        public NameEx Name => this.name;
        public AttributeArgumentListSyntax? ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.AttributeSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttribute(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitAttribute(this);

        public AttributeSyntax Update(NameEx name, AttributeArgumentListSyntax argumentList)
        {
            if (name != this.Name || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.Attribute(name, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeSyntax(this.Kind, this.name, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeSyntax(this.Kind, this.name, this.argumentList, GetDiagnostics(), annotations);

        internal AttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var argumentList = (AttributeArgumentListSyntax?)reader.ReadValue();
            if (argumentList != null)
            {
                AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.argumentList);
        }

        static AttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeSyntax), r => new AttributeSyntax(r));
        }
    }

    /// <summary>Attribute argument list syntax.</summary>
    internal sealed partial class AttributeArgumentListSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken closeParenToken;

        internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Gets the arguments syntax list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.arguments));
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.arguments,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.AttributeArgumentListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttributeArgumentList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeArgumentList(this);

        public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

        internal AttributeArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        static AttributeArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentListSyntax), r => new AttributeArgumentListSyntax(r));
        }
    }

    /// <summary>Attribute argument syntax.</summary>
    internal sealed partial class AttributeArgumentSyntax : AquilaSyntaxNode
    {
        internal readonly NameEqualsSyntax? nameEquals;
        internal readonly ExprSyntax expression;

        internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExprSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExprSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExprSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public NameEqualsSyntax? NameEquals => this.nameEquals;
        /// <summary>Gets the expression.</summary>
        public ExprSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.nameEquals,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.AttributeArgumentSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttributeArgument(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeArgument(this);

        public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, ExprSyntax expression)
        {
            if (nameEquals != this.NameEquals || expression != this.Expression)
            {
                var newNode = SyntaxFactory.AttributeArgument(nameEquals, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.expression, GetDiagnostics(), annotations);

        internal AttributeArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var nameEquals = (NameEqualsSyntax?)reader.ReadValue();
            if (nameEquals != null)
            {
                AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.nameEquals);
            writer.WriteValue(this.expression);
        }

        static AttributeArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentSyntax), r => new AttributeArgumentSyntax(r));
        }
    }

    /// <summary>Class representing an identifier name followed by an equals token.</summary>
    internal sealed partial class NameEqualsSyntax : AquilaSyntaxNode
    {
        internal readonly IdentifierEx name;
        internal readonly SyntaxToken equalsToken;

        internal NameEqualsSyntax(SyntaxKind kind, IdentifierEx name, SyntaxToken equalsToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        internal NameEqualsSyntax(SyntaxKind kind, IdentifierEx name, SyntaxToken equalsToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        internal NameEqualsSyntax(SyntaxKind kind, IdentifierEx name, SyntaxToken equalsToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        /// <summary>Gets the identifier name.</summary>
        public IdentifierEx Name => this.name;
        public SyntaxToken EqualsToken => this.equalsToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.NameEqualsSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitNameEquals(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitNameEquals(this);

        public NameEqualsSyntax Update(IdentifierEx name, SyntaxToken equalsToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken)
            {
                var newNode = SyntaxFactory.NameEquals(name, equalsToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, GetDiagnostics(), annotations);

        internal NameEqualsSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (IdentifierEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
        }

        static NameEqualsSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NameEqualsSyntax), r => new NameEqualsSyntax(r));
        }
    }

    /// <summary>Type parameter list syntax.</summary>
    internal sealed partial class TypeParameterListSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken greaterThanToken;

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>Gets the &lt; token.</summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>Gets the parameter list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.parameters));
        /// <summary>Gets the &gt; token.</summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.parameters,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.TypeParameterListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeParameterList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameterList(this);

        public TypeParameterListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);

        internal TypeParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.greaterThanToken);
        }

        static TypeParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeParameterListSyntax), r => new TypeParameterListSyntax(r));
        }
    }

    /// <summary>Type parameter syntax.</summary>
    internal sealed partial class TypeParameterSyntax : AquilaSyntaxNode
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken? varianceKeyword;
        internal readonly SyntaxToken identifier;

        internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null)
            {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null)
            {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null)
            {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken? VarianceKeyword => this.varianceKeyword;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.varianceKeyword,
                2 => this.identifier,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.TypeParameterSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeParameter(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameter(this);

        public TypeParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
        {
            if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, GetDiagnostics(), annotations);

        internal TypeParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var varianceKeyword = (SyntaxToken?)reader.ReadValue();
            if (varianceKeyword != null)
            {
                AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.varianceKeyword);
            writer.WriteValue(this.identifier);
        }

        static TypeParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeParameterSyntax), r => new TypeParameterSyntax(r));
        }
    }

    /// <summary>Class which represents an expression that has a binary operator.</summary>
    internal sealed partial class BinaryEx : ExprSyntax
    {
        internal readonly ExprSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExprSyntax right;

        internal BinaryEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        public ExprSyntax Left => this.left;
        /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.
        /// </summary>
        public ExprSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.BinaryEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBinaryEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitBinaryEx(this);

        public BinaryEx Update(ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryEx(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BinaryEx(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BinaryEx(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal BinaryEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static BinaryEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(BinaryEx), r => new BinaryEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    internal sealed partial class ParenthesizedEx : ExprSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly ExprSyntax expression;
        internal readonly SyntaxToken closeParenToken;

        internal ParenthesizedEx(SyntaxKind kind, SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedEx(SyntaxKind kind, SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedEx(SyntaxKind kind, SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExprSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.expression,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ParenthesizedEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitParenthesizedEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedEx(this);

        public ParenthesizedEx Update(SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedEx(openParenToken, expression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedEx(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedEx(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParenthesizedEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        static ParenthesizedEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedEx), r => new ParenthesizedEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
    internal sealed partial class PrefixUnaryEx : ExprSyntax
    {
        internal readonly SyntaxToken operatorToken;
        internal readonly ExprSyntax operand;

        internal PrefixUnaryEx(SyntaxKind kind, SyntaxToken operatorToken, ExprSyntax operand, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal PrefixUnaryEx(SyntaxKind kind, SyntaxToken operatorToken, ExprSyntax operand, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal PrefixUnaryEx(SyntaxKind kind, SyntaxToken operatorToken, ExprSyntax operand)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        public ExprSyntax Operand => this.operand;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorToken,
                1 => this.operand,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.PrefixUnaryEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitPrefixUnaryEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitPrefixUnaryEx(this);

        public PrefixUnaryEx Update(SyntaxToken operatorToken, ExprSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.PrefixUnaryEx(this.Kind, operatorToken, operand);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PrefixUnaryEx(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PrefixUnaryEx(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);

        internal PrefixUnaryEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var operand = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.operand);
        }

        static PrefixUnaryEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(PrefixUnaryEx), r => new PrefixUnaryEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
    internal sealed partial class PostfixUnaryEx : ExprSyntax
    {
        internal readonly ExprSyntax operand;
        internal readonly SyntaxToken operatorToken;

        internal PostfixUnaryEx(SyntaxKind kind, ExprSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        internal PostfixUnaryEx(SyntaxKind kind, ExprSyntax operand, SyntaxToken operatorToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        internal PostfixUnaryEx(SyntaxKind kind, ExprSyntax operand, SyntaxToken operatorToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        public ExprSyntax Operand => this.operand;
        /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operand,
                1 => this.operatorToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.PostfixUnaryEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitPostfixUnaryEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitPostfixUnaryEx(this);

        public PostfixUnaryEx Update(ExprSyntax operand, SyntaxToken operatorToken)
        {
            if (operand != this.Operand || operatorToken != this.OperatorToken)
            {
                var newNode = SyntaxFactory.PostfixUnaryEx(this.Kind, operand, operatorToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PostfixUnaryEx(this.Kind, this.operand, this.operatorToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PostfixUnaryEx(this.Kind, this.operand, this.operatorToken, GetDiagnostics(), annotations);

        internal PostfixUnaryEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operand = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(operand);
            this.operand = operand;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operand);
            writer.WriteValue(this.operatorToken);
        }

        static PostfixUnaryEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(PostfixUnaryEx), r => new PostfixUnaryEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for invocation expression.</summary>
    internal sealed partial class InvocationEx : ExprSyntax
    {
        internal readonly ExprSyntax expression;
        internal readonly ArgumentListSyntax argumentList;

        internal InvocationEx(SyntaxKind kind, ExprSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal InvocationEx(SyntaxKind kind, ExprSyntax expression, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal InvocationEx(SyntaxKind kind, ExprSyntax expression, ArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        public ExprSyntax Expression => this.expression;
        /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.
        /// </summary>
        public ArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.InvocationEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInvocationEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitInvocationEx(this);

        public InvocationEx Update(ExprSyntax expression, ArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.InvocationEx(expression, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InvocationEx(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InvocationEx(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);

        internal InvocationEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var argumentList = (ArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.argumentList);
        }

        static InvocationEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(InvocationEx), r => new InvocationEx(r));
        }
    }

    /// <summary>Class which represents an expression that has an assignment operator.</summary>
    internal sealed partial class AssignEx : ExprSyntax
    {
        internal readonly ExprSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExprSyntax right;

        internal AssignEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal AssignEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal AssignEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.
        /// </summary>
        public ExprSyntax Left => this.left;
        /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.
        /// </summary>
        public ExprSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.AssignEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAssignEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitAssignEx(this);

        public AssignEx Update(ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.AssignEx(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AssignEx(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AssignEx(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal AssignEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static AssignEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(AssignEx), r => new AssignEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for element access expression.</summary>
    internal sealed partial class ElementAccessEx : ExprSyntax
    {
        internal readonly ExprSyntax expression;
        internal readonly BracketedArgumentListSyntax argumentList;

        internal ElementAccessEx(SyntaxKind kind, ExprSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ElementAccessEx(SyntaxKind kind, ExprSyntax expression, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ElementAccessEx(SyntaxKind kind, ExprSyntax expression, BracketedArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        public ExprSyntax Expression => this.expression;
        /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access
        /// expression.
        /// </summary>
        public BracketedArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ElementAccessEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitElementAccessEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitElementAccessEx(this);

        public ElementAccessEx Update(ExprSyntax expression, BracketedArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.ElementAccessEx(expression, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElementAccessEx(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElementAccessEx(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);

        internal ElementAccessEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.argumentList);
        }

        static ElementAccessEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElementAccessEx), r => new ElementAccessEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for member access expression.</summary>
    internal sealed partial class MemberAccessEx : ExprSyntax
    {
        internal readonly ExprSyntax expression;
        internal readonly SyntaxToken operatorToken;
        internal readonly NameEx name;

        internal MemberAccessEx(SyntaxKind kind, ExprSyntax expression, SyntaxToken operatorToken, NameEx name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MemberAccessEx(SyntaxKind kind, ExprSyntax expression, SyntaxToken operatorToken, NameEx name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MemberAccessEx(SyntaxKind kind, ExprSyntax expression, SyntaxToken operatorToken, NameEx name)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        public ExprSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        public NameEx Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.operatorToken,
                2 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.MemberAccessEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMemberAccessEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitMemberAccessEx(this);

        public MemberAccessEx Update(ExprSyntax expression, SyntaxToken operatorToken, NameEx name)
        {
            if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MemberAccessEx(this.Kind, expression, operatorToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MemberAccessEx(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MemberAccessEx(this.Kind, this.expression, this.operatorToken, this.name, GetDiagnostics(), annotations);

        internal MemberAccessEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var name = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.name);
        }

        static MemberAccessEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(MemberAccessEx), r => new MemberAccessEx(r));
        }
    }

    internal sealed partial class InterpolatedStringEx : ExprSyntax
    {
        internal readonly SyntaxToken stringStartToken;
        internal readonly GreenNode? contents;
        internal readonly SyntaxToken stringEndToken;

        internal InterpolatedStringEx(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal InterpolatedStringEx(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal InterpolatedStringEx(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        /// <summary>The first part of an interpolated string, $" or $@"</summary>
        public SyntaxToken StringStartToken => this.stringStartToken;
        /// <summary>List of parts of the interpolated string, each one is either a literal part or an
        /// interpolation.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> Contents => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax>(this.contents);
        /// <summary>The closing quote of the interpolated string.</summary>
        public SyntaxToken StringEndToken => this.stringEndToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.stringStartToken,
                1 => this.contents,
                2 => this.stringEndToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.InterpolatedStringEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringEx(this);

        public InterpolatedStringEx Update(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
            if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringEx(stringStartToken, contents, stringEndToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolatedStringEx(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolatedStringEx(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, GetDiagnostics(), annotations);

        internal InterpolatedStringEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var stringStartToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            var contents = (GreenNode?)reader.ReadValue();
            if (contents != null)
            {
                AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            var stringEndToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.stringStartToken);
            writer.WriteValue(this.contents);
            writer.WriteValue(this.stringEndToken);
        }

        static InterpolatedStringEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringEx), r => new InterpolatedStringEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for a range expression.</summary>
    internal sealed partial class RangeEx : ExprSyntax
    {
        internal readonly ExprSyntax? leftOperand;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExprSyntax? rightOperand;

        internal RangeEx(SyntaxKind kind, ExprSyntax? leftOperand, SyntaxToken operatorToken, ExprSyntax? rightOperand, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (leftOperand != null)
            {
                this.AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (rightOperand != null)
            {
                this.AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        internal RangeEx(SyntaxKind kind, ExprSyntax? leftOperand, SyntaxToken operatorToken, ExprSyntax? rightOperand, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (leftOperand != null)
            {
                this.AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (rightOperand != null)
            {
                this.AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        internal RangeEx(SyntaxKind kind, ExprSyntax? leftOperand, SyntaxToken operatorToken, ExprSyntax? rightOperand)
          : base(kind)
        {
            this.SlotCount = 3;
            if (leftOperand != null)
            {
                this.AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (rightOperand != null)
            {
                this.AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
        public ExprSyntax? LeftOperand => this.leftOperand;
        /// <summary>SyntaxToken representing the operator of the range expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
        public ExprSyntax? RightOperand => this.rightOperand;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.leftOperand,
                1 => this.operatorToken,
                2 => this.rightOperand,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.RangeEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitRangeEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitRangeEx(this);

        public RangeEx Update(ExprSyntax leftOperand, SyntaxToken operatorToken, ExprSyntax rightOperand)
        {
            if (leftOperand != this.LeftOperand || operatorToken != this.OperatorToken || rightOperand != this.RightOperand)
            {
                var newNode = SyntaxFactory.RangeEx(leftOperand, operatorToken, rightOperand);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RangeEx(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RangeEx(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, GetDiagnostics(), annotations);

        internal RangeEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var leftOperand = (ExprSyntax?)reader.ReadValue();
            if (leftOperand != null)
            {
                AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var rightOperand = (ExprSyntax?)reader.ReadValue();
            if (rightOperand != null)
            {
                AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.leftOperand);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.rightOperand);
        }

        static RangeEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(RangeEx), r => new RangeEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for conditional expression.</summary>
    internal sealed partial class ConditionalEx : ExprSyntax
    {
        internal readonly ExprSyntax condition;
        internal readonly SyntaxToken questionToken;
        internal readonly ExprSyntax whenTrue;
        internal readonly SyntaxToken colonToken;
        internal readonly ExprSyntax whenFalse;

        internal ConditionalEx(SyntaxKind kind, ExprSyntax condition, SyntaxToken questionToken, ExprSyntax whenTrue, SyntaxToken colonToken, ExprSyntax whenFalse, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        internal ConditionalEx(SyntaxKind kind, ExprSyntax condition, SyntaxToken questionToken, ExprSyntax whenTrue, SyntaxToken colonToken, ExprSyntax whenFalse, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        internal ConditionalEx(SyntaxKind kind, ExprSyntax condition, SyntaxToken questionToken, ExprSyntax whenTrue, SyntaxToken colonToken, ExprSyntax whenFalse)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        public ExprSyntax Condition => this.condition;
        /// <summary>SyntaxToken representing the question mark.</summary>
        public SyntaxToken QuestionToken => this.questionToken;
        /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.
        /// </summary>
        public ExprSyntax WhenTrue => this.whenTrue;
        /// <summary>SyntaxToken representing the colon.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.
        /// </summary>
        public ExprSyntax WhenFalse => this.whenFalse;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.condition,
                1 => this.questionToken,
                2 => this.whenTrue,
                3 => this.colonToken,
                4 => this.whenFalse,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ConditionalEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitConditionalEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitConditionalEx(this);

        public ConditionalEx Update(ExprSyntax condition, SyntaxToken questionToken, ExprSyntax whenTrue, SyntaxToken colonToken, ExprSyntax whenFalse)
        {
            if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
            {
                var newNode = SyntaxFactory.ConditionalEx(condition, questionToken, whenTrue, colonToken, whenFalse);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConditionalEx(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConditionalEx(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, GetDiagnostics(), annotations);

        internal ConditionalEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var condition = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var questionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            var whenTrue = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var whenFalse = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.questionToken);
            writer.WriteValue(this.whenTrue);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.whenFalse);
        }

        static ConditionalEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConditionalEx), r => new ConditionalEx(r));
        }
    }

    internal sealed partial class ThrowEx : ExprSyntax
    {
        internal readonly SyntaxToken throwKeyword;
        internal readonly ExprSyntax expression;

        internal ThrowEx(SyntaxKind kind, SyntaxToken throwKeyword, ExprSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ThrowEx(SyntaxKind kind, SyntaxToken throwKeyword, ExprSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ThrowEx(SyntaxKind kind, SyntaxToken throwKeyword, ExprSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken ThrowKeyword => this.throwKeyword;
        public ExprSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.throwKeyword,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ThrowEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitThrowEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitThrowEx(this);

        public ThrowEx Update(SyntaxToken throwKeyword, ExprSyntax expression)
        {
            if (throwKeyword != this.ThrowKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.ThrowEx(throwKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ThrowEx(this.Kind, this.throwKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ThrowEx(this.Kind, this.throwKeyword, this.expression, GetDiagnostics(), annotations);

        internal ThrowEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var throwKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.throwKeyword);
            writer.WriteValue(this.expression);
        }

        static ThrowEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(ThrowEx), r => new ThrowEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    internal sealed partial class LiteralEx : ExprSyntax
    {
        internal readonly SyntaxToken token;

        internal LiteralEx(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralEx(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralEx(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.
        /// </summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.LiteralEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitLiteralEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitLiteralEx(this);

        public LiteralEx Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralEx(this.Kind, token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LiteralEx(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LiteralEx(this.Kind, this.token, GetDiagnostics(), annotations);

        internal LiteralEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static LiteralEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(LiteralEx), r => new LiteralEx(r));
        }
    }

    /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
    internal sealed partial class ArrowExClause : AquilaSyntaxNode
    {
        internal readonly SyntaxToken arrowToken;
        internal readonly ExprSyntax expression;

        internal ArrowExClause(SyntaxKind kind, SyntaxToken arrowToken, ExprSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArrowExClause(SyntaxKind kind, SyntaxToken arrowToken, ExprSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArrowExClause(SyntaxKind kind, SyntaxToken arrowToken, ExprSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken ArrowToken => this.arrowToken;
        public ExprSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.arrowToken,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ArrowExClause(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArrowExClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitArrowExClause(this);

        public ArrowExClause Update(SyntaxToken arrowToken, ExprSyntax expression)
        {
            if (arrowToken != this.ArrowToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.ArrowExClause(arrowToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrowExClause(this.Kind, this.arrowToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrowExClause(this.Kind, this.arrowToken, this.expression, GetDiagnostics(), annotations);

        internal ArrowExClause(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var arrowToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.arrowToken);
            writer.WriteValue(this.expression);
        }

        static ArrowExClause()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrowExClause), r => new ArrowExClause(r));
        }
    }

    /// <summary>Class which represents the syntax node for initializer expression.</summary>
    internal sealed partial class InitializerEx : ExprSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? expressions;
        internal readonly SyntaxToken closeBraceToken;

        internal InitializerEx(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InitializerEx(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InitializerEx(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer
        /// expression.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> Expressions => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.expressions));
        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.expressions,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.InitializerEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInitializerEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitInitializerEx(this);

        public InitializerEx Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> expressions, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.InitializerEx(this.Kind, openBraceToken, expressions, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InitializerEx(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InitializerEx(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, GetDiagnostics(), annotations);

        internal InitializerEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var expressions = (GreenNode?)reader.ReadValue();
            if (expressions != null)
            {
                AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.expressions);
            writer.WriteValue(this.closeBraceToken);
        }

        static InitializerEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(InitializerEx), r => new InitializerEx(r));
        }
    }

    internal sealed partial class AllocEx : ExprSyntax
    {
        internal readonly TypeEx name;
        internal readonly InitializerEx initializer;

        internal AllocEx(SyntaxKind kind, TypeEx name, InitializerEx initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal AllocEx(SyntaxKind kind, TypeEx name, InitializerEx initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal AllocEx(SyntaxKind kind, TypeEx name, InitializerEx initializer)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public TypeEx Name => this.name;
        /// <summary>Initializer for type</summary>
        public InitializerEx Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.AllocEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAllocEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitAllocEx(this);

        public AllocEx Update(TypeEx name, InitializerEx initializer)
        {
            if (name != this.Name || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.AllocEx(name, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AllocEx(this.Kind, this.name, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AllocEx(this.Kind, this.name, this.initializer, GetDiagnostics(), annotations);

        internal AllocEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var initializer = (InitializerEx)reader.ReadValue();
            AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.initializer);
        }

        static AllocEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(AllocEx), r => new AllocEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for cast expression.</summary>
    internal sealed partial class CastEx : ExprSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeEx type;
        internal readonly SyntaxToken closeParenToken;
        internal readonly ExprSyntax expression;

        internal CastEx(SyntaxKind kind, SyntaxToken openParenToken, TypeEx type, SyntaxToken closeParenToken, ExprSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal CastEx(SyntaxKind kind, SyntaxToken openParenToken, TypeEx type, SyntaxToken closeParenToken, ExprSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal CastEx(SyntaxKind kind, SyntaxToken openParenToken, TypeEx type, SyntaxToken closeParenToken, ExprSyntax expression)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
        public TypeEx Type => this.type;
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;
        /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        public ExprSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.type,
                2 => this.closeParenToken,
                3 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CastEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCastEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCastEx(this);

        public CastEx Update(SyntaxToken openParenToken, TypeEx type, SyntaxToken closeParenToken, ExprSyntax expression)
        {
            if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.CastEx(openParenToken, type, closeParenToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CastEx(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CastEx(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, GetDiagnostics(), annotations);

        internal CastEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.expression);
        }

        static CastEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(CastEx), r => new CastEx(r));
        }
    }

    /// <summary>Represents a match expression syntax.</summary>
    internal sealed partial class MatchEx : ExprSyntax
    {
        internal readonly SyntaxToken matchKeyword;
        internal readonly SyntaxToken? openParenToken;
        internal readonly ExprSyntax expression;
        internal readonly SyntaxToken? closeParenToken;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? arms;
        internal readonly SyntaxToken closeBraceToken;

        internal MatchEx(SyntaxKind kind, SyntaxToken matchKeyword, SyntaxToken? openParenToken, ExprSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(matchKeyword);
            this.matchKeyword = matchKeyword;
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (arms != null)
            {
                this.AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal MatchEx(SyntaxKind kind, SyntaxToken matchKeyword, SyntaxToken? openParenToken, ExprSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(matchKeyword);
            this.matchKeyword = matchKeyword;
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (arms != null)
            {
                this.AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal MatchEx(SyntaxKind kind, SyntaxToken matchKeyword, SyntaxToken? openParenToken, ExprSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(matchKeyword);
            this.matchKeyword = matchKeyword;
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (arms != null)
            {
                this.AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the match keyword.
        /// </summary>
        public SyntaxToken MatchKeyword => this.matchKeyword;
        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
        /// </summary>
        public SyntaxToken? OpenParenToken => this.openParenToken;
        /// <summary>
        /// Gets an ExpressionSyntax representing the expression of the match ex.
        /// </summary>
        public ExprSyntax Expression => this.expression;
        /// <summary>
        /// Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
        /// </summary>
        public SyntaxToken? CloseParenToken => this.closeParenToken;
        /// <summary>
        /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
        /// </summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>
        /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch
        /// statement.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<MatchArm> Arms => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<MatchArm>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.arms));
        /// <summary>
        /// Gets a SyntaxToken that represents the open braces following the switch sections.
        /// </summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.matchKeyword,
                1 => this.openParenToken,
                2 => this.expression,
                3 => this.closeParenToken,
                4 => this.openBraceToken,
                5 => this.arms,
                6 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.MatchEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMatchEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitMatchEx(this);

        public MatchEx Update(SyntaxToken matchKeyword, SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<MatchArm> arms, SyntaxToken closeBraceToken)
        {
            if (matchKeyword != this.MatchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || arms != this.Arms || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.MatchEx(matchKeyword, openParenToken, expression, closeParenToken, openBraceToken, arms, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MatchEx(this.Kind, this.matchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.arms, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MatchEx(this.Kind, this.matchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.arms, this.closeBraceToken, GetDiagnostics(), annotations);

        internal MatchEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var matchKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(matchKeyword);
            this.matchKeyword = matchKeyword;
            var openParenToken = (SyntaxToken?)reader.ReadValue();
            if (openParenToken != null)
            {
                AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken?)reader.ReadValue();
            if (closeParenToken != null)
            {
                AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var arms = (GreenNode?)reader.ReadValue();
            if (arms != null)
            {
                AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.matchKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.arms);
            writer.WriteValue(this.closeBraceToken);
        }

        static MatchEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(MatchEx), r => new MatchEx(r));
        }
    }

    internal sealed partial class MatchArm : AquilaSyntaxNode
    {
        internal readonly SyntaxToken? barToken;
        internal readonly ExprSyntax patternExpression;
        internal readonly SyntaxToken? equalsGreaterThanToken;
        internal readonly ExprSyntax resultExpression;

        internal MatchArm(SyntaxKind kind, SyntaxToken? barToken, ExprSyntax patternExpression, SyntaxToken? equalsGreaterThanToken, ExprSyntax resultExpression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (barToken != null)
            {
                this.AdjustFlagsAndWidth(barToken);
                this.barToken = barToken;
            }
            this.AdjustFlagsAndWidth(patternExpression);
            this.patternExpression = patternExpression;
            if (equalsGreaterThanToken != null)
            {
                this.AdjustFlagsAndWidth(equalsGreaterThanToken);
                this.equalsGreaterThanToken = equalsGreaterThanToken;
            }
            this.AdjustFlagsAndWidth(resultExpression);
            this.resultExpression = resultExpression;
        }

        internal MatchArm(SyntaxKind kind, SyntaxToken? barToken, ExprSyntax patternExpression, SyntaxToken? equalsGreaterThanToken, ExprSyntax resultExpression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (barToken != null)
            {
                this.AdjustFlagsAndWidth(barToken);
                this.barToken = barToken;
            }
            this.AdjustFlagsAndWidth(patternExpression);
            this.patternExpression = patternExpression;
            if (equalsGreaterThanToken != null)
            {
                this.AdjustFlagsAndWidth(equalsGreaterThanToken);
                this.equalsGreaterThanToken = equalsGreaterThanToken;
            }
            this.AdjustFlagsAndWidth(resultExpression);
            this.resultExpression = resultExpression;
        }

        internal MatchArm(SyntaxKind kind, SyntaxToken? barToken, ExprSyntax patternExpression, SyntaxToken? equalsGreaterThanToken, ExprSyntax resultExpression)
          : base(kind)
        {
            this.SlotCount = 4;
            if (barToken != null)
            {
                this.AdjustFlagsAndWidth(barToken);
                this.barToken = barToken;
            }
            this.AdjustFlagsAndWidth(patternExpression);
            this.patternExpression = patternExpression;
            if (equalsGreaterThanToken != null)
            {
                this.AdjustFlagsAndWidth(equalsGreaterThanToken);
                this.equalsGreaterThanToken = equalsGreaterThanToken;
            }
            this.AdjustFlagsAndWidth(resultExpression);
            this.resultExpression = resultExpression;
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
        /// </summary>
        public SyntaxToken? BarToken => this.barToken;
        /// <summary>
        /// Gets an ExpressionSyntax representing the expression of the match ex.
        /// </summary>
        public ExprSyntax PatternExpression => this.patternExpression;
        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
        /// </summary>
        public SyntaxToken? EqualsGreaterThanToken => this.equalsGreaterThanToken;
        /// <summary>
        /// Gets an ExpressionSyntax representing the expression of the match ex.
        /// </summary>
        public ExprSyntax ResultExpression => this.resultExpression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.barToken,
                1 => this.patternExpression,
                2 => this.equalsGreaterThanToken,
                3 => this.resultExpression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.MatchArm(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMatchArm(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitMatchArm(this);

        public MatchArm Update(SyntaxToken barToken, ExprSyntax patternExpression, SyntaxToken equalsGreaterThanToken, ExprSyntax resultExpression)
        {
            if (barToken != this.BarToken || patternExpression != this.PatternExpression || equalsGreaterThanToken != this.EqualsGreaterThanToken || resultExpression != this.ResultExpression)
            {
                var newNode = SyntaxFactory.MatchArm(barToken, patternExpression, equalsGreaterThanToken, resultExpression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MatchArm(this.Kind, this.barToken, this.patternExpression, this.equalsGreaterThanToken, this.resultExpression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MatchArm(this.Kind, this.barToken, this.patternExpression, this.equalsGreaterThanToken, this.resultExpression, GetDiagnostics(), annotations);

        internal MatchArm(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var barToken = (SyntaxToken?)reader.ReadValue();
            if (barToken != null)
            {
                AdjustFlagsAndWidth(barToken);
                this.barToken = barToken;
            }
            var patternExpression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(patternExpression);
            this.patternExpression = patternExpression;
            var equalsGreaterThanToken = (SyntaxToken?)reader.ReadValue();
            if (equalsGreaterThanToken != null)
            {
                AdjustFlagsAndWidth(equalsGreaterThanToken);
                this.equalsGreaterThanToken = equalsGreaterThanToken;
            }
            var resultExpression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(resultExpression);
            this.resultExpression = resultExpression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.barToken);
            writer.WriteValue(this.patternExpression);
            writer.WriteValue(this.equalsGreaterThanToken);
            writer.WriteValue(this.resultExpression);
        }

        static MatchArm()
        {
            ObjectBinder.RegisterTypeReader(typeof(MatchArm), r => new MatchArm(r));
        }
    }

    internal abstract partial class InterpolatedStringContentSyntax : AquilaSyntaxNode
    {
        internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal InterpolatedStringContentSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected InterpolatedStringContentSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
    {
        internal readonly SyntaxToken textToken;

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        /// <summary>The text contents of a part of the interpolated string.</summary>
        public SyntaxToken TextToken => this.textToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.textToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.InterpolatedStringTextSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringText(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringText(this);

        public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
        {
            if (textToken != this.TextToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringText(textToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolatedStringTextSyntax(this.Kind, this.textToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolatedStringTextSyntax(this.Kind, this.textToken, GetDiagnostics(), annotations);

        internal InterpolatedStringTextSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var textToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.textToken);
        }

        static InterpolatedStringTextSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringTextSyntax), r => new InterpolatedStringTextSyntax(r));
        }
    }

    internal sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly ExprSyntax expression;
        internal readonly InterpolationAlignmentClauseSyntax? alignmentClause;
        internal readonly InterpolationFormatClauseSyntax? formatClause;
        internal readonly SyntaxToken closeBraceToken;

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExprSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (alignmentClause != null)
            {
                this.AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            if (formatClause != null)
            {
                this.AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExprSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (alignmentClause != null)
            {
                this.AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            if (formatClause != null)
            {
                this.AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExprSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (alignmentClause != null)
            {
                this.AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            if (formatClause != null)
            {
                this.AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public ExprSyntax Expression => this.expression;
        public InterpolationAlignmentClauseSyntax? AlignmentClause => this.alignmentClause;
        public InterpolationFormatClauseSyntax? FormatClause => this.formatClause;
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.expression,
                2 => this.alignmentClause,
                3 => this.formatClause,
                4 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.InterpolationSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolation(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolation(this);

        public InterpolationSyntax Update(SyntaxToken openBraceToken, ExprSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, GetDiagnostics(), annotations);

        internal InterpolationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var alignmentClause = (InterpolationAlignmentClauseSyntax?)reader.ReadValue();
            if (alignmentClause != null)
            {
                AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            var formatClause = (InterpolationFormatClauseSyntax?)reader.ReadValue();
            if (formatClause != null)
            {
                AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.alignmentClause);
            writer.WriteValue(this.formatClause);
            writer.WriteValue(this.closeBraceToken);
        }

        static InterpolationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolationSyntax), r => new InterpolationSyntax(r));
        }
    }

    internal sealed partial class InterpolationAlignmentClauseSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken commaToken;
        internal readonly ExprSyntax value;

        internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExprSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExprSyntax value, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExprSyntax value)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        public SyntaxToken CommaToken => this.commaToken;
        public ExprSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.commaToken,
                1 => this.value,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.InterpolationAlignmentClauseSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolationAlignmentClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolationAlignmentClause(this);

        public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExprSyntax value)
        {
            if (commaToken != this.CommaToken || value != this.Value)
            {
                var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, GetDiagnostics(), annotations);

        internal InterpolationAlignmentClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var commaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            var value = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.commaToken);
            writer.WriteValue(this.value);
        }

        static InterpolationAlignmentClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolationAlignmentClauseSyntax), r => new InterpolationAlignmentClauseSyntax(r));
        }
    }

    internal sealed partial class InterpolationFormatClauseSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken colonToken;
        internal readonly SyntaxToken formatStringToken;

        internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>The text contents of the format specifier for an interpolation.</summary>
        public SyntaxToken FormatStringToken => this.formatStringToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.colonToken,
                1 => this.formatStringToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.InterpolationFormatClauseSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolationFormatClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolationFormatClause(this);

        public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
        {
            if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
            {
                var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, GetDiagnostics(), annotations);

        internal InterpolationFormatClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var formatStringToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.formatStringToken);
        }

        static InterpolationFormatClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolationFormatClauseSyntax), r => new InterpolationFormatClauseSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are
    /// derived. This is an abstract class.
    /// </summary>
    internal abstract partial class BaseArgumentListSyntax : AquilaSyntaxNode
    {
        internal BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseArgumentListSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
    }

    /// <summary>Class which represents the syntax node for the list of arguments.</summary>
    internal sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken closeParenToken;

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.arguments,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ArgumentListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArgumentList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitArgumentList(this);

        public ArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

        internal ArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        static ArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArgumentListSyntax), r => new ArgumentListSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
    internal sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken closeBracketToken;

        internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>SyntaxToken representing open bracket.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing close bracket.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.arguments,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.BracketedArgumentListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBracketedArgumentList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitBracketedArgumentList(this);

        public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, GetDiagnostics(), annotations);

        internal BracketedArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeBracketToken);
        }

        static BracketedArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BracketedArgumentListSyntax), r => new BracketedArgumentListSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for argument.</summary>
    internal sealed partial class ArgumentSyntax : AquilaSyntaxNode
    {
        internal readonly NameColonSyntax? nameColon;
        internal readonly SyntaxToken? refKindKeyword;
        internal readonly ExprSyntax expression;

        internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExprSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExprSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExprSyntax expression)
          : base(kind)
        {
            this.SlotCount = 3;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
        public NameColonSyntax? NameColon => this.nameColon;
        /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        public SyntaxToken? RefKindKeyword => this.refKindKeyword;
        /// <summary>ExpressionSyntax node representing the argument.</summary>
        public ExprSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.nameColon,
                1 => this.refKindKeyword,
                2 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ArgumentSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArgument(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitArgument(this);

        public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExprSyntax expression)
        {
            if (nameColon != this.NameColon || refKindKeyword != this.RefKindKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.Argument(nameColon, refKindKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, GetDiagnostics(), annotations);

        internal ArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var nameColon = (NameColonSyntax?)reader.ReadValue();
            if (nameColon != null)
            {
                AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            var refKindKeyword = (SyntaxToken?)reader.ReadValue();
            if (refKindKeyword != null)
            {
                AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.refKindKeyword);
            writer.WriteValue(this.expression);
        }

        static ArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArgumentSyntax), r => new ArgumentSyntax(r));
        }
    }

    internal abstract partial class BaseExpressionColonSyntax : AquilaSyntaxNode
    {
        internal BaseExpressionColonSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseExpressionColonSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseExpressionColonSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract ExprSyntax Expression { get; }

        public abstract SyntaxToken ColonToken { get; }
    }

    internal sealed partial class ExprColonSyntax : BaseExpressionColonSyntax
    {
        internal readonly ExprSyntax expression;
        internal readonly SyntaxToken colonToken;

        internal ExprColonSyntax(SyntaxKind kind, ExprSyntax expression, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal ExprColonSyntax(SyntaxKind kind, ExprSyntax expression, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal ExprColonSyntax(SyntaxKind kind, ExprSyntax expression, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        public override ExprSyntax Expression => this.expression;
        public override SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ExprColonSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitExprColon(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitExprColon(this);

        public ExprColonSyntax Update(ExprSyntax expression, SyntaxToken colonToken)
        {
            if (expression != this.Expression || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.ExprColon(expression, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExprColonSyntax(this.Kind, this.expression, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExprColonSyntax(this.Kind, this.expression, this.colonToken, GetDiagnostics(), annotations);

        internal ExprColonSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.colonToken);
        }

        static ExprColonSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExprColonSyntax), r => new ExprColonSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for name colon syntax.</summary>
    internal sealed partial class NameColonSyntax : BaseExpressionColonSyntax
    {
        internal readonly IdentifierEx name;
        internal readonly SyntaxToken colonToken;

        internal NameColonSyntax(SyntaxKind kind, IdentifierEx name, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal NameColonSyntax(SyntaxKind kind, IdentifierEx name, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal NameColonSyntax(SyntaxKind kind, IdentifierEx name, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public IdentifierEx Name => this.name;
        /// <summary>SyntaxToken representing colon.</summary>
        public override SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.NameColonSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitNameColon(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitNameColon(this);

        public NameColonSyntax Update(IdentifierEx name, SyntaxToken colonToken)
        {
            if (name != this.Name || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.NameColon(name, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NameColonSyntax(this.Kind, this.name, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NameColonSyntax(this.Kind, this.name, this.colonToken, GetDiagnostics(), annotations);

        internal NameColonSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (IdentifierEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.colonToken);
        }

        static NameColonSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NameColonSyntax), r => new NameColonSyntax(r));
        }
    }

    internal abstract partial class TypeEx : ExprSyntax
    {
        internal TypeEx(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TypeEx(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TypeEx(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal abstract partial class NameEx : TypeEx
    {
        internal NameEx(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal NameEx(SyntaxKind kind)
          : base(kind)
        {
        }

        protected NameEx(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Class which represents the syntax node for qualified name.</summary>
    internal sealed partial class QualifiedNameEx : NameEx
    {
        internal readonly NameEx left;
        internal readonly SyntaxToken dotToken;
        internal readonly SimpleNameEx right;

        internal QualifiedNameEx(SyntaxKind kind, NameEx left, SyntaxToken dotToken, SimpleNameEx right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal QualifiedNameEx(SyntaxKind kind, NameEx left, SyntaxToken dotToken, SimpleNameEx right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal QualifiedNameEx(SyntaxKind kind, NameEx left, SyntaxToken dotToken, SimpleNameEx right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified
        /// name.
        /// </summary>
        public NameEx Left => this.left;
        /// <summary>SyntaxToken representing the dot.</summary>
        public SyntaxToken DotToken => this.dotToken;
        /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified
        /// name.
        /// </summary>
        public SimpleNameEx Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.dotToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.QualifiedNameEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitQualifiedNameEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitQualifiedNameEx(this);

        public QualifiedNameEx Update(NameEx left, SyntaxToken dotToken, SimpleNameEx right)
        {
            if (left != this.Left || dotToken != this.DotToken || right != this.Right)
            {
                var newNode = SyntaxFactory.QualifiedNameEx(left, dotToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new QualifiedNameEx(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new QualifiedNameEx(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);

        internal QualifiedNameEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (NameEx)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var dotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            var right = (SimpleNameEx)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.right);
        }

        static QualifiedNameEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(QualifiedNameEx), r => new QualifiedNameEx(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived.
    /// This is an abstract class.
    /// </summary>
    internal abstract partial class SimpleNameEx : NameEx
    {
        internal SimpleNameEx(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal SimpleNameEx(SyntaxKind kind)
          : base(kind)
        {
        }

        protected SimpleNameEx(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
        public abstract SyntaxToken Identifier { get; }
    }

    internal sealed partial class IdentifierEx : SimpleNameEx
    {
        internal readonly SyntaxToken identifier;

        internal IdentifierEx(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierEx(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierEx(SyntaxKind kind, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>Gets the identifier.</summary>
        public override SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.identifier : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.IdentifierEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIdentifierEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitIdentifierEx(this);

        public IdentifierEx Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierEx(identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IdentifierEx(this.Kind, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IdentifierEx(this.Kind, this.identifier, GetDiagnostics(), annotations);

        internal IdentifierEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
        }

        static IdentifierEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(IdentifierEx), r => new IdentifierEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for generic name.</summary>
    internal sealed partial class GenericEx : SimpleNameEx
    {
        internal readonly SyntaxToken identifier;
        internal readonly TypeArgumentListSyntax typeArgumentList;

        internal GenericEx(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        internal GenericEx(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        internal GenericEx(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        public override SyntaxToken Identifier => this.identifier;
        /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.
        /// </summary>
        public TypeArgumentListSyntax TypeArgumentList => this.typeArgumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.typeArgumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.GenericEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitGenericEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitGenericEx(this);

        public GenericEx Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        {
            if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
            {
                var newNode = SyntaxFactory.GenericEx(identifier, typeArgumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GenericEx(this.Kind, this.identifier, this.typeArgumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GenericEx(this.Kind, this.identifier, this.typeArgumentList, GetDiagnostics(), annotations);

        internal GenericEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeArgumentList = (TypeArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeArgumentList);
        }

        static GenericEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(GenericEx), r => new GenericEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for predefined types.</summary>
    internal sealed partial class PredefinedTypeEx : TypeEx
    {
        internal readonly SyntaxToken keyword;

        internal PredefinedTypeEx(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        internal PredefinedTypeEx(SyntaxKind kind, SyntaxToken keyword, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        internal PredefinedTypeEx(SyntaxKind kind, SyntaxToken keyword)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        public SyntaxToken Keyword => this.keyword;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.keyword : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.PredefinedTypeEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitPredefinedTypeEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitPredefinedTypeEx(this);

        public PredefinedTypeEx Update(SyntaxToken keyword)
        {
            if (keyword != this.Keyword)
            {
                var newNode = SyntaxFactory.PredefinedTypeEx(keyword);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PredefinedTypeEx(this.Kind, this.keyword, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PredefinedTypeEx(this.Kind, this.keyword, GetDiagnostics(), annotations);

        internal PredefinedTypeEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
        }

        static PredefinedTypeEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(PredefinedTypeEx), r => new PredefinedTypeEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for the array type.</summary>
    internal sealed partial class ArrayTypeEx : TypeEx
    {
        internal readonly TypeEx elementType;
        internal readonly GreenNode? rankSpecifiers;

        internal ArrayTypeEx(SyntaxKind kind, TypeEx elementType, GreenNode? rankSpecifiers, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null)
            {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        internal ArrayTypeEx(SyntaxKind kind, TypeEx elementType, GreenNode? rankSpecifiers, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null)
            {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        internal ArrayTypeEx(SyntaxKind kind, TypeEx elementType, GreenNode? rankSpecifiers)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null)
            {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
        public TypeEx ElementType => this.elementType;
        /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the
        /// array.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax>(this.rankSpecifiers);

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elementType,
                1 => this.rankSpecifiers,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ArrayTypeEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArrayTypeEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitArrayTypeEx(this);

        public ArrayTypeEx Update(TypeEx elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
        {
            if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
            {
                var newNode = SyntaxFactory.ArrayTypeEx(elementType, rankSpecifiers);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrayTypeEx(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrayTypeEx(this.Kind, this.elementType, this.rankSpecifiers, GetDiagnostics(), annotations);

        internal ArrayTypeEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elementType = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            var rankSpecifiers = (GreenNode?)reader.ReadValue();
            if (rankSpecifiers != null)
            {
                AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elementType);
            writer.WriteValue(this.rankSpecifiers);
        }

        static ArrayTypeEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrayTypeEx), r => new ArrayTypeEx(r));
        }
    }

    internal sealed partial class UnionTypeEx : TypeEx
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? types;
        internal readonly SyntaxToken closeParenToken;

        internal UnionTypeEx(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? types, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal UnionTypeEx(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? types, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal UnionTypeEx(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? types, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>
        /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch
        /// statement.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> Types => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.types));
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.types,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.UnionTypeEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitUnionTypeEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitUnionTypeEx(this);

        public UnionTypeEx Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> types, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || types != this.Types || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.UnionTypeEx(openParenToken, types, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnionTypeEx(this.Kind, this.openParenToken, this.types, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnionTypeEx(this.Kind, this.openParenToken, this.types, this.closeParenToken, GetDiagnostics(), annotations);

        internal UnionTypeEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var types = (GreenNode?)reader.ReadValue();
            if (types != null)
            {
                AdjustFlagsAndWidth(types);
                this.types = types;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.types);
            writer.WriteValue(this.closeParenToken);
        }

        static UnionTypeEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnionTypeEx), r => new UnionTypeEx(r));
        }
    }

    /// <summary>The ref modifier of a method's return value or a local.</summary>
    internal sealed partial class RefTypeEx : TypeEx
    {
        internal readonly SyntaxToken refKeyword;
        internal readonly SyntaxToken? readOnlyKeyword;
        internal readonly TypeEx type;

        internal RefTypeEx(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeEx type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            if (readOnlyKeyword != null)
            {
                this.AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal RefTypeEx(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeEx type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            if (readOnlyKeyword != null)
            {
                this.AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal RefTypeEx(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeEx type)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            if (readOnlyKeyword != null)
            {
                this.AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        public SyntaxToken RefKeyword => this.refKeyword;
        /// <summary>Gets the optional "readonly" keyword.</summary>
        public SyntaxToken? ReadOnlyKeyword => this.readOnlyKeyword;
        public TypeEx Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.refKeyword,
                1 => this.readOnlyKeyword,
                2 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.RefTypeEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitRefTypeEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitRefTypeEx(this);

        public RefTypeEx Update(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeEx type)
        {
            if (refKeyword != this.RefKeyword || readOnlyKeyword != this.ReadOnlyKeyword || type != this.Type)
            {
                var newNode = SyntaxFactory.RefTypeEx(refKeyword, readOnlyKeyword, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RefTypeEx(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RefTypeEx(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, GetDiagnostics(), annotations);

        internal RefTypeEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var refKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            var readOnlyKeyword = (SyntaxToken?)reader.ReadValue();
            if (readOnlyKeyword != null)
            {
                AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.refKeyword);
            writer.WriteValue(this.readOnlyKeyword);
            writer.WriteValue(this.type);
        }

        static RefTypeEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(RefTypeEx), r => new RefTypeEx(r));
        }
    }

    /// <summary>Class which represents the syntax node for type argument list.</summary>
    internal sealed partial class TypeArgumentListSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken greaterThanToken;

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>SyntaxToken representing less than.</summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing greater than.</summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.arguments,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.TypeArgumentListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeArgumentList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeArgumentList(this);

        public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> arguments, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);

        internal TypeArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.greaterThanToken);
        }

        static TypeArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeArgumentListSyntax), r => new TypeArgumentListSyntax(r));
        }
    }

    internal sealed partial class ArrayRankSpecifierSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? sizes;
        internal readonly SyntaxToken closeBracketToken;

        internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null)
            {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null)
            {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null)
            {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> Sizes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.sizes));
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.sizes,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ArrayRankSpecifierSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArrayRankSpecifier(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitArrayRankSpecifier(this);

        public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> sizes, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, GetDiagnostics(), annotations);

        internal ArrayRankSpecifierSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var sizes = (GreenNode?)reader.ReadValue();
            if (sizes != null)
            {
                AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.sizes);
            writer.WriteValue(this.closeBracketToken);
        }

        static ArrayRankSpecifierSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrayRankSpecifierSyntax), r => new ArrayRankSpecifierSyntax(r));
        }
    }

    /// <summary>Class which represents a placeholder in an array size list.</summary>
    internal sealed partial class OmittedArraySizeEx : ExprSyntax
    {
        internal readonly SyntaxToken omittedArraySizeExpressionToken;

        internal OmittedArraySizeEx(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        internal OmittedArraySizeEx(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        internal OmittedArraySizeEx(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        /// <summary>SyntaxToken representing the omitted array size expression.</summary>
        public SyntaxToken OmittedArraySizeExpressionToken => this.omittedArraySizeExpressionToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.omittedArraySizeExpressionToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.OmittedArraySizeEx(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitOmittedArraySizeEx(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitOmittedArraySizeEx(this);

        public OmittedArraySizeEx Update(SyntaxToken omittedArraySizeExpressionToken)
        {
            if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
            {
                var newNode = SyntaxFactory.OmittedArraySizeEx(omittedArraySizeExpressionToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OmittedArraySizeEx(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OmittedArraySizeEx(this.Kind, this.omittedArraySizeExpressionToken, GetDiagnostics(), annotations);

        internal OmittedArraySizeEx(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var omittedArraySizeExpressionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.omittedArraySizeExpressionToken);
        }

        static OmittedArraySizeEx()
        {
            ObjectBinder.RegisterTypeReader(typeof(OmittedArraySizeEx), r => new OmittedArraySizeEx(r));
        }
    }

    /// <summary>Base type for parameter list syntax.</summary>
    internal abstract partial class BaseParameterListSyntax : AquilaSyntaxNode
    {
        internal BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseParameterListSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the parameter list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
    }

    /// <summary>Parameter list syntax.</summary>
    internal sealed partial class ParameterListSyntax : BaseParameterListSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeParenToken;

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.parameters));
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.parameters,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ParameterListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenToken);
        }

        static ParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterListSyntax), r => new ParameterListSyntax(r));
        }
    }

    /// <summary>Parameter list syntax with surrounding brackets.</summary>
    internal sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeBracketToken;

        internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.parameters));
        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.parameters,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.BracketedParameterListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBracketedParameterList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitBracketedParameterList(this);

        public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);

        internal BracketedParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeBracketToken);
        }

        static BracketedParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BracketedParameterListSyntax), r => new BracketedParameterListSyntax(r));
        }
    }

    /// <summary>Base parameter syntax.</summary>
    internal abstract partial class BaseParameterSyntax : AquilaSyntaxNode
    {
        internal BaseParameterSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseParameterSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseParameterSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

        /// <summary>Gets the modifier list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }

        public abstract TypeEx? Type { get; }
    }

    /// <summary>Parameter syntax.</summary>
    internal sealed partial class ParameterSyntax : BaseParameterSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken identifier;
        internal readonly TypeEx? type;
        internal readonly EqualsValueClauseSyntax? @default;

        internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, TypeEx? type, EqualsValueClauseSyntax? @default, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            if (@default != null)
            {
                this.AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, TypeEx? type, EqualsValueClauseSyntax? @default, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            if (@default != null)
            {
                this.AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, TypeEx? type, EqualsValueClauseSyntax? @default)
          : base(kind)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            if (@default != null)
            {
                this.AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>Gets the modifier list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public override TypeEx? Type => this.type;
        public EqualsValueClauseSyntax? Default => this.@default;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.identifier,
                3 => this.type,
                4 => this.@default,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ParameterSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitParameter(this);

        public ParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, TypeEx type, EqualsValueClauseSyntax @default)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || type != this.Type || @default != this.Default)
            {
                var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, identifier, type, @default);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.type, this.@default, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.type, this.@default, GetDiagnostics(), annotations);

        internal ParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var type = (TypeEx?)reader.ReadValue();
            if (type != null)
            {
                AdjustFlagsAndWidth(type);
                this.type = type;
            }
            var @default = (EqualsValueClauseSyntax?)reader.ReadValue();
            if (@default != null)
            {
                AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.type);
            writer.WriteValue(this.@default);
        }

        static ParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterSyntax), r => new ParameterSyntax(r));
        }
    }

    /// <summary>Parameter syntax.</summary>
    internal sealed partial class FunctionPointerParameterSyntax : BaseParameterSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeEx type;

        internal FunctionPointerParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal FunctionPointerParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal FunctionPointerParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx type)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>Gets the modifier list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public override TypeEx Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.FunctionPointerParameterSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitFunctionPointerParameter(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionPointerParameter(this);

        public FunctionPointerParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx type)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
            {
                var newNode = SyntaxFactory.FunctionPointerParameter(attributeLists, modifiers, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionPointerParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionPointerParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, GetDiagnostics(), annotations);

        internal FunctionPointerParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
        }

        static FunctionPointerParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionPointerParameterSyntax), r => new FunctionPointerParameterSyntax(r));
        }
    }

    internal sealed partial class IncompleteMemberSyntax : MemberDecl
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeEx? type;

        internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx? type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx? type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeEx? type)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public TypeEx? Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.IncompleteMemberSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIncompleteMember(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitIncompleteMember(this);

        public IncompleteMemberSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx type)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
            {
                var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, GetDiagnostics(), annotations);

        internal IncompleteMemberSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeEx?)reader.ReadValue();
            if (type != null)
            {
                AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
        }

        static IncompleteMemberSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IncompleteMemberSyntax), r => new IncompleteMemberSyntax(r));
        }
    }

    internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? tokens;

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.SkippedTokensTriviaSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);

        internal SkippedTokensTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tokens = (GreenNode?)reader.ReadValue();
            if (tokens != null)
            {
                AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tokens);
        }

        static SkippedTokensTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
        }
    }

    internal sealed partial class EqualsValueClauseSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken equalsToken;
        internal readonly ExprSyntax value;

        internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExprSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExprSyntax value, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExprSyntax value)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        public SyntaxToken EqualsToken => this.equalsToken;
        public ExprSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.equalsToken,
                1 => this.value,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.EqualsValueClauseSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitEqualsValueClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitEqualsValueClause(this);

        public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExprSyntax value)
        {
            if (equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.EqualsValueClause(equalsToken, value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, GetDiagnostics(), annotations);

        internal EqualsValueClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var value = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.value);
        }

        static EqualsValueClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EqualsValueClauseSyntax), r => new EqualsValueClauseSyntax(r));
        }
    }

    internal sealed partial class VariableDecl : AquilaSyntaxNode
    {
        internal readonly TypeEx type;
        internal readonly GreenNode? variables;

        internal VariableDecl(SyntaxKind kind, TypeEx type, GreenNode? variables, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        internal VariableDecl(SyntaxKind kind, TypeEx type, GreenNode? variables, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        internal VariableDecl(SyntaxKind kind, TypeEx type, GreenNode? variables)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        public TypeEx Type => this.type;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableInit> Variables => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableInit>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.variables));

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.variables,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.VariableDecl(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitVariableDecl(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitVariableDecl(this);

        public VariableDecl Update(TypeEx type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableInit> variables)
        {
            if (type != this.Type || variables != this.Variables)
            {
                var newNode = SyntaxFactory.VariableDecl(type, variables);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VariableDecl(this.Kind, this.type, this.variables, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VariableDecl(this.Kind, this.type, this.variables, GetDiagnostics(), annotations);

        internal VariableDecl(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var variables = (GreenNode?)reader.ReadValue();
            if (variables != null)
            {
                AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.variables);
        }

        static VariableDecl()
        {
            ObjectBinder.RegisterTypeReader(typeof(VariableDecl), r => new VariableDecl(r));
        }
    }

    internal sealed partial class VariableInit : AquilaSyntaxNode
    {
        internal readonly SyntaxToken identifier;
        internal readonly BracketedArgumentListSyntax? argumentList;
        internal readonly EqualsValueClauseSyntax? initializer;

        internal VariableInit(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal VariableInit(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal VariableInit(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public BracketedArgumentListSyntax? ArgumentList => this.argumentList;
        public EqualsValueClauseSyntax? Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.argumentList,
                2 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.VariableInit(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitVariableInit(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitVariableInit(this);

        public VariableInit Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
        {
            if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.VariableInit(identifier, argumentList, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VariableInit(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VariableInit(this.Kind, this.identifier, this.argumentList, this.initializer, GetDiagnostics(), annotations);

        internal VariableInit(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var argumentList = (BracketedArgumentListSyntax?)reader.ReadValue();
            if (argumentList != null)
            {
                AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            var initializer = (EqualsValueClauseSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.argumentList);
            writer.WriteValue(this.initializer);
        }

        static VariableInit()
        {
            ObjectBinder.RegisterTypeReader(typeof(VariableInit), r => new VariableInit(r));
        }
    }

    internal sealed partial class BlockStmt : StmtSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? statements;
        internal readonly SyntaxToken closeBraceToken;

        internal BlockStmt(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal BlockStmt(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal BlockStmt(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StmtSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StmtSyntax>(this.statements);
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.statements,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.BlockStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBlockStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitBlockStmt(this);

        public BlockStmt Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StmtSyntax> statements, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.BlockStmt(openBraceToken, statements, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BlockStmt(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BlockStmt(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, GetDiagnostics(), annotations);

        internal BlockStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.statements);
            writer.WriteValue(this.closeBraceToken);
        }

        static BlockStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(BlockStmt), r => new BlockStmt(r));
        }
    }

    internal sealed partial class ExpressionStmt : StmtSyntax
    {
        internal readonly ExprSyntax expression;
        internal readonly SyntaxToken semicolonToken;

        internal ExpressionStmt(SyntaxKind kind, ExprSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ExpressionStmt(SyntaxKind kind, ExprSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ExpressionStmt(SyntaxKind kind, ExprSyntax expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public ExprSyntax Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ExpressionStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitExpressionStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionStmt(this);

        public ExpressionStmt Update(ExprSyntax expression, SyntaxToken semicolonToken)
        {
            if (expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ExpressionStmt(expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionStmt(this.Kind, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionStmt(this.Kind, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal ExpressionStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static ExpressionStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionStmt), r => new ExpressionStmt(r));
        }
    }

    internal sealed partial class EmptyStmt : StmtSyntax
    {
        internal readonly SyntaxToken semicolonToken;

        internal EmptyStmt(SyntaxKind kind, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal EmptyStmt(SyntaxKind kind, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal EmptyStmt(SyntaxKind kind, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.semicolonToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.EmptyStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitEmptyStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitEmptyStmt(this);

        public EmptyStmt Update(SyntaxToken semicolonToken)
        {
            if (semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EmptyStmt(semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EmptyStmt(this.Kind, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EmptyStmt(this.Kind, this.semicolonToken, GetDiagnostics(), annotations);

        internal EmptyStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.semicolonToken);
        }

        static EmptyStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(EmptyStmt), r => new EmptyStmt(r));
        }
    }

    /// <summary>Represents a labeled statement syntax.</summary>
    internal sealed partial class LabeledStmt : StmtSyntax
    {
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken colonToken;
        internal readonly StmtSyntax statement;

        internal LabeledStmt(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StmtSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal LabeledStmt(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StmtSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal LabeledStmt(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StmtSyntax statement)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        public StmtSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.colonToken,
                2 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.LabeledStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitLabeledStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitLabeledStmt(this);

        public LabeledStmt Update(SyntaxToken identifier, SyntaxToken colonToken, StmtSyntax statement)
        {
            if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.LabeledStmt(identifier, colonToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LabeledStmt(this.Kind, this.identifier, this.colonToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LabeledStmt(this.Kind, this.identifier, this.colonToken, this.statement, GetDiagnostics(), annotations);

        internal LabeledStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.statement);
        }

        static LabeledStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(LabeledStmt), r => new LabeledStmt(r));
        }
    }

    /// <summary>
    /// Represents a goto statement syntax
    /// </summary>
    internal sealed partial class GotoStmt : StmtSyntax
    {
        internal readonly SyntaxToken gotoKeyword;
        internal readonly SyntaxToken? caseOrDefaultKeyword;
        internal readonly ExprSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal GotoStmt(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null)
            {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal GotoStmt(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null)
            {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal GotoStmt(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null)
            {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the goto keyword.
        /// </summary>
        public SyntaxToken GotoKeyword => this.gotoKeyword;
        /// <summary>
        /// Gets a SyntaxToken that represents the case or default keywords if any exists.
        /// </summary>
        public SyntaxToken? CaseOrDefaultKeyword => this.caseOrDefaultKeyword;
        /// <summary>
        /// Gets a constant expression for a goto case statement.
        /// </summary>
        public ExprSyntax? Expression => this.expression;
        /// <summary>
        /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
        /// </summary>
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.gotoKeyword,
                1 => this.caseOrDefaultKeyword,
                2 => this.expression,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.GotoStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitGotoStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitGotoStmt(this);

        public GotoStmt Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExprSyntax expression, SyntaxToken semicolonToken)
        {
            if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoStmt(this.Kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GotoStmt(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GotoStmt(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal GotoStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var gotoKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            var caseOrDefaultKeyword = (SyntaxToken?)reader.ReadValue();
            if (caseOrDefaultKeyword != null)
            {
                AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            var expression = (ExprSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.gotoKeyword);
            writer.WriteValue(this.caseOrDefaultKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static GotoStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(GotoStmt), r => new GotoStmt(r));
        }
    }

    internal sealed partial class BreakStmt : StmtSyntax
    {
        internal readonly SyntaxToken breakKeyword;
        internal readonly SyntaxToken semicolonToken;

        internal BreakStmt(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal BreakStmt(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal BreakStmt(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken BreakKeyword => this.breakKeyword;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.breakKeyword,
                1 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.BreakStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBreakStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitBreakStmt(this);

        public BreakStmt Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
            if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.BreakStmt(breakKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BreakStmt(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BreakStmt(this.Kind, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal BreakStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var breakKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.breakKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static BreakStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(BreakStmt), r => new BreakStmt(r));
        }
    }

    internal sealed partial class ContinueStmt : StmtSyntax
    {
        internal readonly SyntaxToken continueKeyword;
        internal readonly SyntaxToken semicolonToken;

        internal ContinueStmt(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ContinueStmt(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ContinueStmt(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken ContinueKeyword => this.continueKeyword;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.continueKeyword,
                1 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ContinueStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitContinueStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitContinueStmt(this);

        public ContinueStmt Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
            if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ContinueStmt(continueKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ContinueStmt(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ContinueStmt(this.Kind, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal ContinueStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var continueKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.continueKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static ContinueStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(ContinueStmt), r => new ContinueStmt(r));
        }
    }

    internal sealed partial class ReturnStmt : StmtSyntax
    {
        internal readonly SyntaxToken returnKeyword;
        internal readonly ExprSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal ReturnStmt(SyntaxKind kind, SyntaxToken returnKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ReturnStmt(SyntaxKind kind, SyntaxToken returnKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ReturnStmt(SyntaxKind kind, SyntaxToken returnKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken ReturnKeyword => this.returnKeyword;
        public ExprSyntax? Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.returnKeyword,
                1 => this.expression,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ReturnStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitReturnStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitReturnStmt(this);

        public ReturnStmt Update(SyntaxToken returnKeyword, ExprSyntax expression, SyntaxToken semicolonToken)
        {
            if (returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ReturnStmt(returnKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ReturnStmt(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ReturnStmt(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal ReturnStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var returnKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            var expression = (ExprSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.returnKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static ReturnStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(ReturnStmt), r => new ReturnStmt(r));
        }
    }

    internal sealed partial class ThrowStmt : StmtSyntax
    {
        internal readonly SyntaxToken throwKeyword;
        internal readonly ExprSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal ThrowStmt(SyntaxKind kind, SyntaxToken throwKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ThrowStmt(SyntaxKind kind, SyntaxToken throwKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ThrowStmt(SyntaxKind kind, SyntaxToken throwKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken ThrowKeyword => this.throwKeyword;
        public ExprSyntax? Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.throwKeyword,
                1 => this.expression,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ThrowStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitThrowStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitThrowStmt(this);

        public ThrowStmt Update(SyntaxToken throwKeyword, ExprSyntax expression, SyntaxToken semicolonToken)
        {
            if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ThrowStmt(throwKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ThrowStmt(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ThrowStmt(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal ThrowStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var throwKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            var expression = (ExprSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.throwKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static ThrowStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(ThrowStmt), r => new ThrowStmt(r));
        }
    }

    internal sealed partial class YieldStmt : StmtSyntax
    {
        internal readonly SyntaxToken yieldKeyword;
        internal readonly SyntaxToken returnOrBreakKeyword;
        internal readonly ExprSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal YieldStmt(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal YieldStmt(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExprSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal YieldStmt(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken YieldKeyword => this.yieldKeyword;
        public SyntaxToken ReturnOrBreakKeyword => this.returnOrBreakKeyword;
        public ExprSyntax? Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.yieldKeyword,
                1 => this.returnOrBreakKeyword,
                2 => this.expression,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.YieldStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitYieldStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitYieldStmt(this);

        public YieldStmt Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExprSyntax expression, SyntaxToken semicolonToken)
        {
            if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.YieldStmt(this.Kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new YieldStmt(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new YieldStmt(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal YieldStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var yieldKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            var returnOrBreakKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            var expression = (ExprSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.yieldKeyword);
            writer.WriteValue(this.returnOrBreakKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static YieldStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(YieldStmt), r => new YieldStmt(r));
        }
    }

    internal sealed partial class WhileStmt : StmtSyntax
    {
        internal readonly SyntaxToken whileKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExprSyntax condition;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StmtSyntax statement;

        internal WhileStmt(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal WhileStmt(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal WhileStmt(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public SyntaxToken WhileKeyword => this.whileKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public ExprSyntax Condition => this.condition;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StmtSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whileKeyword,
                1 => this.openParenToken,
                2 => this.condition,
                3 => this.closeParenToken,
                4 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.WhileStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitWhileStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitWhileStmt(this);

        public WhileStmt Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement)
        {
            if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.WhileStmt(whileKeyword, openParenToken, condition, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhileStmt(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhileStmt(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal WhileStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var condition = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static WhileStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhileStmt), r => new WhileStmt(r));
        }
    }

    internal sealed partial class DoStmt : StmtSyntax
    {
        internal readonly SyntaxToken doKeyword;
        internal readonly StmtSyntax statement;
        internal readonly SyntaxToken whileKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExprSyntax condition;
        internal readonly SyntaxToken closeParenToken;
        internal readonly SyntaxToken semicolonToken;

        internal DoStmt(SyntaxKind kind, SyntaxToken doKeyword, StmtSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal DoStmt(SyntaxKind kind, SyntaxToken doKeyword, StmtSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal DoStmt(SyntaxKind kind, SyntaxToken doKeyword, StmtSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken DoKeyword => this.doKeyword;
        public StmtSyntax Statement => this.statement;
        public SyntaxToken WhileKeyword => this.whileKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public ExprSyntax Condition => this.condition;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.doKeyword,
                1 => this.statement,
                2 => this.whileKeyword,
                3 => this.openParenToken,
                4 => this.condition,
                5 => this.closeParenToken,
                6 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.DoStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitDoStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitDoStmt(this);

        public DoStmt Update(SyntaxToken doKeyword, StmtSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        {
            if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.DoStmt(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DoStmt(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DoStmt(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal DoStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var condition = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.statement);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.semicolonToken);
        }

        static DoStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(DoStmt), r => new DoStmt(r));
        }
    }

    internal sealed partial class ForStmt : StmtSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly VariableDecl? declaration;
        internal readonly GreenNode? initializers;
        internal readonly SyntaxToken firstSemicolonToken;
        internal readonly ExprSyntax? condition;
        internal readonly SyntaxToken secondSemicolonToken;
        internal readonly GreenNode? incrementors;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StmtSyntax statement;

        internal ForStmt(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDecl? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExprSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StmtSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null)
            {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null)
            {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForStmt(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDecl? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExprSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StmtSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null)
            {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null)
            {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForStmt(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDecl? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExprSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StmtSyntax statement)
          : base(kind)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null)
            {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null)
            {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public VariableDecl? Declaration => this.declaration;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> Initializers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.initializers));
        public SyntaxToken FirstSemicolonToken => this.firstSemicolonToken;
        public ExprSyntax? Condition => this.condition;
        public SyntaxToken SecondSemicolonToken => this.secondSemicolonToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> Incrementors => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.incrementors));
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StmtSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.openParenToken,
                2 => this.declaration,
                3 => this.initializers,
                4 => this.firstSemicolonToken,
                5 => this.condition,
                6 => this.secondSemicolonToken,
                7 => this.incrementors,
                8 => this.closeParenToken,
                9 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ForStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitForStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitForStmt(this);

        public ForStmt Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDecl declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> initializers, SyntaxToken firstSemicolonToken, ExprSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> incrementors, SyntaxToken closeParenToken, StmtSyntax statement)
        {
            if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ForStmt(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForStmt(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForStmt(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal ForStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 10;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var declaration = (VariableDecl?)reader.ReadValue();
            if (declaration != null)
            {
                AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            var initializers = (GreenNode?)reader.ReadValue();
            if (initializers != null)
            {
                AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            var firstSemicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            var condition = (ExprSyntax?)reader.ReadValue();
            if (condition != null)
            {
                AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            var secondSemicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            var incrementors = (GreenNode?)reader.ReadValue();
            if (incrementors != null)
            {
                AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.initializers);
            writer.WriteValue(this.firstSemicolonToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.secondSemicolonToken);
            writer.WriteValue(this.incrementors);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static ForStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForStmt), r => new ForStmt(r));
        }
    }

    internal sealed partial class ForEachStmt : StmtSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExprSyntax expression;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StmtSyntax statement;

        internal ForEachStmt(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken identifier, SyntaxToken inKeyword, ExprSyntax expression, SyntaxToken closeParenToken, StmtSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForEachStmt(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken identifier, SyntaxToken inKeyword, ExprSyntax expression, SyntaxToken closeParenToken, StmtSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForEachStmt(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken identifier, SyntaxToken inKeyword, ExprSyntax expression, SyntaxToken closeParenToken, StmtSyntax statement)
          : base(kind)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public SyntaxToken ForKeyword => this.forKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public SyntaxToken InKeyword => this.inKeyword;
        public ExprSyntax Expression => this.expression;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StmtSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.openParenToken,
                2 => this.identifier,
                3 => this.inKeyword,
                4 => this.expression,
                5 => this.closeParenToken,
                6 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ForEachStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitForEachStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitForEachStmt(this);

        public ForEachStmt Update(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken identifier, SyntaxToken inKeyword, ExprSyntax expression, SyntaxToken closeParenToken, StmtSyntax statement)
        {
            if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ForEachStmt(forKeyword, openParenToken, identifier, inKeyword, expression, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForEachStmt(this.Kind, this.forKeyword, this.openParenToken, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForEachStmt(this.Kind, this.forKeyword, this.openParenToken, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal ForEachStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static ForEachStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForEachStmt), r => new ForEachStmt(r));
        }
    }

    internal sealed partial class LocalDeclStmt : StmtSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly VariableDecl declaration;
        internal readonly SyntaxToken semicolonToken;

        internal LocalDeclStmt(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDecl declaration, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal LocalDeclStmt(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDecl declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal LocalDeclStmt(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDecl declaration, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>Gets the modifier list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public VariableDecl Declaration => this.declaration;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.declaration,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.LocalDeclStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitLocalDeclStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitLocalDeclStmt(this);

        public LocalDeclStmt Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDecl declaration, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalDeclStmt(attributeLists, modifiers, declaration, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LocalDeclStmt(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LocalDeclStmt(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);

        internal LocalDeclStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var declaration = (VariableDecl)reader.ReadValue();
            AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.semicolonToken);
        }

        static LocalDeclStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(LocalDeclStmt), r => new LocalDeclStmt(r));
        }
    }

    /// <summary>
    /// Represents an if statement syntax.
    /// </summary>
    internal sealed partial class IfStmt : StmtSyntax
    {
        internal readonly SyntaxToken ifKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExprSyntax condition;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StmtSyntax statement;
        internal readonly ElseClauseSyntax? @else;

        internal IfStmt(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, ElseClauseSyntax? @else, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfStmt(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, ElseClauseSyntax? @else, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfStmt(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, ElseClauseSyntax? @else)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the if keyword.
        /// </summary>
        public SyntaxToken IfKeyword => this.ifKeyword;
        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition
        /// expression.
        /// </summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>
        /// Gets an ExpressionSyntax that represents the condition of the if statement.
        /// </summary>
        public ExprSyntax Condition => this.condition;
        /// <summary>
        /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition
        /// expression.
        /// </summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;
        /// <summary>
        /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
        /// </summary>
        public StmtSyntax Statement => this.statement;
        /// <summary>
        /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if
        /// such statement exists.
        /// </summary>
        public ElseClauseSyntax? Else => this.@else;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.ifKeyword,
                1 => this.openParenToken,
                2 => this.condition,
                3 => this.closeParenToken,
                4 => this.statement,
                5 => this.@else,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.IfStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIfStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitIfStmt(this);

        public IfStmt Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, ElseClauseSyntax @else)
        {
            if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
            {
                var newNode = SyntaxFactory.IfStmt(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfStmt(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfStmt(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, GetDiagnostics(), annotations);

        internal IfStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var ifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var condition = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
            var @else = (ElseClauseSyntax?)reader.ReadValue();
            if (@else != null)
            {
                AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
            writer.WriteValue(this.@else);
        }

        static IfStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfStmt), r => new IfStmt(r));
        }
    }

    /// <summary>Represents an else statement syntax.</summary>
    internal sealed partial class ElseClauseSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken elseKeyword;
        internal readonly StmtSyntax statement;

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StmtSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StmtSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StmtSyntax statement)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        /// <summary>
        /// Gets a syntax token
        /// </summary>
        public SyntaxToken ElseKeyword => this.elseKeyword;
        public StmtSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elseKeyword,
                1 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ElseClauseSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StmtSyntax statement)
        {
            if (elseKeyword != this.ElseKeyword || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, GetDiagnostics(), annotations);

        internal ElseClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elseKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.statement);
        }

        static ElseClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseClauseSyntax), r => new ElseClauseSyntax(r));
        }
    }

    internal sealed partial class TryStmt : StmtSyntax
    {
        internal readonly SyntaxToken tryKeyword;
        internal readonly BlockStmt block;
        internal readonly GreenNode? catches;
        internal readonly FinallyClauseSyntax? @finally;

        internal TryStmt(SyntaxKind kind, SyntaxToken tryKeyword, BlockStmt block, GreenNode? catches, FinallyClauseSyntax? @finally, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null)
            {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if (@finally != null)
            {
                this.AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        internal TryStmt(SyntaxKind kind, SyntaxToken tryKeyword, BlockStmt block, GreenNode? catches, FinallyClauseSyntax? @finally, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null)
            {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if (@finally != null)
            {
                this.AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        internal TryStmt(SyntaxKind kind, SyntaxToken tryKeyword, BlockStmt block, GreenNode? catches, FinallyClauseSyntax? @finally)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null)
            {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if (@finally != null)
            {
                this.AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        public SyntaxToken TryKeyword => this.tryKeyword;
        public BlockStmt Block => this.block;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> Catches => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax>(this.catches);
        public FinallyClauseSyntax? Finally => this.@finally;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.tryKeyword,
                1 => this.block,
                2 => this.catches,
                3 => this.@finally,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.TryStmt(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTryStmt(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitTryStmt(this);

        public TryStmt Update(SyntaxToken tryKeyword, BlockStmt block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
        {
            if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
            {
                var newNode = SyntaxFactory.TryStmt(tryKeyword, block, catches, @finally);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TryStmt(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TryStmt(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, GetDiagnostics(), annotations);

        internal TryStmt(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var tryKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            var block = (BlockStmt)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var catches = (GreenNode?)reader.ReadValue();
            if (catches != null)
            {
                AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            var @finally = (FinallyClauseSyntax?)reader.ReadValue();
            if (@finally != null)
            {
                AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tryKeyword);
            writer.WriteValue(this.block);
            writer.WriteValue(this.catches);
            writer.WriteValue(this.@finally);
        }

        static TryStmt()
        {
            ObjectBinder.RegisterTypeReader(typeof(TryStmt), r => new TryStmt(r));
        }
    }

    internal sealed partial class CatchClauseSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken catchKeyword;
        internal readonly CatchDeclarationSyntax? declaration;
        internal readonly CatchFilterClauseSyntax? filter;
        internal readonly BlockStmt block;

        internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockStmt block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null)
            {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockStmt block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null)
            {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockStmt block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null)
            {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken CatchKeyword => this.catchKeyword;
        public CatchDeclarationSyntax? Declaration => this.declaration;
        public CatchFilterClauseSyntax? Filter => this.filter;
        public BlockStmt Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.catchKeyword,
                1 => this.declaration,
                2 => this.filter,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CatchClauseSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCatchClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCatchClause(this);

        public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockStmt block)
        {
            if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block)
            {
                var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, GetDiagnostics(), annotations);

        internal CatchClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var catchKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            var declaration = (CatchDeclarationSyntax?)reader.ReadValue();
            if (declaration != null)
            {
                AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            var filter = (CatchFilterClauseSyntax?)reader.ReadValue();
            if (filter != null)
            {
                AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            var block = (BlockStmt)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.catchKeyword);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.filter);
            writer.WriteValue(this.block);
        }

        static CatchClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CatchClauseSyntax), r => new CatchClauseSyntax(r));
        }
    }

    internal sealed partial class CatchDeclarationSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeEx type;
        internal readonly SyntaxToken? identifier;
        internal readonly SyntaxToken closeParenToken;

        internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeEx type, SyntaxToken? identifier, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeEx type, SyntaxToken? identifier, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeEx type, SyntaxToken? identifier, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        public SyntaxToken OpenParenToken => this.openParenToken;
        public TypeEx Type => this.type;
        public SyntaxToken? Identifier => this.identifier;
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.type,
                2 => this.identifier,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CatchDeclarationSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCatchDeclaration(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCatchDeclaration(this);

        public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeEx type, SyntaxToken identifier, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, GetDiagnostics(), annotations);

        internal CatchDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var identifier = (SyntaxToken?)reader.ReadValue();
            if (identifier != null)
            {
                AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.closeParenToken);
        }

        static CatchDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CatchDeclarationSyntax), r => new CatchDeclarationSyntax(r));
        }
    }

    internal sealed partial class CatchFilterClauseSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken whenKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExprSyntax filterExpression;
        internal readonly SyntaxToken closeParenToken;

        internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExprSyntax filterExpression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExprSyntax filterExpression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExprSyntax filterExpression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        public SyntaxToken WhenKeyword => this.whenKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public ExprSyntax FilterExpression => this.filterExpression;
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whenKeyword,
                1 => this.openParenToken,
                2 => this.filterExpression,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CatchFilterClauseSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCatchFilterClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCatchFilterClause(this);

        public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExprSyntax filterExpression, SyntaxToken closeParenToken)
        {
            if (whenKeyword != this.WhenKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CatchFilterClause(whenKeyword, openParenToken, filterExpression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, GetDiagnostics(), annotations);

        internal CatchFilterClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var whenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var filterExpression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whenKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.filterExpression);
            writer.WriteValue(this.closeParenToken);
        }

        static CatchFilterClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CatchFilterClauseSyntax), r => new CatchFilterClauseSyntax(r));
        }
    }

    internal sealed partial class FinallyClauseSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken finallyKeyword;
        internal readonly BlockStmt block;

        internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockStmt block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockStmt block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockStmt block)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken FinallyKeyword => this.finallyKeyword;
        public BlockStmt Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.finallyKeyword,
                1 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.FinallyClauseSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitFinallyClause(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitFinallyClause(this);

        public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockStmt block)
        {
            if (finallyKeyword != this.FinallyKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, GetDiagnostics(), annotations);

        internal FinallyClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var finallyKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            var block = (BlockStmt)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.finallyKeyword);
            writer.WriteValue(this.block);
        }

        static FinallyClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FinallyClauseSyntax), r => new FinallyClauseSyntax(r));
        }
    }

    internal sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? content;
        internal readonly SyntaxToken endOfComment;

        internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment)
          : base(kind)
        {
            this.SlotCount = 2;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content);
        public SyntaxToken EndOfComment => this.endOfComment;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.content,
                1 => this.endOfComment,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.DocumentationCommentTriviaSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitDocumentationCommentTrivia(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitDocumentationCommentTrivia(this);

        public DocumentationCommentTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
        {
            if (content != this.Content || endOfComment != this.EndOfComment)
            {
                var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind, content, endOfComment);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, GetDiagnostics(), annotations);

        internal DocumentationCommentTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var content = (GreenNode?)reader.ReadValue();
            if (content != null)
            {
                AdjustFlagsAndWidth(content);
                this.content = content;
            }
            var endOfComment = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.content);
            writer.WriteValue(this.endOfComment);
        }

        static DocumentationCommentTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DocumentationCommentTriviaSyntax), r => new DocumentationCommentTriviaSyntax(r));
        }
    }

    /// <summary>
    /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment
    /// tag).
    /// For example, the M in &lt;see cref="M" /&gt;.
    /// </summary>
    internal abstract partial class CrefSyntax : AquilaSyntaxNode
    {
        internal CrefSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal CrefSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected CrefSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>
    /// A symbol reference that definitely refers to a type.
    /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    internal sealed partial class TypeCrefSyntax : CrefSyntax
    {
        internal readonly TypeEx type;

        internal TypeCrefSyntax(SyntaxKind kind, TypeEx type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeCrefSyntax(SyntaxKind kind, TypeEx type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeCrefSyntax(SyntaxKind kind, TypeEx type)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        public TypeEx Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.type : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.TypeCrefSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeCref(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeCref(this);

        public TypeCrefSyntax Update(TypeEx type)
        {
            if (type != this.Type)
            {
                var newNode = SyntaxFactory.TypeCref(type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeCrefSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeCrefSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

        internal TypeCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
        }

        static TypeCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeCrefSyntax), r => new TypeCrefSyntax(r));
        }
    }

    /// <summary>
    /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
    /// For example, cref="System.String.ToString()".
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    internal sealed partial class QualifiedCrefSyntax : CrefSyntax
    {
        internal readonly TypeEx container;
        internal readonly SyntaxToken dotToken;
        internal readonly MemberCrefSyntax member;

        internal QualifiedCrefSyntax(SyntaxKind kind, TypeEx container, SyntaxToken dotToken, MemberCrefSyntax member, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
        }

        internal QualifiedCrefSyntax(SyntaxKind kind, TypeEx container, SyntaxToken dotToken, MemberCrefSyntax member, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
        }

        internal QualifiedCrefSyntax(SyntaxKind kind, TypeEx container, SyntaxToken dotToken, MemberCrefSyntax member)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
        }

        public TypeEx Container => this.container;
        public SyntaxToken DotToken => this.dotToken;
        public MemberCrefSyntax Member => this.member;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.container,
                1 => this.dotToken,
                2 => this.member,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.QualifiedCrefSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitQualifiedCref(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitQualifiedCref(this);

        public QualifiedCrefSyntax Update(TypeEx container, SyntaxToken dotToken, MemberCrefSyntax member)
        {
            if (container != this.Container || dotToken != this.DotToken || member != this.Member)
            {
                var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, GetDiagnostics(), annotations);

        internal QualifiedCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var container = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(container);
            this.container = container;
            var dotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            var member = (MemberCrefSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(member);
            this.member = member;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.container);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.member);
        }

        static QualifiedCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(QualifiedCrefSyntax), r => new QualifiedCrefSyntax(r));
        }
    }

    /// <summary>
    /// The unqualified part of a CrefSyntax.
    /// For example, "ToString()" in "object.ToString()".
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    internal abstract partial class MemberCrefSyntax : CrefSyntax
    {
        internal MemberCrefSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal MemberCrefSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected MemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified
    /// name,
    /// with an optional type parameter list) and an optional parameter list.
    /// For example, "M", "M&lt;T&gt;" or "M(int)".
    /// Also, "A::B()" or "string()".
    /// </summary>
    internal sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly TypeEx name;
        internal readonly CrefParameterListSyntax? parameters;

        internal NameMemberCrefSyntax(SyntaxKind kind, TypeEx name, CrefParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal NameMemberCrefSyntax(SyntaxKind kind, TypeEx name, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal NameMemberCrefSyntax(SyntaxKind kind, TypeEx name, CrefParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public TypeEx Name => this.name;
        public CrefParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.NameMemberCrefSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitNameMemberCref(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitNameMemberCref(this);

        public NameMemberCrefSyntax Update(TypeEx name, CrefParameterListSyntax parameters)
        {
            if (name != this.Name || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.NameMemberCref(name, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, GetDiagnostics(), annotations);

        internal NameMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var parameters = (CrefParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.parameters);
        }

        static NameMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NameMemberCrefSyntax), r => new NameMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
    /// For example, "this" or "this[int]".
    /// </summary>
    internal sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly SyntaxToken thisKeyword;
        internal readonly CrefBracketedParameterListSyntax? parameters;

        internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public SyntaxToken ThisKeyword => this.thisKeyword;
        public CrefBracketedParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.thisKeyword,
                1 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.IndexerMemberCrefSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIndexerMemberCref(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitIndexerMemberCref(this);

        public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
        {
            if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, GetDiagnostics(), annotations);

        internal IndexerMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var thisKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            var parameters = (CrefBracketedParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.thisKeyword);
            writer.WriteValue(this.parameters);
        }

        static IndexerMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IndexerMemberCrefSyntax), r => new IndexerMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
    /// For example, "operator +" or "operator -[int]".
    /// NOTE: the operator must be overloadable.
    /// </summary>
    internal sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly SyntaxToken operatorKeyword;
        internal readonly SyntaxToken operatorToken;
        internal readonly CrefParameterListSyntax? parameters;

        internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public SyntaxToken OperatorKeyword => this.operatorKeyword;
        /// <summary>Gets the operator token.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        public CrefParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorKeyword,
                1 => this.operatorToken,
                2 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.OperatorMemberCrefSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitOperatorMemberCref(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitOperatorMemberCref(this);

        public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
        {
            if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, GetDiagnostics(), annotations);

        internal OperatorMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var operatorKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var parameters = (CrefParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.parameters);
        }

        static OperatorMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(OperatorMemberCrefSyntax), r => new OperatorMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination
    /// type, and an optional parameter list.
    /// For example, "implicit operator int" or "explicit operator MyType(int)".
    /// </summary>
    internal sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly SyntaxToken implicitOrExplicitKeyword;
        internal readonly SyntaxToken operatorKeyword;
        internal readonly TypeEx type;
        internal readonly CrefParameterListSyntax? parameters;

        internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeEx type, CrefParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeEx type, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeEx type, CrefParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public SyntaxToken ImplicitOrExplicitKeyword => this.implicitOrExplicitKeyword;
        public SyntaxToken OperatorKeyword => this.operatorKeyword;
        public TypeEx Type => this.type;
        public CrefParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.implicitOrExplicitKeyword,
                1 => this.operatorKeyword,
                2 => this.type,
                3 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.ConversionOperatorMemberCrefSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitConversionOperatorMemberCref(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitConversionOperatorMemberCref(this);

        public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeEx type, CrefParameterListSyntax parameters)
        {
            if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, GetDiagnostics(), annotations);

        internal ConversionOperatorMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            var operatorKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var parameters = (CrefParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.implicitOrExplicitKeyword);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.parameters);
        }

        static ConversionOperatorMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConversionOperatorMemberCrefSyntax), r => new ConversionOperatorMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A list of cref parameters with surrounding punctuation.
    /// Unlike regular parameters, cref parameters do not have names.
    /// </summary>
    internal abstract partial class BaseCrefParameterListSyntax : AquilaSyntaxNode
    {
        internal BaseCrefParameterListSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseCrefParameterListSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseCrefParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the parameter list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
    }

    /// <summary>
    /// A parenthesized list of cref parameters.
    /// </summary>
    internal sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeParenToken;

        internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.parameters));
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.parameters,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CrefParameterListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCrefParameterList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCrefParameterList(this);

        public CrefParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);

        internal CrefParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenToken);
        }

        static CrefParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CrefParameterListSyntax), r => new CrefParameterListSyntax(r));
        }
    }

    /// <summary>
    /// A bracketed list of cref parameters.
    /// </summary>
    internal sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeBracketToken;

        internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.parameters));
        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.parameters,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CrefBracketedParameterListSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCrefBracketedParameterList(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCrefBracketedParameterList(this);

        public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);

        internal CrefBracketedParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeBracketToken);
        }

        static CrefBracketedParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CrefBracketedParameterListSyntax), r => new CrefBracketedParameterListSyntax(r));
        }
    }

    /// <summary>
    /// An element of a BaseCrefParameterListSyntax.
    /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
    /// there is no name and there are no attributes or other modifiers.
    /// </summary>
    internal sealed partial class CrefParameterSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken? refKindKeyword;
        internal readonly TypeEx type;

        internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeEx type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeEx type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeEx type)
          : base(kind)
        {
            this.SlotCount = 2;
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        public SyntaxToken? RefKindKeyword => this.refKindKeyword;
        public TypeEx Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.refKindKeyword,
                1 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.CrefParameterSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCrefParameter(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitCrefParameter(this);

        public CrefParameterSyntax Update(SyntaxToken refKindKeyword, TypeEx type)
        {
            if (refKindKeyword != this.RefKindKeyword || type != this.Type)
            {
                var newNode = SyntaxFactory.CrefParameter(refKindKeyword, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, GetDiagnostics(), annotations);

        internal CrefParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var refKindKeyword = (SyntaxToken?)reader.ReadValue();
            if (refKindKeyword != null)
            {
                AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            var type = (TypeEx)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.refKindKeyword);
            writer.WriteValue(this.type);
        }

        static CrefParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CrefParameterSyntax), r => new CrefParameterSyntax(r));
        }
    }

    internal abstract partial class XmlNodeSyntax : AquilaSyntaxNode
    {
        internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal XmlNodeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected XmlNodeSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class XmlElementSyntax : XmlNodeSyntax
    {
        internal readonly XmlElementStartTagSyntax startTag;
        internal readonly GreenNode? content;
        internal readonly XmlElementEndTagSyntax endTag;

        internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        public XmlElementStartTagSyntax StartTag => this.startTag;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content);
        public XmlElementEndTagSyntax EndTag => this.endTag;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.startTag,
                1 => this.content,
                2 => this.endTag,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlElementSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlElement(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElement(this);

        public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
        {
            if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
            {
                var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);

        internal XmlElementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var startTag = (XmlElementStartTagSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            var content = (GreenNode?)reader.ReadValue();
            if (content != null)
            {
                AdjustFlagsAndWidth(content);
                this.content = content;
            }
            var endTag = (XmlElementEndTagSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.startTag);
            writer.WriteValue(this.content);
            writer.WriteValue(this.endTag);
        }

        static XmlElementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlElementSyntax), r => new XmlElementSyntax(r));
        }
    }

    internal sealed partial class XmlElementStartTagSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly XmlNameSyntax name;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken greaterThanToken;

        internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        public SyntaxToken LessThanToken => this.lessThanToken;
        public XmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes);
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.name,
                2 => this.attributes,
                3 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlElementStartTagSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlElementStartTag(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElementStartTag(this);

        public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);

        internal XmlElementStartTagSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.greaterThanToken);
        }

        static XmlElementStartTagSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlElementStartTagSyntax), r => new XmlElementStartTagSyntax(r));
        }
    }

    internal sealed partial class XmlElementEndTagSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken lessThanSlashToken;
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken greaterThanToken;

        internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        public SyntaxToken LessThanSlashToken => this.lessThanSlashToken;
        public XmlNameSyntax Name => this.name;
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanSlashToken,
                1 => this.name,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlElementEndTagSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlElementEndTag(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElementEndTag(this);

        public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        {
            if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);

        internal XmlElementEndTagSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanSlashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanSlashToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.greaterThanToken);
        }

        static XmlElementEndTagSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlElementEndTagSyntax), r => new XmlElementEndTagSyntax(r));
        }
    }

    internal sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly XmlNameSyntax name;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken slashGreaterThanToken;

        internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        public SyntaxToken LessThanToken => this.lessThanToken;
        public XmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes);
        public SyntaxToken SlashGreaterThanToken => this.slashGreaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.name,
                2 => this.attributes,
                3 => this.slashGreaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlEmptyElementSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlEmptyElement(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlEmptyElement(this);

        public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);

        internal XmlEmptyElementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.slashGreaterThanToken);
        }

        static XmlEmptyElementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlEmptyElementSyntax), r => new XmlEmptyElementSyntax(r));
        }
    }

    internal sealed partial class XmlNameSyntax : AquilaSyntaxNode
    {
        internal readonly XmlPrefixSyntax? prefix;
        internal readonly SyntaxToken localName;

        internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (prefix != null)
            {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (prefix != null)
            {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName)
          : base(kind)
        {
            this.SlotCount = 2;
            if (prefix != null)
            {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        public XmlPrefixSyntax? Prefix => this.prefix;
        public SyntaxToken LocalName => this.localName;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.prefix,
                1 => this.localName,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlNameSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlName(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlName(this);

        public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
        {
            if (prefix != this.Prefix || localName != this.LocalName)
            {
                var newNode = SyntaxFactory.XmlName(prefix, localName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlNameSyntax(this.Kind, this.prefix, this.localName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlNameSyntax(this.Kind, this.prefix, this.localName, GetDiagnostics(), annotations);

        internal XmlNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var prefix = (XmlPrefixSyntax?)reader.ReadValue();
            if (prefix != null)
            {
                AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            var localName = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.prefix);
            writer.WriteValue(this.localName);
        }

        static XmlNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlNameSyntax), r => new XmlNameSyntax(r));
        }
    }

    internal sealed partial class XmlPrefixSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken prefix;
        internal readonly SyntaxToken colonToken;

        internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        public SyntaxToken Prefix => this.prefix;
        public SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.prefix,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlPrefixSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlPrefix(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlPrefix(this);

        public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
        {
            if (prefix != this.Prefix || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, GetDiagnostics(), annotations);

        internal XmlPrefixSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var prefix = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.prefix);
            writer.WriteValue(this.colonToken);
        }

        static XmlPrefixSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlPrefixSyntax), r => new XmlPrefixSyntax(r));
        }
    }

    internal abstract partial class XmlAttributeSyntax : AquilaSyntaxNode
    {
        internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal XmlAttributeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected XmlAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract XmlNameSyntax Name { get; }

        public abstract SyntaxToken EqualsToken { get; }

        public abstract SyntaxToken StartQuoteToken { get; }

        public abstract SyntaxToken EndQuoteToken { get; }
    }

    internal sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
    {
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly SyntaxToken startQuoteToken;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken endQuoteToken;

        internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        public override XmlNameSyntax Name => this.name;
        public override SyntaxToken EqualsToken => this.equalsToken;
        public override SyntaxToken StartQuoteToken => this.startQuoteToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public override SyntaxToken EndQuoteToken => this.endQuoteToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                2 => this.startQuoteToken,
                3 => this.textTokens,
                4 => this.endQuoteToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlTextAttributeSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlTextAttribute(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlTextAttribute(this);

        public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, GetDiagnostics(), annotations);

        internal XmlTextAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var startQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var endQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endQuoteToken);
        }

        static XmlTextAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlTextAttributeSyntax), r => new XmlTextAttributeSyntax(r));
        }
    }

    internal sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
    {
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly SyntaxToken startQuoteToken;
        internal readonly CrefSyntax cref;
        internal readonly SyntaxToken endQuoteToken;

        internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        public override XmlNameSyntax Name => this.name;
        public override SyntaxToken EqualsToken => this.equalsToken;
        public override SyntaxToken StartQuoteToken => this.startQuoteToken;
        public CrefSyntax Cref => this.cref;
        public override SyntaxToken EndQuoteToken => this.endQuoteToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                2 => this.startQuoteToken,
                3 => this.cref,
                4 => this.endQuoteToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlCrefAttributeSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlCrefAttribute(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlCrefAttribute(this);

        public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, GetDiagnostics(), annotations);

        internal XmlCrefAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var startQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            var cref = (CrefSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(cref);
            this.cref = cref;
            var endQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.cref);
            writer.WriteValue(this.endQuoteToken);
        }

        static XmlCrefAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlCrefAttributeSyntax), r => new XmlCrefAttributeSyntax(r));
        }
    }

    internal sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
    {
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly SyntaxToken startQuoteToken;
        internal readonly IdentifierEx identifier;
        internal readonly SyntaxToken endQuoteToken;

        internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierEx identifier, SyntaxToken endQuoteToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierEx identifier, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierEx identifier, SyntaxToken endQuoteToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        public override XmlNameSyntax Name => this.name;
        public override SyntaxToken EqualsToken => this.equalsToken;
        public override SyntaxToken StartQuoteToken => this.startQuoteToken;
        public IdentifierEx Identifier => this.identifier;
        public override SyntaxToken EndQuoteToken => this.endQuoteToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                2 => this.startQuoteToken,
                3 => this.identifier,
                4 => this.endQuoteToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlNameAttributeSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlNameAttribute(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlNameAttribute(this);

        public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierEx identifier, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, GetDiagnostics(), annotations);

        internal XmlNameAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var startQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            var identifier = (IdentifierEx)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var endQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.endQuoteToken);
        }

        static XmlNameAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlNameAttributeSyntax), r => new XmlNameAttributeSyntax(r));
        }
    }

    internal sealed partial class XmlTextSyntax : XmlNodeSyntax
    {
        internal readonly GreenNode? textTokens;

        internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.textTokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlTextSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlText(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlText(this);

        public XmlTextSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
        {
            if (textTokens != this.TextTokens)
            {
                var newNode = SyntaxFactory.XmlText(textTokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlTextSyntax(this.Kind, this.textTokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlTextSyntax(this.Kind, this.textTokens, GetDiagnostics(), annotations);

        internal XmlTextSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.textTokens);
        }

        static XmlTextSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlTextSyntax), r => new XmlTextSyntax(r));
        }
    }

    internal sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken startCDataToken;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken endCDataToken;

        internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        public SyntaxToken StartCDataToken => this.startCDataToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public SyntaxToken EndCDataToken => this.endCDataToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.startCDataToken,
                1 => this.textTokens,
                2 => this.endCDataToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlCDataSectionSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlCDataSection(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlCDataSection(this);

        public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
        {
            if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
            {
                var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, GetDiagnostics(), annotations);

        internal XmlCDataSectionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var startCDataToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var endCDataToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.startCDataToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endCDataToken);
        }

        static XmlCDataSectionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlCDataSectionSyntax), r => new XmlCDataSectionSyntax(r));
        }
    }

    internal sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken startProcessingInstructionToken;
        internal readonly XmlNameSyntax name;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken endProcessingInstructionToken;

        internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        public SyntaxToken StartProcessingInstructionToken => this.startProcessingInstructionToken;
        public XmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public SyntaxToken EndProcessingInstructionToken => this.endProcessingInstructionToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.startProcessingInstructionToken,
                1 => this.name,
                2 => this.textTokens,
                3 => this.endProcessingInstructionToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlProcessingInstructionSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlProcessingInstruction(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlProcessingInstruction(this);

        public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
        {
            if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
            {
                var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, GetDiagnostics(), annotations);

        internal XmlProcessingInstructionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var startProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var endProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.startProcessingInstructionToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endProcessingInstructionToken);
        }

        static XmlProcessingInstructionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlProcessingInstructionSyntax), r => new XmlProcessingInstructionSyntax(r));
        }
    }

    internal sealed partial class XmlCommentSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken lessThanExclamationMinusMinusToken;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken minusMinusGreaterThanToken;

        internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        public SyntaxToken LessThanExclamationMinusMinusToken => this.lessThanExclamationMinusMinusToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public SyntaxToken MinusMinusGreaterThanToken => this.minusMinusGreaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanExclamationMinusMinusToken,
                1 => this.textTokens,
                2 => this.minusMinusGreaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.XmlCommentSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlComment(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitXmlComment(this);

        public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
        {
            if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, GetDiagnostics(), annotations);

        internal XmlCommentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanExclamationMinusMinusToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var minusMinusGreaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanExclamationMinusMinusToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.minusMinusGreaterThanToken);
        }

        static XmlCommentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlCommentSyntax), r => new XmlCommentSyntax(r));
        }
    }

    internal abstract partial class HtmlNodeSyntax : AquilaSyntaxNode
    {
        internal HtmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal HtmlNodeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected HtmlNodeSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class HtmlElementSyntax : HtmlNodeSyntax
    {
        internal readonly HtmlElementStartTagSyntax startTag;
        internal readonly GreenNode? content;
        internal readonly HtmlElementEndTagSyntax endTag;

        internal HtmlElementSyntax(SyntaxKind kind, HtmlElementStartTagSyntax startTag, GreenNode? content, HtmlElementEndTagSyntax endTag, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal HtmlElementSyntax(SyntaxKind kind, HtmlElementStartTagSyntax startTag, GreenNode? content, HtmlElementEndTagSyntax endTag, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal HtmlElementSyntax(SyntaxKind kind, HtmlElementStartTagSyntax startTag, GreenNode? content, HtmlElementEndTagSyntax endTag)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        public HtmlElementStartTagSyntax StartTag => this.startTag;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> Content => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax>(this.content);
        public HtmlElementEndTagSyntax EndTag => this.endTag;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.startTag,
                1 => this.content,
                2 => this.endTag,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlElementSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlElement(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlElement(this);

        public HtmlElementSyntax Update(HtmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> content, HtmlElementEndTagSyntax endTag)
        {
            if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
            {
                var newNode = SyntaxFactory.HtmlElement(startTag, content, endTag);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);

        internal HtmlElementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var startTag = (HtmlElementStartTagSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            var content = (GreenNode?)reader.ReadValue();
            if (content != null)
            {
                AdjustFlagsAndWidth(content);
                this.content = content;
            }
            var endTag = (HtmlElementEndTagSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.startTag);
            writer.WriteValue(this.content);
            writer.WriteValue(this.endTag);
        }

        static HtmlElementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlElementSyntax), r => new HtmlElementSyntax(r));
        }
    }

    internal sealed partial class HtmlElementStartTagSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly HtmlNameSyntax name;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken greaterThanToken;

        internal HtmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, HtmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal HtmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, HtmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal HtmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, HtmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        public SyntaxToken LessThanToken => this.lessThanToken;
        public HtmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax>(this.attributes);
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.name,
                2 => this.attributes,
                3 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlElementStartTagSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlElementStartTag(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlElementStartTag(this);

        public HtmlElementStartTagSyntax Update(SyntaxToken lessThanToken, HtmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.HtmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);

        internal HtmlElementStartTagSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var name = (HtmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.greaterThanToken);
        }

        static HtmlElementStartTagSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlElementStartTagSyntax), r => new HtmlElementStartTagSyntax(r));
        }
    }

    internal sealed partial class HtmlElementEndTagSyntax : AquilaSyntaxNode
    {
        internal readonly SyntaxToken lessThanSlashToken;
        internal readonly HtmlNodeSyntax name;
        internal readonly SyntaxToken greaterThanToken;

        internal HtmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, HtmlNodeSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal HtmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, HtmlNodeSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal HtmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, HtmlNodeSyntax name, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        public SyntaxToken LessThanSlashToken => this.lessThanSlashToken;
        public HtmlNodeSyntax Name => this.name;
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanSlashToken,
                1 => this.name,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlElementEndTagSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlElementEndTag(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlElementEndTag(this);

        public HtmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, HtmlNodeSyntax name, SyntaxToken greaterThanToken)
        {
            if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.HtmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);

        internal HtmlElementEndTagSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanSlashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            var name = (HtmlNodeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanSlashToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.greaterThanToken);
        }

        static HtmlElementEndTagSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlElementEndTagSyntax), r => new HtmlElementEndTagSyntax(r));
        }
    }

    internal sealed partial class HtmlEmptyElementSyntax : HtmlNodeSyntax
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly HtmlNameSyntax name;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken slashGreaterThanToken;

        internal HtmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, HtmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal HtmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, HtmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal HtmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, HtmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        public SyntaxToken LessThanToken => this.lessThanToken;
        public HtmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax>(this.attributes);
        public SyntaxToken SlashGreaterThanToken => this.slashGreaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.name,
                2 => this.attributes,
                3 => this.slashGreaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlEmptyElementSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlEmptyElement(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlEmptyElement(this);

        public HtmlEmptyElementSyntax Update(SyntaxToken lessThanToken, HtmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
            {
                var newNode = SyntaxFactory.HtmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);

        internal HtmlEmptyElementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var name = (HtmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.slashGreaterThanToken);
        }

        static HtmlEmptyElementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlEmptyElementSyntax), r => new HtmlEmptyElementSyntax(r));
        }
    }

    internal sealed partial class HtmlNameSyntax : HtmlNodeSyntax
    {
        internal readonly SyntaxToken tagName;

        internal HtmlNameSyntax(SyntaxKind kind, SyntaxToken tagName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(tagName);
            this.tagName = tagName;
        }

        internal HtmlNameSyntax(SyntaxKind kind, SyntaxToken tagName, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(tagName);
            this.tagName = tagName;
        }

        internal HtmlNameSyntax(SyntaxKind kind, SyntaxToken tagName)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(tagName);
            this.tagName = tagName;
        }

        public SyntaxToken TagName => this.tagName;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tagName : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlNameSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlName(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlName(this);

        public HtmlNameSyntax Update(SyntaxToken tagName)
        {
            if (tagName != this.TagName)
            {
                var newNode = SyntaxFactory.HtmlName(tagName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlNameSyntax(this.Kind, this.tagName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlNameSyntax(this.Kind, this.tagName, GetDiagnostics(), annotations);

        internal HtmlNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tagName = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(tagName);
            this.tagName = tagName;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tagName);
        }

        static HtmlNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlNameSyntax), r => new HtmlNameSyntax(r));
        }
    }

    internal abstract partial class BaseHtmlAttributeSyntax : AquilaSyntaxNode
    {
        internal BaseHtmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseHtmlAttributeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseHtmlAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class HtmlExpressionAttributeSyntax : BaseHtmlAttributeSyntax
    {
        internal readonly ExprSyntax expression;

        internal HtmlExpressionAttributeSyntax(SyntaxKind kind, ExprSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal HtmlExpressionAttributeSyntax(SyntaxKind kind, ExprSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal HtmlExpressionAttributeSyntax(SyntaxKind kind, ExprSyntax expression)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public ExprSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.expression : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlExpressionAttributeSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlExpressionAttribute(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlExpressionAttribute(this);

        public HtmlExpressionAttributeSyntax Update(ExprSyntax expression)
        {
            if (expression != this.Expression)
            {
                var newNode = SyntaxFactory.HtmlExpressionAttribute(expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlExpressionAttributeSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlExpressionAttributeSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);

        internal HtmlExpressionAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
        }

        static HtmlExpressionAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlExpressionAttributeSyntax), r => new HtmlExpressionAttributeSyntax(r));
        }
    }

    internal sealed partial class HtmlAttributeSyntax : BaseHtmlAttributeSyntax
    {
        internal readonly HtmlNameSyntax name;
        internal readonly SyntaxToken? equalsToken;
        internal readonly SyntaxToken? startQuoteToken;
        internal readonly GreenNode? nodes;
        internal readonly SyntaxToken? endQuoteToken;

        internal HtmlAttributeSyntax(SyntaxKind kind, HtmlNameSyntax name, SyntaxToken? equalsToken, SyntaxToken? startQuoteToken, GreenNode? nodes, SyntaxToken? endQuoteToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (equalsToken != null)
            {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
            }
            if (startQuoteToken != null)
            {
                this.AdjustFlagsAndWidth(startQuoteToken);
                this.startQuoteToken = startQuoteToken;
            }
            if (nodes != null)
            {
                this.AdjustFlagsAndWidth(nodes);
                this.nodes = nodes;
            }
            if (endQuoteToken != null)
            {
                this.AdjustFlagsAndWidth(endQuoteToken);
                this.endQuoteToken = endQuoteToken;
            }
        }

        internal HtmlAttributeSyntax(SyntaxKind kind, HtmlNameSyntax name, SyntaxToken? equalsToken, SyntaxToken? startQuoteToken, GreenNode? nodes, SyntaxToken? endQuoteToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (equalsToken != null)
            {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
            }
            if (startQuoteToken != null)
            {
                this.AdjustFlagsAndWidth(startQuoteToken);
                this.startQuoteToken = startQuoteToken;
            }
            if (nodes != null)
            {
                this.AdjustFlagsAndWidth(nodes);
                this.nodes = nodes;
            }
            if (endQuoteToken != null)
            {
                this.AdjustFlagsAndWidth(endQuoteToken);
                this.endQuoteToken = endQuoteToken;
            }
        }

        internal HtmlAttributeSyntax(SyntaxKind kind, HtmlNameSyntax name, SyntaxToken? equalsToken, SyntaxToken? startQuoteToken, GreenNode? nodes, SyntaxToken? endQuoteToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (equalsToken != null)
            {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
            }
            if (startQuoteToken != null)
            {
                this.AdjustFlagsAndWidth(startQuoteToken);
                this.startQuoteToken = startQuoteToken;
            }
            if (nodes != null)
            {
                this.AdjustFlagsAndWidth(nodes);
                this.nodes = nodes;
            }
            if (endQuoteToken != null)
            {
                this.AdjustFlagsAndWidth(endQuoteToken);
                this.endQuoteToken = endQuoteToken;
            }
        }

        public HtmlNameSyntax Name => this.name;
        public SyntaxToken? EqualsToken => this.equalsToken;
        public SyntaxToken? StartQuoteToken => this.startQuoteToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode> Nodes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode>(this.nodes);
        public SyntaxToken? EndQuoteToken => this.endQuoteToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                2 => this.startQuoteToken,
                3 => this.nodes,
                4 => this.endQuoteToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlAttributeSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlAttribute(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlAttribute(this);

        public HtmlAttributeSyntax Update(HtmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode> nodes, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || nodes != this.Nodes || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.HtmlAttribute(name, equalsToken, startQuoteToken, nodes, endQuoteToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.nodes, this.endQuoteToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.nodes, this.endQuoteToken, GetDiagnostics(), annotations);

        internal HtmlAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var name = (HtmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken?)reader.ReadValue();
            if (equalsToken != null)
            {
                AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
            }
            var startQuoteToken = (SyntaxToken?)reader.ReadValue();
            if (startQuoteToken != null)
            {
                AdjustFlagsAndWidth(startQuoteToken);
                this.startQuoteToken = startQuoteToken;
            }
            var nodes = (GreenNode?)reader.ReadValue();
            if (nodes != null)
            {
                AdjustFlagsAndWidth(nodes);
                this.nodes = nodes;
            }
            var endQuoteToken = (SyntaxToken?)reader.ReadValue();
            if (endQuoteToken != null)
            {
                AdjustFlagsAndWidth(endQuoteToken);
                this.endQuoteToken = endQuoteToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.nodes);
            writer.WriteValue(this.endQuoteToken);
        }

        static HtmlAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlAttributeSyntax), r => new HtmlAttributeSyntax(r));
        }
    }

    internal sealed partial class HtmlTextSyntax : HtmlNodeSyntax
    {
        internal readonly SyntaxToken text;

        internal HtmlTextSyntax(SyntaxKind kind, SyntaxToken text, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(text);
            this.text = text;
        }

        internal HtmlTextSyntax(SyntaxKind kind, SyntaxToken text, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(text);
            this.text = text;
        }

        internal HtmlTextSyntax(SyntaxKind kind, SyntaxToken text)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(text);
            this.text = text;
        }

        public SyntaxToken Text => this.text;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.text : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlTextSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlText(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlText(this);

        public HtmlTextSyntax Update(SyntaxToken text)
        {
            if (text != this.Text)
            {
                var newNode = SyntaxFactory.HtmlText(text);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlTextSyntax(this.Kind, this.text, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlTextSyntax(this.Kind, this.text, GetDiagnostics(), annotations);

        internal HtmlTextSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var text = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(text);
            this.text = text;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.text);
        }

        static HtmlTextSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlTextSyntax), r => new HtmlTextSyntax(r));
        }
    }

    internal sealed partial class HtmlExpressionSyntax : HtmlNodeSyntax
    {
        internal readonly SyntaxToken atToken;
        internal readonly ExprSyntax expression;

        internal HtmlExpressionSyntax(SyntaxKind kind, SyntaxToken atToken, ExprSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal HtmlExpressionSyntax(SyntaxKind kind, SyntaxToken atToken, ExprSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal HtmlExpressionSyntax(SyntaxKind kind, SyntaxToken atToken, ExprSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken AtToken => this.atToken;
        public ExprSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.atToken,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlExpressionSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlExpression(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlExpression(this);

        public HtmlExpressionSyntax Update(SyntaxToken atToken, ExprSyntax expression)
        {
            if (atToken != this.AtToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.HtmlExpression(atToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlExpressionSyntax(this.Kind, this.atToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlExpressionSyntax(this.Kind, this.atToken, this.expression, GetDiagnostics(), annotations);

        internal HtmlExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var atToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            var expression = (ExprSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.atToken);
            writer.WriteValue(this.expression);
        }

        static HtmlExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlExpressionSyntax), r => new HtmlExpressionSyntax(r));
        }
    }

    internal sealed partial class HtmlStatementSyntax : HtmlNodeSyntax
    {
        internal readonly SyntaxToken atToken;
        internal readonly StmtSyntax statement;

        internal HtmlStatementSyntax(SyntaxKind kind, SyntaxToken atToken, StmtSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal HtmlStatementSyntax(SyntaxKind kind, SyntaxToken atToken, StmtSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal HtmlStatementSyntax(SyntaxKind kind, SyntaxToken atToken, StmtSyntax statement)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public SyntaxToken AtToken => this.atToken;
        public StmtSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.atToken,
                1 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlStatementSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlStatement(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlStatement(this);

        public HtmlStatementSyntax Update(SyntaxToken atToken, StmtSyntax statement)
        {
            if (atToken != this.AtToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.HtmlStatement(atToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlStatementSyntax(this.Kind, this.atToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlStatementSyntax(this.Kind, this.atToken, this.statement, GetDiagnostics(), annotations);

        internal HtmlStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var atToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            var statement = (StmtSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.atToken);
            writer.WriteValue(this.statement);
        }

        static HtmlStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlStatementSyntax), r => new HtmlStatementSyntax(r));
        }
    }

    internal sealed partial class HtmlCodeSyntax : HtmlNodeSyntax
    {
        internal readonly SyntaxToken atToken;
        internal readonly SyntaxToken htmlCodeKeyword;
        internal readonly SyntaxToken openBrace;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken closeBrace;

        internal HtmlCodeSyntax(SyntaxKind kind, SyntaxToken atToken, SyntaxToken htmlCodeKeyword, SyntaxToken openBrace, GreenNode? members, SyntaxToken closeBrace, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(htmlCodeKeyword);
            this.htmlCodeKeyword = htmlCodeKeyword;
            this.AdjustFlagsAndWidth(openBrace);
            this.openBrace = openBrace;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBrace);
            this.closeBrace = closeBrace;
        }

        internal HtmlCodeSyntax(SyntaxKind kind, SyntaxToken atToken, SyntaxToken htmlCodeKeyword, SyntaxToken openBrace, GreenNode? members, SyntaxToken closeBrace, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(htmlCodeKeyword);
            this.htmlCodeKeyword = htmlCodeKeyword;
            this.AdjustFlagsAndWidth(openBrace);
            this.openBrace = openBrace;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBrace);
            this.closeBrace = closeBrace;
        }

        internal HtmlCodeSyntax(SyntaxKind kind, SyntaxToken atToken, SyntaxToken htmlCodeKeyword, SyntaxToken openBrace, GreenNode? members, SyntaxToken closeBrace)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            this.AdjustFlagsAndWidth(htmlCodeKeyword);
            this.htmlCodeKeyword = htmlCodeKeyword;
            this.AdjustFlagsAndWidth(openBrace);
            this.openBrace = openBrace;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBrace);
            this.closeBrace = closeBrace;
        }

        public SyntaxToken AtToken => this.atToken;
        public SyntaxToken HtmlCodeKeyword => this.htmlCodeKeyword;
        public SyntaxToken OpenBrace => this.openBrace;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl>(this.members);
        public SyntaxToken CloseBrace => this.closeBrace;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.atToken,
                1 => this.htmlCodeKeyword,
                2 => this.openBrace,
                3 => this.members,
                4 => this.closeBrace,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Aquila.CodeAnalysis.Syntax.HtmlCodeSyntax(this, parent, position);

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitHtmlCode(this);
        public override TResult Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) => visitor.VisitHtmlCode(this);

        public HtmlCodeSyntax Update(SyntaxToken atToken, SyntaxToken htmlCodeKeyword, SyntaxToken openBrace, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> members, SyntaxToken closeBrace)
        {
            if (atToken != this.AtToken || htmlCodeKeyword != this.HtmlCodeKeyword || openBrace != this.OpenBrace || members != this.Members || closeBrace != this.CloseBrace)
            {
                var newNode = SyntaxFactory.HtmlCode(atToken, htmlCodeKeyword, openBrace, members, closeBrace);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new HtmlCodeSyntax(this.Kind, this.atToken, this.htmlCodeKeyword, this.openBrace, this.members, this.closeBrace, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new HtmlCodeSyntax(this.Kind, this.atToken, this.htmlCodeKeyword, this.openBrace, this.members, this.closeBrace, GetDiagnostics(), annotations);

        internal HtmlCodeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var atToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(atToken);
            this.atToken = atToken;
            var htmlCodeKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(htmlCodeKeyword);
            this.htmlCodeKeyword = htmlCodeKeyword;
            var openBrace = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBrace);
            this.openBrace = openBrace;
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var closeBrace = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBrace);
            this.closeBrace = closeBrace;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.atToken);
            writer.WriteValue(this.htmlCodeKeyword);
            writer.WriteValue(this.openBrace);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBrace);
        }

        static HtmlCodeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(HtmlCodeSyntax), r => new HtmlCodeSyntax(r));
        }
    }

    internal partial class AquilaSyntaxVisitor<TResult>
    {
        public virtual TResult VisitModuleDecl(ModuleDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImportDecl(ImportDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeDecl(TypeDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitFieldDecl(FieldDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitMethodDecl(MethodDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitFuncOwner(FuncOwnerSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFuncDecl(FuncDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitExtendDecl(ExtendDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitComponentDecl(ComponentDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitAttributeList(AttributeListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttribute(AttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNameEquals(NameEqualsSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBinaryEx(BinaryEx node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedEx(ParenthesizedEx node) => this.DefaultVisit(node);
        public virtual TResult VisitPrefixUnaryEx(PrefixUnaryEx node) => this.DefaultVisit(node);
        public virtual TResult VisitPostfixUnaryEx(PostfixUnaryEx node) => this.DefaultVisit(node);
        public virtual TResult VisitInvocationEx(InvocationEx node) => this.DefaultVisit(node);
        public virtual TResult VisitAssignEx(AssignEx node) => this.DefaultVisit(node);
        public virtual TResult VisitElementAccessEx(ElementAccessEx node) => this.DefaultVisit(node);
        public virtual TResult VisitMemberAccessEx(MemberAccessEx node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolatedStringEx(InterpolatedStringEx node) => this.DefaultVisit(node);
        public virtual TResult VisitRangeEx(RangeEx node) => this.DefaultVisit(node);
        public virtual TResult VisitConditionalEx(ConditionalEx node) => this.DefaultVisit(node);
        public virtual TResult VisitThrowEx(ThrowEx node) => this.DefaultVisit(node);
        public virtual TResult VisitLiteralEx(LiteralEx node) => this.DefaultVisit(node);
        public virtual TResult VisitArrowExClause(ArrowExClause node) => this.DefaultVisit(node);
        public virtual TResult VisitInitializerEx(InitializerEx node) => this.DefaultVisit(node);
        public virtual TResult VisitAllocEx(AllocEx node) => this.DefaultVisit(node);
        public virtual TResult VisitCastEx(CastEx node) => this.DefaultVisit(node);
        public virtual TResult VisitMatchEx(MatchEx node) => this.DefaultVisit(node);
        public virtual TResult VisitMatchArm(MatchArm node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExprColon(ExprColonSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitQualifiedNameEx(QualifiedNameEx node) => this.DefaultVisit(node);
        public virtual TResult VisitIdentifierEx(IdentifierEx node) => this.DefaultVisit(node);
        public virtual TResult VisitGenericEx(GenericEx node) => this.DefaultVisit(node);
        public virtual TResult VisitPredefinedTypeEx(PredefinedTypeEx node) => this.DefaultVisit(node);
        public virtual TResult VisitArrayTypeEx(ArrayTypeEx node) => this.DefaultVisit(node);
        public virtual TResult VisitUnionTypeEx(UnionTypeEx node) => this.DefaultVisit(node);
        public virtual TResult VisitRefTypeEx(RefTypeEx node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOmittedArraySizeEx(OmittedArraySizeEx node) => this.DefaultVisit(node);
        public virtual TResult VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionPointerParameter(FunctionPointerParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVariableDecl(VariableDecl node) => this.DefaultVisit(node);
        public virtual TResult VisitVariableInit(VariableInit node) => this.DefaultVisit(node);
        public virtual TResult VisitBlockStmt(BlockStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionStmt(ExpressionStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitEmptyStmt(EmptyStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitLabeledStmt(LabeledStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitGotoStmt(GotoStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitBreakStmt(BreakStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitContinueStmt(ContinueStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitReturnStmt(ReturnStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitThrowStmt(ThrowStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitYieldStmt(YieldStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitWhileStmt(WhileStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitDoStmt(DoStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitForStmt(ForStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitForEachStmt(ForEachStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitLocalDeclStmt(LocalDeclStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitIfStmt(IfStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTryStmt(TryStmt node) => this.DefaultVisit(node);
        public virtual TResult VisitCatchClause(CatchClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFinallyClause(FinallyClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeCref(TypeCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCrefParameter(CrefParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlElement(XmlElementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlName(XmlNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlText(XmlTextSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlComment(XmlCommentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlElement(HtmlElementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlElementStartTag(HtmlElementStartTagSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlElementEndTag(HtmlElementEndTagSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlEmptyElement(HtmlEmptyElementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlName(HtmlNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlExpressionAttribute(HtmlExpressionAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlAttribute(HtmlAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlText(HtmlTextSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlExpression(HtmlExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlStatement(HtmlStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitHtmlCode(HtmlCodeSyntax node) => this.DefaultVisit(node);
    }

    internal partial class AquilaSyntaxVisitor
    {
        public virtual void VisitModuleDecl(ModuleDecl node) => this.DefaultVisit(node);
        public virtual void VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImportDecl(ImportDecl node) => this.DefaultVisit(node);
        public virtual void VisitTypeDecl(TypeDecl node) => this.DefaultVisit(node);
        public virtual void VisitFieldDecl(FieldDecl node) => this.DefaultVisit(node);
        public virtual void VisitMethodDecl(MethodDecl node) => this.DefaultVisit(node);
        public virtual void VisitFuncOwner(FuncOwnerSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFuncDecl(FuncDecl node) => this.DefaultVisit(node);
        public virtual void VisitExtendDecl(ExtendDecl node) => this.DefaultVisit(node);
        public virtual void VisitComponentDecl(ComponentDecl node) => this.DefaultVisit(node);
        public virtual void VisitAttributeList(AttributeListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttribute(AttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttributeArgument(AttributeArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNameEquals(NameEqualsSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBinaryEx(BinaryEx node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedEx(ParenthesizedEx node) => this.DefaultVisit(node);
        public virtual void VisitPrefixUnaryEx(PrefixUnaryEx node) => this.DefaultVisit(node);
        public virtual void VisitPostfixUnaryEx(PostfixUnaryEx node) => this.DefaultVisit(node);
        public virtual void VisitInvocationEx(InvocationEx node) => this.DefaultVisit(node);
        public virtual void VisitAssignEx(AssignEx node) => this.DefaultVisit(node);
        public virtual void VisitElementAccessEx(ElementAccessEx node) => this.DefaultVisit(node);
        public virtual void VisitMemberAccessEx(MemberAccessEx node) => this.DefaultVisit(node);
        public virtual void VisitInterpolatedStringEx(InterpolatedStringEx node) => this.DefaultVisit(node);
        public virtual void VisitRangeEx(RangeEx node) => this.DefaultVisit(node);
        public virtual void VisitConditionalEx(ConditionalEx node) => this.DefaultVisit(node);
        public virtual void VisitThrowEx(ThrowEx node) => this.DefaultVisit(node);
        public virtual void VisitLiteralEx(LiteralEx node) => this.DefaultVisit(node);
        public virtual void VisitArrowExClause(ArrowExClause node) => this.DefaultVisit(node);
        public virtual void VisitInitializerEx(InitializerEx node) => this.DefaultVisit(node);
        public virtual void VisitAllocEx(AllocEx node) => this.DefaultVisit(node);
        public virtual void VisitCastEx(CastEx node) => this.DefaultVisit(node);
        public virtual void VisitMatchEx(MatchEx node) => this.DefaultVisit(node);
        public virtual void VisitMatchArm(MatchArm node) => this.DefaultVisit(node);
        public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExprColon(ExprColonSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);
        public virtual void VisitQualifiedNameEx(QualifiedNameEx node) => this.DefaultVisit(node);
        public virtual void VisitIdentifierEx(IdentifierEx node) => this.DefaultVisit(node);
        public virtual void VisitGenericEx(GenericEx node) => this.DefaultVisit(node);
        public virtual void VisitPredefinedTypeEx(PredefinedTypeEx node) => this.DefaultVisit(node);
        public virtual void VisitArrayTypeEx(ArrayTypeEx node) => this.DefaultVisit(node);
        public virtual void VisitUnionTypeEx(UnionTypeEx node) => this.DefaultVisit(node);
        public virtual void VisitRefTypeEx(RefTypeEx node) => this.DefaultVisit(node);
        public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOmittedArraySizeEx(OmittedArraySizeEx node) => this.DefaultVisit(node);
        public virtual void VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionPointerParameter(FunctionPointerParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIncompleteMember(IncompleteMemberSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVariableDecl(VariableDecl node) => this.DefaultVisit(node);
        public virtual void VisitVariableInit(VariableInit node) => this.DefaultVisit(node);
        public virtual void VisitBlockStmt(BlockStmt node) => this.DefaultVisit(node);
        public virtual void VisitExpressionStmt(ExpressionStmt node) => this.DefaultVisit(node);
        public virtual void VisitEmptyStmt(EmptyStmt node) => this.DefaultVisit(node);
        public virtual void VisitLabeledStmt(LabeledStmt node) => this.DefaultVisit(node);
        public virtual void VisitGotoStmt(GotoStmt node) => this.DefaultVisit(node);
        public virtual void VisitBreakStmt(BreakStmt node) => this.DefaultVisit(node);
        public virtual void VisitContinueStmt(ContinueStmt node) => this.DefaultVisit(node);
        public virtual void VisitReturnStmt(ReturnStmt node) => this.DefaultVisit(node);
        public virtual void VisitThrowStmt(ThrowStmt node) => this.DefaultVisit(node);
        public virtual void VisitYieldStmt(YieldStmt node) => this.DefaultVisit(node);
        public virtual void VisitWhileStmt(WhileStmt node) => this.DefaultVisit(node);
        public virtual void VisitDoStmt(DoStmt node) => this.DefaultVisit(node);
        public virtual void VisitForStmt(ForStmt node) => this.DefaultVisit(node);
        public virtual void VisitForEachStmt(ForEachStmt node) => this.DefaultVisit(node);
        public virtual void VisitLocalDeclStmt(LocalDeclStmt node) => this.DefaultVisit(node);
        public virtual void VisitIfStmt(IfStmt node) => this.DefaultVisit(node);
        public virtual void VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTryStmt(TryStmt node) => this.DefaultVisit(node);
        public virtual void VisitCatchClause(CatchClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFinallyClause(FinallyClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeCref(TypeCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitQualifiedCref(QualifiedCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNameMemberCref(NameMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCrefParameterList(CrefParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCrefParameter(CrefParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlElement(XmlElementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlName(XmlNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlPrefix(XmlPrefixSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlText(XmlTextSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlComment(XmlCommentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlElement(HtmlElementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlElementStartTag(HtmlElementStartTagSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlElementEndTag(HtmlElementEndTagSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlEmptyElement(HtmlEmptyElementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlName(HtmlNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlExpressionAttribute(HtmlExpressionAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlAttribute(HtmlAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlText(HtmlTextSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlExpression(HtmlExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlStatement(HtmlStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitHtmlCode(HtmlCodeSyntax node) => this.DefaultVisit(node);
    }

    internal partial class AquilaSyntaxRewriter : AquilaSyntaxVisitor<AquilaSyntaxNode>
    {
        public override AquilaSyntaxNode VisitModuleDecl(ModuleDecl node)
            => node.Update((SyntaxToken)Visit(node.ModuleKeyword), (NameEx)Visit(node.Name), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
            => node.Update((ModuleDecl)Visit(node.Module), VisitList(node.Imports), VisitList(node.HtmlNodes), VisitList(node.Members), (SyntaxToken)Visit(node.EndOfFileToken));

        public override AquilaSyntaxNode VisitImportDecl(ImportDecl node)
            => node.Update((SyntaxToken)Visit(node.ImportKeyword), (SyntaxToken)Visit(node.ClrKeyword), (NameEx)Visit(node.Name), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitTypeDecl(TypeDecl node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.TypeKeyword), (NameEx)Visit(node.Name), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Fields), (SyntaxToken)Visit(node.CloseBraceToken));

        public override AquilaSyntaxNode VisitFieldDecl(FieldDecl node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeEx)Visit(node.Type), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitMethodDecl(MethodDecl node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeEx)Visit(node.ReturnType), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.ParameterList), (BlockStmt)Visit(node.Body), (ArrowExClause)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitFuncOwner(FuncOwnerSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (SyntaxToken)Visit(node.Identifier), (TypeEx)Visit(node.OwnerType), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitFuncDecl(FuncDecl node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.FnKeyword), (FuncOwnerSyntax)Visit(node.FuncOwner), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.ParameterList), (TypeEx)Visit(node.ReturnType), (BlockStmt)Visit(node.Body), (ArrowExClause)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitExtendDecl(ExtendDecl node)
            => node.Update((SyntaxToken)Visit(node.ExtendKeyword), (NameEx)Visit(node.Name), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Methods), (SyntaxToken)Visit(node.CloseBraceToken));

        public override AquilaSyntaxNode VisitComponentDecl(ComponentDecl node)
            => node.Update((SyntaxToken)Visit(node.ComponentKeyword), (NameEx)Visit(node.Name), VisitList(node.Extends));

        public override AquilaSyntaxNode VisitAttributeList(AttributeListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Attributes), (SyntaxToken)Visit(node.CloseBracketToken));

        public override AquilaSyntaxNode VisitAttribute(AttributeSyntax node)
            => node.Update((NameEx)Visit(node.Name), (AttributeArgumentListSyntax)Visit(node.ArgumentList));

        public override AquilaSyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
            => node.Update((NameEqualsSyntax)Visit(node.NameEquals), (ExprSyntax)Visit(node.Expression));

        public override AquilaSyntaxNode VisitNameEquals(NameEqualsSyntax node)
            => node.Update((IdentifierEx)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken));

        public override AquilaSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.GreaterThanToken));

        public override AquilaSyntaxNode VisitTypeParameter(TypeParameterSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.VarianceKeyword), (SyntaxToken)Visit(node.Identifier));

        public override AquilaSyntaxNode VisitBinaryEx(BinaryEx node)
            => node.Update((ExprSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (ExprSyntax)Visit(node.Right));

        public override AquilaSyntaxNode VisitParenthesizedEx(ParenthesizedEx node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitPrefixUnaryEx(PrefixUnaryEx node)
            => node.Update((SyntaxToken)Visit(node.OperatorToken), (ExprSyntax)Visit(node.Operand));

        public override AquilaSyntaxNode VisitPostfixUnaryEx(PostfixUnaryEx node)
            => node.Update((ExprSyntax)Visit(node.Operand), (SyntaxToken)Visit(node.OperatorToken));

        public override AquilaSyntaxNode VisitInvocationEx(InvocationEx node)
            => node.Update((ExprSyntax)Visit(node.Expression), (ArgumentListSyntax)Visit(node.ArgumentList));

        public override AquilaSyntaxNode VisitAssignEx(AssignEx node)
            => node.Update((ExprSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (ExprSyntax)Visit(node.Right));

        public override AquilaSyntaxNode VisitElementAccessEx(ElementAccessEx node)
            => node.Update((ExprSyntax)Visit(node.Expression), (BracketedArgumentListSyntax)Visit(node.ArgumentList));

        public override AquilaSyntaxNode VisitMemberAccessEx(MemberAccessEx node)
            => node.Update((ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.OperatorToken), (NameEx)Visit(node.Name));

        public override AquilaSyntaxNode VisitInterpolatedStringEx(InterpolatedStringEx node)
            => node.Update((SyntaxToken)Visit(node.StringStartToken), VisitList(node.Contents), (SyntaxToken)Visit(node.StringEndToken));

        public override AquilaSyntaxNode VisitRangeEx(RangeEx node)
            => node.Update((ExprSyntax)Visit(node.LeftOperand), (SyntaxToken)Visit(node.OperatorToken), (ExprSyntax)Visit(node.RightOperand));

        public override AquilaSyntaxNode VisitConditionalEx(ConditionalEx node)
            => node.Update((ExprSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.QuestionToken), (ExprSyntax)Visit(node.WhenTrue), (SyntaxToken)Visit(node.ColonToken), (ExprSyntax)Visit(node.WhenFalse));

        public override AquilaSyntaxNode VisitThrowEx(ThrowEx node)
            => node.Update((SyntaxToken)Visit(node.ThrowKeyword), (ExprSyntax)Visit(node.Expression));

        public override AquilaSyntaxNode VisitLiteralEx(LiteralEx node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override AquilaSyntaxNode VisitArrowExClause(ArrowExClause node)
            => node.Update((SyntaxToken)Visit(node.ArrowToken), (ExprSyntax)Visit(node.Expression));

        public override AquilaSyntaxNode VisitInitializerEx(InitializerEx node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Expressions), (SyntaxToken)Visit(node.CloseBraceToken));

        public override AquilaSyntaxNode VisitAllocEx(AllocEx node)
            => node.Update((TypeEx)Visit(node.Name), (InitializerEx)Visit(node.Initializer));

        public override AquilaSyntaxNode VisitCastEx(CastEx node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (TypeEx)Visit(node.Type), (SyntaxToken)Visit(node.CloseParenToken), (ExprSyntax)Visit(node.Expression));

        public override AquilaSyntaxNode VisitMatchEx(MatchEx node)
            => node.Update((SyntaxToken)Visit(node.MatchKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Arms), (SyntaxToken)Visit(node.CloseBraceToken));

        public override AquilaSyntaxNode VisitMatchArm(MatchArm node)
            => node.Update((SyntaxToken)Visit(node.BarToken), (ExprSyntax)Visit(node.PatternExpression), (SyntaxToken)Visit(node.EqualsGreaterThanToken), (ExprSyntax)Visit(node.ResultExpression));

        public override AquilaSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
            => node.Update((SyntaxToken)Visit(node.TextToken));

        public override AquilaSyntaxNode VisitInterpolation(InterpolationSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), (ExprSyntax)Visit(node.Expression), (InterpolationAlignmentClauseSyntax)Visit(node.AlignmentClause), (InterpolationFormatClauseSyntax)Visit(node.FormatClause), (SyntaxToken)Visit(node.CloseBraceToken));

        public override AquilaSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.CommaToken), (ExprSyntax)Visit(node.Value));

        public override AquilaSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ColonToken), (SyntaxToken)Visit(node.FormatStringToken));

        public override AquilaSyntaxNode VisitArgumentList(ArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseBracketToken));

        public override AquilaSyntaxNode VisitArgument(ArgumentSyntax node)
            => node.Update((NameColonSyntax)Visit(node.NameColon), (SyntaxToken)Visit(node.RefKindKeyword), (ExprSyntax)Visit(node.Expression));

        public override AquilaSyntaxNode VisitExprColon(ExprColonSyntax node)
            => node.Update((ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.ColonToken));

        public override AquilaSyntaxNode VisitNameColon(NameColonSyntax node)
            => node.Update((IdentifierEx)Visit(node.Name), (SyntaxToken)Visit(node.ColonToken));

        public override AquilaSyntaxNode VisitQualifiedNameEx(QualifiedNameEx node)
            => node.Update((NameEx)Visit(node.Left), (SyntaxToken)Visit(node.DotToken), (SimpleNameEx)Visit(node.Right));

        public override AquilaSyntaxNode VisitIdentifierEx(IdentifierEx node)
            => node.Update((SyntaxToken)Visit(node.Identifier));

        public override AquilaSyntaxNode VisitGenericEx(GenericEx node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (TypeArgumentListSyntax)Visit(node.TypeArgumentList));

        public override AquilaSyntaxNode VisitPredefinedTypeEx(PredefinedTypeEx node)
            => node.Update((SyntaxToken)Visit(node.Keyword));

        public override AquilaSyntaxNode VisitArrayTypeEx(ArrayTypeEx node)
            => node.Update((TypeEx)Visit(node.ElementType), VisitList(node.RankSpecifiers));

        public override AquilaSyntaxNode VisitUnionTypeEx(UnionTypeEx node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Types), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitRefTypeEx(RefTypeEx node)
            => node.Update((SyntaxToken)Visit(node.RefKeyword), (SyntaxToken)Visit(node.ReadOnlyKeyword), (TypeEx)Visit(node.Type));

        public override AquilaSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.GreaterThanToken));

        public override AquilaSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Sizes), (SyntaxToken)Visit(node.CloseBracketToken));

        public override AquilaSyntaxNode VisitOmittedArraySizeEx(OmittedArraySizeEx node)
            => node.Update((SyntaxToken)Visit(node.OmittedArraySizeExpressionToken));

        public override AquilaSyntaxNode VisitParameterList(ParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseBracketToken));

        public override AquilaSyntaxNode VisitParameter(ParameterSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Identifier), (TypeEx)Visit(node.Type), (EqualsValueClauseSyntax)Visit(node.Default));

        public override AquilaSyntaxNode VisitFunctionPointerParameter(FunctionPointerParameterSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeEx)Visit(node.Type));

        public override AquilaSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeEx)Visit(node.Type));

        public override AquilaSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override AquilaSyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.EqualsToken), (ExprSyntax)Visit(node.Value));

        public override AquilaSyntaxNode VisitVariableDecl(VariableDecl node)
            => node.Update((TypeEx)Visit(node.Type), VisitList(node.Variables));

        public override AquilaSyntaxNode VisitVariableInit(VariableInit node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (BracketedArgumentListSyntax)Visit(node.ArgumentList), (EqualsValueClauseSyntax)Visit(node.Initializer));

        public override AquilaSyntaxNode VisitBlockStmt(BlockStmt node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Statements), (SyntaxToken)Visit(node.CloseBraceToken));

        public override AquilaSyntaxNode VisitExpressionStmt(ExpressionStmt node)
            => node.Update((ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitEmptyStmt(EmptyStmt node)
            => node.Update((SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitLabeledStmt(LabeledStmt node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.ColonToken), (StmtSyntax)Visit(node.Statement));

        public override AquilaSyntaxNode VisitGotoStmt(GotoStmt node)
            => node.Update((SyntaxToken)Visit(node.GotoKeyword), (SyntaxToken)Visit(node.CaseOrDefaultKeyword), (ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitBreakStmt(BreakStmt node)
            => node.Update((SyntaxToken)Visit(node.BreakKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitContinueStmt(ContinueStmt node)
            => node.Update((SyntaxToken)Visit(node.ContinueKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitReturnStmt(ReturnStmt node)
            => node.Update((SyntaxToken)Visit(node.ReturnKeyword), (ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitThrowStmt(ThrowStmt node)
            => node.Update((SyntaxToken)Visit(node.ThrowKeyword), (ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitYieldStmt(YieldStmt node)
            => node.Update((SyntaxToken)Visit(node.YieldKeyword), (SyntaxToken)Visit(node.ReturnOrBreakKeyword), (ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitWhileStmt(WhileStmt node)
            => node.Update((SyntaxToken)Visit(node.WhileKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExprSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.CloseParenToken), (StmtSyntax)Visit(node.Statement));

        public override AquilaSyntaxNode VisitDoStmt(DoStmt node)
            => node.Update((SyntaxToken)Visit(node.DoKeyword), (StmtSyntax)Visit(node.Statement), (SyntaxToken)Visit(node.WhileKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExprSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.CloseParenToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitForStmt(ForStmt node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (SyntaxToken)Visit(node.OpenParenToken), (VariableDecl)Visit(node.Declaration), VisitList(node.Initializers), (SyntaxToken)Visit(node.FirstSemicolonToken), (ExprSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.SecondSemicolonToken), VisitList(node.Incrementors), (SyntaxToken)Visit(node.CloseParenToken), (StmtSyntax)Visit(node.Statement));

        public override AquilaSyntaxNode VisitForEachStmt(ForEachStmt node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (SyntaxToken)Visit(node.OpenParenToken), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.InKeyword), (ExprSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken), (StmtSyntax)Visit(node.Statement));

        public override AquilaSyntaxNode VisitLocalDeclStmt(LocalDeclStmt node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (VariableDecl)Visit(node.Declaration), (SyntaxToken)Visit(node.SemicolonToken));

        public override AquilaSyntaxNode VisitIfStmt(IfStmt node)
            => node.Update((SyntaxToken)Visit(node.IfKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExprSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.CloseParenToken), (StmtSyntax)Visit(node.Statement), (ElseClauseSyntax)Visit(node.Else));

        public override AquilaSyntaxNode VisitElseClause(ElseClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ElseKeyword), (StmtSyntax)Visit(node.Statement));

        public override AquilaSyntaxNode VisitTryStmt(TryStmt node)
            => node.Update((SyntaxToken)Visit(node.TryKeyword), (BlockStmt)Visit(node.Block), VisitList(node.Catches), (FinallyClauseSyntax)Visit(node.Finally));

        public override AquilaSyntaxNode VisitCatchClause(CatchClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.CatchKeyword), (CatchDeclarationSyntax)Visit(node.Declaration), (CatchFilterClauseSyntax)Visit(node.Filter), (BlockStmt)Visit(node.Block));

        public override AquilaSyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (TypeEx)Visit(node.Type), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhenKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExprSyntax)Visit(node.FilterExpression), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.FinallyKeyword), (BlockStmt)Visit(node.Block));

        public override AquilaSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
            => node.Update(VisitList(node.Content), (SyntaxToken)Visit(node.EndOfComment));

        public override AquilaSyntaxNode VisitTypeCref(TypeCrefSyntax node)
            => node.Update((TypeEx)Visit(node.Type));

        public override AquilaSyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)
            => node.Update((TypeEx)Visit(node.Container), (SyntaxToken)Visit(node.DotToken), (MemberCrefSyntax)Visit(node.Member));

        public override AquilaSyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)
            => node.Update((TypeEx)Visit(node.Name), (CrefParameterListSyntax)Visit(node.Parameters));

        public override AquilaSyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
            => node.Update((SyntaxToken)Visit(node.ThisKeyword), (CrefBracketedParameterListSyntax)Visit(node.Parameters));

        public override AquilaSyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorKeyword), (SyntaxToken)Visit(node.OperatorToken), (CrefParameterListSyntax)Visit(node.Parameters));

        public override AquilaSyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
            => node.Update((SyntaxToken)Visit(node.ImplicitOrExplicitKeyword), (SyntaxToken)Visit(node.OperatorKeyword), (TypeEx)Visit(node.Type), (CrefParameterListSyntax)Visit(node.Parameters));

        public override AquilaSyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseParenToken));

        public override AquilaSyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseBracketToken));

        public override AquilaSyntaxNode VisitCrefParameter(CrefParameterSyntax node)
            => node.Update((SyntaxToken)Visit(node.RefKindKeyword), (TypeEx)Visit(node.Type));

        public override AquilaSyntaxNode VisitXmlElement(XmlElementSyntax node)
            => node.Update((XmlElementStartTagSyntax)Visit(node.StartTag), VisitList(node.Content), (XmlElementEndTagSyntax)Visit(node.EndTag));

        public override AquilaSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), (XmlNameSyntax)Visit(node.Name), VisitList(node.Attributes), (SyntaxToken)Visit(node.GreaterThanToken));

        public override AquilaSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanSlashToken), (XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.GreaterThanToken));

        public override AquilaSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), (XmlNameSyntax)Visit(node.Name), VisitList(node.Attributes), (SyntaxToken)Visit(node.SlashGreaterThanToken));

        public override AquilaSyntaxNode VisitXmlName(XmlNameSyntax node)
            => node.Update((XmlPrefixSyntax)Visit(node.Prefix), (SyntaxToken)Visit(node.LocalName));

        public override AquilaSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
            => node.Update((SyntaxToken)Visit(node.Prefix), (SyntaxToken)Visit(node.ColonToken));

        public override AquilaSyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
            => node.Update((XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (SyntaxToken)Visit(node.StartQuoteToken), VisitList(node.TextTokens), (SyntaxToken)Visit(node.EndQuoteToken));

        public override AquilaSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
            => node.Update((XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (SyntaxToken)Visit(node.StartQuoteToken), (CrefSyntax)Visit(node.Cref), (SyntaxToken)Visit(node.EndQuoteToken));

        public override AquilaSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
            => node.Update((XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (SyntaxToken)Visit(node.StartQuoteToken), (IdentifierEx)Visit(node.Identifier), (SyntaxToken)Visit(node.EndQuoteToken));

        public override AquilaSyntaxNode VisitXmlText(XmlTextSyntax node)
            => node.Update(VisitList(node.TextTokens));

        public override AquilaSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StartCDataToken), VisitList(node.TextTokens), (SyntaxToken)Visit(node.EndCDataToken));

        public override AquilaSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StartProcessingInstructionToken), (XmlNameSyntax)Visit(node.Name), VisitList(node.TextTokens), (SyntaxToken)Visit(node.EndProcessingInstructionToken));

        public override AquilaSyntaxNode VisitXmlComment(XmlCommentSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanExclamationMinusMinusToken), VisitList(node.TextTokens), (SyntaxToken)Visit(node.MinusMinusGreaterThanToken));

        public override AquilaSyntaxNode VisitHtmlElement(HtmlElementSyntax node)
            => node.Update((HtmlElementStartTagSyntax)Visit(node.StartTag), VisitList(node.Content), (HtmlElementEndTagSyntax)Visit(node.EndTag));

        public override AquilaSyntaxNode VisitHtmlElementStartTag(HtmlElementStartTagSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), (HtmlNameSyntax)Visit(node.Name), VisitList(node.Attributes), (SyntaxToken)Visit(node.GreaterThanToken));

        public override AquilaSyntaxNode VisitHtmlElementEndTag(HtmlElementEndTagSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanSlashToken), (HtmlNodeSyntax)Visit(node.Name), (SyntaxToken)Visit(node.GreaterThanToken));

        public override AquilaSyntaxNode VisitHtmlEmptyElement(HtmlEmptyElementSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), (HtmlNameSyntax)Visit(node.Name), VisitList(node.Attributes), (SyntaxToken)Visit(node.SlashGreaterThanToken));

        public override AquilaSyntaxNode VisitHtmlName(HtmlNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.TagName));

        public override AquilaSyntaxNode VisitHtmlExpressionAttribute(HtmlExpressionAttributeSyntax node)
            => node.Update((ExprSyntax)Visit(node.Expression));

        public override AquilaSyntaxNode VisitHtmlAttribute(HtmlAttributeSyntax node)
            => node.Update((HtmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (SyntaxToken)Visit(node.StartQuoteToken), VisitList(node.Nodes), (SyntaxToken)Visit(node.EndQuoteToken));

        public override AquilaSyntaxNode VisitHtmlText(HtmlTextSyntax node)
            => node.Update((SyntaxToken)Visit(node.Text));

        public override AquilaSyntaxNode VisitHtmlExpression(HtmlExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.AtToken), (ExprSyntax)Visit(node.Expression));

        public override AquilaSyntaxNode VisitHtmlStatement(HtmlStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.AtToken), (StmtSyntax)Visit(node.Statement));

        public override AquilaSyntaxNode VisitHtmlCode(HtmlCodeSyntax node)
            => node.Update((SyntaxToken)Visit(node.AtToken), (SyntaxToken)Visit(node.HtmlCodeKeyword), (SyntaxToken)Visit(node.OpenBrace), VisitList(node.Members), (SyntaxToken)Visit(node.CloseBrace));
    }

    internal partial class ContextAwareSyntax
    {
        private SyntaxFactoryContext context;

        public ContextAwareSyntax(SyntaxFactoryContext context)
            => this.context = context;

        public ModuleDecl ModuleDecl(SyntaxToken moduleKeyword, NameEx name, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (moduleKeyword == null) throw new ArgumentNullException(nameof(moduleKeyword));
            if (moduleKeyword.Kind != SyntaxKind.ModuleKeyword) throw new ArgumentException(nameof(moduleKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ModuleDecl, moduleKeyword, name, semicolonToken, this.context, out hash);
            if (cached != null) return (ModuleDecl)cached;

            var result = new ModuleDecl(SyntaxKind.ModuleDecl, moduleKeyword, name, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CompilationUnitSyntax CompilationUnit(ModuleDecl? module, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ImportDecl> imports, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> htmlNodes, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> members, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, module, imports.Node, htmlNodes.Node, members.Node, endOfFileToken, this.context);
        }

        public ImportDecl ImportDecl(SyntaxToken importKeyword, SyntaxToken? clrKeyword, NameEx name, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (importKeyword == null) throw new ArgumentNullException(nameof(importKeyword));
            if (importKeyword.Kind != SyntaxKind.ImportKeyword) throw new ArgumentException(nameof(importKeyword));
            if (clrKeyword != null)
            {
                switch (clrKeyword.Kind)
                {
                    case SyntaxKind.ClrKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(clrKeyword));
                }
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ImportDecl(SyntaxKind.ImportDecl, importKeyword, clrKeyword, name, semicolonToken, this.context);
        }

        public TypeDecl TypeDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken typeKeyword, NameEx name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<FieldDecl> fields, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (typeKeyword == null) throw new ArgumentNullException(nameof(typeKeyword));
            if (typeKeyword.Kind != SyntaxKind.TypeKeyword) throw new ArgumentException(nameof(typeKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new TypeDecl(SyntaxKind.TypeDecl, attributeLists.Node, modifiers.Node, typeKeyword, name, openBraceToken, fields.Node, closeBraceToken, this.context);
        }

        public FieldDecl FieldDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx type, SyntaxToken identifier, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new FieldDecl(SyntaxKind.FieldDecl, attributeLists.Node, modifiers.Node, type, identifier, semicolonToken, this.context);
        }

        public MethodDecl MethodDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new MethodDecl(SyntaxKind.MethodDecl, attributeLists.Node, modifiers.Node, returnType, identifier, typeParameterList, parameterList, body, expressionBody, semicolonToken, this.context);
        }

        public FuncOwnerSyntax FuncOwner(SyntaxToken openParenToken, SyntaxToken identifier, TypeEx ownerType, SyntaxToken? closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (ownerType == null) throw new ArgumentNullException(nameof(ownerType));
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
#endif

            return new FuncOwnerSyntax(SyntaxKind.FuncOwner, openParenToken, identifier, ownerType, closeParenToken, this.context);
        }

        public FuncDecl FuncDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken fnKeyword, FuncOwnerSyntax? funcOwner, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, TypeEx? returnType, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (fnKeyword == null) throw new ArgumentNullException(nameof(fnKeyword));
            if (fnKeyword.Kind != SyntaxKind.FnKeyword) throw new ArgumentException(nameof(fnKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new FuncDecl(SyntaxKind.FuncDecl, attributeLists.Node, modifiers.Node, fnKeyword, funcOwner, identifier, typeParameterList, parameterList, returnType, body, expressionBody, semicolonToken, this.context);
        }

        public ExtendDecl ExtendDecl(SyntaxToken extendKeyword, NameEx name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MethodDecl> methods, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (extendKeyword == null) throw new ArgumentNullException(nameof(extendKeyword));
            if (extendKeyword.Kind != SyntaxKind.ExtendKeyword) throw new ArgumentException(nameof(extendKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new ExtendDecl(SyntaxKind.ExtendDecl, extendKeyword, name, openBraceToken, methods.Node, closeBraceToken, this.context);
        }

        public ComponentDecl ComponentDecl(SyntaxToken componentKeyword, NameEx name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExtendDecl> extends)
        {
#if DEBUG
            if (componentKeyword == null) throw new ArgumentNullException(nameof(componentKeyword));
            if (componentKeyword.Kind != SyntaxKind.ComponentKeyword) throw new ArgumentException(nameof(componentKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ComponentDecl, componentKeyword, name, extends.Node, this.context, out hash);
            if (cached != null) return (ComponentDecl)cached;

            var result = new ComponentDecl(SyntaxKind.ComponentDecl, componentKeyword, name, extends.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AttributeListSyntax AttributeList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeList, openBracketToken, attributes.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (AttributeListSyntax)cached;

            var result = new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, attributes.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AttributeSyntax Attribute(NameEx name, AttributeArgumentListSyntax? argumentList)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, this.context, out hash);
            if (cached != null) return (AttributeSyntax)cached;

            var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (AttributeArgumentListSyntax)cached;

            var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax? nameEquals, ExprSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, expression, this.context, out hash);
            if (cached != null) return (AttributeArgumentSyntax)cached;

            var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NameEqualsSyntax NameEquals(IdentifierEx name, SyntaxToken equalsToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, this.context, out hash);
            if (cached != null) return (NameEqualsSyntax)cached;

            var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context, out hash);
            if (cached != null) return (TypeParameterListSyntax)cached;

            var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier)
        {
#if DEBUG
            if (varianceKeyword != null)
            {
                switch (varianceKeyword.Kind)
                {
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(varianceKeyword));
                }
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context, out hash);
            if (cached != null) return (TypeParameterSyntax)cached;

            var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BinaryEx BinaryEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.LogicalAndExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.IsExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.CoalesceExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarBarToken:
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.IsKeyword:
                case SyntaxKind.AsKeyword:
                case SyntaxKind.QuestionQuestionToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
            if (cached != null) return (BinaryEx)cached;

            var result = new BinaryEx(kind, left, operatorToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParenthesizedEx ParenthesizedEx(SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context, out hash);
            if (cached != null) return (ParenthesizedEx)cached;

            var result = new ParenthesizedEx(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PrefixUnaryEx PrefixUnaryEx(SyntaxKind kind, SyntaxToken operatorToken, ExprSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.UnaryPlusExpression:
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                case SyntaxKind.AddressOfExpression:
                case SyntaxKind.PointerIndirectionExpression:
                case SyntaxKind.IndexExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.CaretToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, this.context, out hash);
            if (cached != null) return (PrefixUnaryEx)cached;

            var result = new PrefixUnaryEx(kind, operatorToken, operand, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PostfixUnaryEx PostfixUnaryEx(SyntaxKind kind, ExprSyntax operand, SyntaxToken operatorToken)
        {
            switch (kind)
            {
                case SyntaxKind.PostIncrementExpression:
                case SyntaxKind.PostDecrementExpression:
                case SyntaxKind.SuppressNullableWarningExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operand == null) throw new ArgumentNullException(nameof(operand));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.ExclamationToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, this.context, out hash);
            if (cached != null) return (PostfixUnaryEx)cached;

            var result = new PostfixUnaryEx(kind, operand, operatorToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InvocationEx InvocationEx(ExprSyntax expression, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, this.context, out hash);
            if (cached != null) return (InvocationEx)cached;

            var result = new InvocationEx(SyntaxKind.InvocationExpression, expression, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AssignEx AssignEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleAssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.RightShiftAssignmentExpression:
                case SyntaxKind.CoalesceAssignmentExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.EqualsToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.AmpersandEqualsToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.QuestionQuestionEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
            if (cached != null) return (AssignEx)cached;

            var result = new AssignEx(kind, left, operatorToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ElementAccessEx ElementAccessEx(ExprSyntax expression, BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, this.context, out hash);
            if (cached != null) return (ElementAccessEx)cached;

            var result = new ElementAccessEx(SyntaxKind.ElementAccessExpression, expression, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public MemberAccessEx MemberAccessEx(SyntaxKind kind, ExprSyntax expression, SyntaxToken operatorToken, NameEx name)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.DotToken:
                case SyntaxKind.MinusGreaterThanToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, this.context, out hash);
            if (cached != null) return (MemberAccessEx)cached;

            var result = new MemberAccessEx(kind, expression, operatorToken, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InterpolatedStringEx InterpolatedStringEx(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
#if DEBUG
            if (stringStartToken == null) throw new ArgumentNullException(nameof(stringStartToken));
            switch (stringStartToken.Kind)
            {
                case SyntaxKind.InterpolatedStringStartToken:
                case SyntaxKind.InterpolatedVerbatimStringStartToken: break;
                default: throw new ArgumentException(nameof(stringStartToken));
            }
            if (stringEndToken == null) throw new ArgumentNullException(nameof(stringEndToken));
            if (stringEndToken.Kind != SyntaxKind.InterpolatedStringEndToken) throw new ArgumentException(nameof(stringEndToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context, out hash);
            if (cached != null) return (InterpolatedStringEx)cached;

            var result = new InterpolatedStringEx(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public RangeEx RangeEx(ExprSyntax? leftOperand, SyntaxToken operatorToken, ExprSyntax? rightOperand)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.DotDotToken) throw new ArgumentException(nameof(operatorToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, this.context, out hash);
            if (cached != null) return (RangeEx)cached;

            var result = new RangeEx(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ConditionalEx ConditionalEx(ExprSyntax condition, SyntaxToken questionToken, ExprSyntax whenTrue, SyntaxToken colonToken, ExprSyntax whenFalse)
        {
#if DEBUG
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (questionToken == null) throw new ArgumentNullException(nameof(questionToken));
            if (questionToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(questionToken));
            if (whenTrue == null) throw new ArgumentNullException(nameof(whenTrue));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (whenFalse == null) throw new ArgumentNullException(nameof(whenFalse));
#endif

            return new ConditionalEx(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse, this.context);
        }

        public ThrowEx ThrowEx(SyntaxToken throwKeyword, ExprSyntax expression)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, this.context, out hash);
            if (cached != null) return (ThrowEx)cached;

            var result = new ThrowEx(SyntaxKind.ThrowExpression, throwKeyword, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LiteralEx LiteralEx(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.ArgListExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.CharacterLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.NullLiteralExpression:
                case SyntaxKind.DefaultLiteralExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.ArgListKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.CharacterLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.DefaultKeyword: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)kind, token, this.context, out hash);
            if (cached != null) return (LiteralEx)cached;

            var result = new LiteralEx(kind, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArrowExClause ArrowExClause(SyntaxToken arrowToken, ExprSyntax expression)
        {
#if DEBUG
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context, out hash);
            if (cached != null) return (ArrowExClause)cached;

            var result = new ArrowExClause(SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InitializerEx InitializerEx(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> expressions, SyntaxToken closeBraceToken)
        {
            switch (kind)
            {
                case SyntaxKind.ObjectInitializerExpression:
                case SyntaxKind.CollectionInitializerExpression:
                case SyntaxKind.ArrayInitializerExpression:
                case SyntaxKind.ComplexElementInitializerExpression:
                case SyntaxKind.WithInitializerExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, this.context, out hash);
            if (cached != null) return (InitializerEx)cached;

            var result = new InitializerEx(kind, openBraceToken, expressions.Node, closeBraceToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AllocEx AllocEx(TypeEx name, InitializerEx initializer)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.AllocExpression, name, initializer, this.context, out hash);
            if (cached != null) return (AllocEx)cached;

            var result = new AllocEx(SyntaxKind.AllocExpression, name, initializer, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CastEx CastEx(SyntaxToken openParenToken, TypeEx type, SyntaxToken closeParenToken, ExprSyntax expression)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new CastEx(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression, this.context);
        }

        public MatchEx MatchEx(SyntaxToken matchKeyword, SyntaxToken? openParenToken, ExprSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<MatchArm> arms, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (matchKeyword == null) throw new ArgumentNullException(nameof(matchKeyword));
            if (matchKeyword.Kind != SyntaxKind.MatchKeyword) throw new ArgumentException(nameof(matchKeyword));
            if (openParenToken != null)
            {
                switch (openParenToken.Kind)
                {
                    case SyntaxKind.OpenParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openParenToken));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new MatchEx(SyntaxKind.MatchExpression, matchKeyword, openParenToken, expression, closeParenToken, openBraceToken, arms.Node, closeBraceToken, this.context);
        }

        public MatchArm MatchArm(SyntaxToken? barToken, ExprSyntax patternExpression, SyntaxToken? equalsGreaterThanToken, ExprSyntax resultExpression)
        {
#if DEBUG
            if (barToken != null)
            {
                switch (barToken.Kind)
                {
                    case SyntaxKind.BarToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(barToken));
                }
            }
            if (patternExpression == null) throw new ArgumentNullException(nameof(patternExpression));
            if (equalsGreaterThanToken != null)
            {
                switch (equalsGreaterThanToken.Kind)
                {
                    case SyntaxKind.EqualsGreaterThanToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(equalsGreaterThanToken));
                }
            }
            if (resultExpression == null) throw new ArgumentNullException(nameof(resultExpression));
#endif

            return new MatchArm(SyntaxKind.MatchArm, barToken, patternExpression, equalsGreaterThanToken, resultExpression, this.context);
        }

        public InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
        {
#if DEBUG
            if (textToken == null) throw new ArgumentNullException(nameof(textToken));
            if (textToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(textToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, this.context, out hash);
            if (cached != null) return (InterpolatedStringTextSyntax)cached;

            var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExprSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken, this.context);
        }

        public InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExprSyntax value)
        {
#if DEBUG
            if (commaToken == null) throw new ArgumentNullException(nameof(commaToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context, out hash);
            if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

            var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (formatStringToken == null) throw new ArgumentNullException(nameof(formatStringToken));
            if (formatStringToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(formatStringToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context, out hash);
            if (cached != null) return (InterpolationFormatClauseSyntax)cached;

            var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (ArgumentListSyntax)cached;

            var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (BracketedArgumentListSyntax)cached;

            var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArgumentSyntax Argument(NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExprSyntax expression)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refKindKeyword, expression, this.context, out hash);
            if (cached != null) return (ArgumentSyntax)cached;

            var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ExprColonSyntax ExprColon(ExprSyntax expression, SyntaxToken colonToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionColon, expression, colonToken, this.context, out hash);
            if (cached != null) return (ExprColonSyntax)cached;

            var result = new ExprColonSyntax(SyntaxKind.ExpressionColon, expression, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NameColonSyntax NameColon(IdentifierEx name, SyntaxToken colonToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, this.context, out hash);
            if (cached != null) return (NameColonSyntax)cached;

            var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public QualifiedNameEx QualifiedNameEx(NameEx left, SyntaxToken dotToken, SimpleNameEx right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, this.context, out hash);
            if (cached != null) return (QualifiedNameEx)cached;

            var result = new QualifiedNameEx(SyntaxKind.QualifiedName, left, dotToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public IdentifierEx IdentifierEx(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierEx, identifier, this.context, out hash);
            if (cached != null) return (IdentifierEx)cached;

            var result = new IdentifierEx(SyntaxKind.IdentifierEx, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public GenericEx GenericEx(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (typeArgumentList == null) throw new ArgumentNullException(nameof(typeArgumentList));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, this.context, out hash);
            if (cached != null) return (GenericEx)cached;

            var result = new GenericEx(SyntaxKind.GenericName, identifier, typeArgumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PredefinedTypeEx PredefinedTypeEx(SyntaxToken keyword)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.BoolKeyword:
                case SyntaxKind.ByteKeyword:
                case SyntaxKind.SByteKeyword:
                case SyntaxKind.IntKeyword:
                case SyntaxKind.UIntKeyword:
                case SyntaxKind.ShortKeyword:
                case SyntaxKind.UShortKeyword:
                case SyntaxKind.LongKeyword:
                case SyntaxKind.ULongKeyword:
                case SyntaxKind.FloatKeyword:
                case SyntaxKind.DoubleKeyword:
                case SyntaxKind.DecimalKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.CharKeyword:
                case SyntaxKind.ObjectKeyword:
                case SyntaxKind.VoidKeyword:
                case SyntaxKind.DatetimeKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, this.context, out hash);
            if (cached != null) return (PredefinedTypeEx)cached;

            var result = new PredefinedTypeEx(SyntaxKind.PredefinedType, keyword, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArrayTypeEx ArrayTypeEx(TypeEx elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context, out hash);
            if (cached != null) return (ArrayTypeEx)cached;

            var result = new ArrayTypeEx(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public UnionTypeEx UnionTypeEx(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> types, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.UnionType, openParenToken, types.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (UnionTypeEx)cached;

            var result = new UnionTypeEx(SyntaxKind.UnionType, openParenToken, types.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public RefTypeEx RefTypeEx(SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeEx type)
        {
#if DEBUG
            if (refKeyword == null) throw new ArgumentNullException(nameof(refKeyword));
            if (refKeyword.Kind != SyntaxKind.RefKeyword) throw new ArgumentException(nameof(refKeyword));
            if (readOnlyKeyword != null)
            {
                switch (readOnlyKeyword.Kind)
                {
                    case SyntaxKind.ReadOnlyKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(readOnlyKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, this.context, out hash);
            if (cached != null) return (RefTypeEx)cached;

            var result = new RefTypeEx(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> arguments, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context, out hash);
            if (cached != null) return (TypeArgumentListSyntax)cached;

            var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> sizes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (ArrayRankSpecifierSyntax)cached;

            var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public OmittedArraySizeEx OmittedArraySizeEx(SyntaxToken omittedArraySizeExpressionToken)
        {
#if DEBUG
            if (omittedArraySizeExpressionToken == null) throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
            if (omittedArraySizeExpressionToken.Kind != SyntaxKind.OmittedArraySizeExpressionToken) throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context, out hash);
            if (cached != null) return (OmittedArraySizeEx)cached;

            var result = new OmittedArraySizeEx(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (ParameterListSyntax)cached;

            var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (BracketedParameterListSyntax)cached;

            var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, TypeEx? type, EqualsValueClauseSyntax? @default)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.ArgListKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, identifier, type, @default, this.context);
        }

        public FunctionPointerParameterSyntax FunctionPointerParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type, this.context, out hash);
            if (cached != null) return (FunctionPointerParameterSyntax)cached;

            var result = new FunctionPointerParameterSyntax(SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx? type)
        {
#if DEBUG
#endif

            return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type, this.context);
        }

        public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
        }

        public EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExprSyntax value)
        {
#if DEBUG
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, this.context, out hash);
            if (cached != null) return (EqualsValueClauseSyntax)cached;

            var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public VariableDecl VariableDecl(TypeEx type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableInit> variables)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, this.context, out hash);
            if (cached != null) return (VariableDecl)cached;

            var result = new VariableDecl(SyntaxKind.VariableDeclaration, type, variables.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public VariableInit VariableInit(SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context, out hash);
            if (cached != null) return (VariableInit)cached;

            var result = new VariableInit(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BlockStmt BlockStmt(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StmtSyntax> statements, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context, out hash);
            if (cached != null) return (BlockStmt)cached;

            var result = new BlockStmt(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ExpressionStmt ExpressionStmt(ExprSyntax expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context, out hash);
            if (cached != null) return (ExpressionStmt)cached;

            var result = new ExpressionStmt(SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public EmptyStmt EmptyStmt(SyntaxToken semicolonToken)
        {
#if DEBUG
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, this.context, out hash);
            if (cached != null) return (EmptyStmt)cached;

            var result = new EmptyStmt(SyntaxKind.EmptyStatement, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LabeledStmt LabeledStmt(SyntaxToken identifier, SyntaxToken colonToken, StmtSyntax statement)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context, out hash);
            if (cached != null) return (LabeledStmt)cached;

            var result = new LabeledStmt(SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public GotoStmt GotoStmt(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.GotoStatement:
                case SyntaxKind.GotoCaseStatement:
                case SyntaxKind.GotoDefaultStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (gotoKeyword == null) throw new ArgumentNullException(nameof(gotoKeyword));
            if (gotoKeyword.Kind != SyntaxKind.GotoKeyword) throw new ArgumentException(nameof(gotoKeyword));
            if (caseOrDefaultKeyword != null)
            {
                switch (caseOrDefaultKeyword.Kind)
                {
                    case SyntaxKind.CaseKeyword:
                    case SyntaxKind.DefaultKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(caseOrDefaultKeyword));
                }
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new GotoStmt(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken, this.context);
        }

        public BreakStmt BreakStmt(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context, out hash);
            if (cached != null) return (BreakStmt)cached;

            var result = new BreakStmt(SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ContinueStmt ContinueStmt(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (continueKeyword == null) throw new ArgumentNullException(nameof(continueKeyword));
            if (continueKeyword.Kind != SyntaxKind.ContinueKeyword) throw new ArgumentException(nameof(continueKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context, out hash);
            if (cached != null) return (ContinueStmt)cached;

            var result = new ContinueStmt(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ReturnStmt ReturnStmt(SyntaxToken returnKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (returnKeyword == null) throw new ArgumentNullException(nameof(returnKeyword));
            if (returnKeyword.Kind != SyntaxKind.ReturnKeyword) throw new ArgumentException(nameof(returnKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, this.context, out hash);
            if (cached != null) return (ReturnStmt)cached;

            var result = new ReturnStmt(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ThrowStmt ThrowStmt(SyntaxToken throwKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context, out hash);
            if (cached != null) return (ThrowStmt)cached;

            var result = new ThrowStmt(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public YieldStmt YieldStmt(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.YieldReturnStatement:
                case SyntaxKind.YieldBreakStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (yieldKeyword == null) throw new ArgumentNullException(nameof(yieldKeyword));
            if (yieldKeyword.Kind != SyntaxKind.YieldKeyword) throw new ArgumentException(nameof(yieldKeyword));
            if (returnOrBreakKeyword == null) throw new ArgumentNullException(nameof(returnOrBreakKeyword));
            switch (returnOrBreakKeyword.Kind)
            {
                case SyntaxKind.ReturnKeyword:
                case SyntaxKind.BreakKeyword: break;
                default: throw new ArgumentException(nameof(returnOrBreakKeyword));
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new YieldStmt(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken, this.context);
        }

        public WhileStmt WhileStmt(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new WhileStmt(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement, this.context);
        }

        public DoStmt DoStmt(SyntaxToken doKeyword, StmtSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new DoStmt(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.context);
        }

        public ForStmt ForStmt(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDecl? declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> initializers, SyntaxToken firstSemicolonToken, ExprSyntax? condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> incrementors, SyntaxToken closeParenToken, StmtSyntax statement)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (firstSemicolonToken == null) throw new ArgumentNullException(nameof(firstSemicolonToken));
            if (firstSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(firstSemicolonToken));
            if (secondSemicolonToken == null) throw new ArgumentNullException(nameof(secondSemicolonToken));
            if (secondSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(secondSemicolonToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForStmt(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement, this.context);
        }

        public ForEachStmt ForEachStmt(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken identifier, SyntaxToken inKeyword, ExprSyntax expression, SyntaxToken closeParenToken, StmtSyntax statement)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForEachStmt(SyntaxKind.ForEachStatement, forKeyword, openParenToken, identifier, inKeyword, expression, closeParenToken, statement, this.context);
        }

        public LocalDeclStmt LocalDeclStmt(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDecl declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new LocalDeclStmt(SyntaxKind.LocalDeclarationStatement, attributeLists.Node, modifiers.Node, declaration, semicolonToken, this.context);
        }

        public IfStmt IfStmt(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new IfStmt(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else, this.context);
        }

        public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StmtSyntax statement)
        {
#if DEBUG
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, this.context, out hash);
            if (cached != null) return (ElseClauseSyntax)cached;

            var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TryStmt TryStmt(SyntaxToken tryKeyword, BlockStmt block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax? @finally)
        {
#if DEBUG
            if (tryKeyword == null) throw new ArgumentNullException(nameof(tryKeyword));
            if (tryKeyword.Kind != SyntaxKind.TryKeyword) throw new ArgumentException(nameof(tryKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new TryStmt(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally, this.context);
        }

        public CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockStmt block)
        {
#if DEBUG
            if (catchKeyword == null) throw new ArgumentNullException(nameof(catchKeyword));
            if (catchKeyword.Kind != SyntaxKind.CatchKeyword) throw new ArgumentException(nameof(catchKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block, this.context);
        }

        public CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeEx type, SyntaxToken? identifier, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier != null)
            {
                switch (identifier.Kind)
                {
                    case SyntaxKind.IdentifierToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(identifier));
                }
            }
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken, this.context);
        }

        public CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExprSyntax filterExpression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (filterExpression == null) throw new ArgumentNullException(nameof(filterExpression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken, this.context);
        }

        public FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockStmt block)
        {
#if DEBUG
            if (finallyKeyword == null) throw new ArgumentNullException(nameof(finallyKeyword));
            if (finallyKeyword.Kind != SyntaxKind.FinallyKeyword) throw new ArgumentException(nameof(finallyKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, this.context, out hash);
            if (cached != null) return (FinallyClauseSyntax)cached;

            var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
        {
            switch (kind)
            {
                case SyntaxKind.SingleLineDocumentationCommentTrivia:
                case SyntaxKind.MultiLineDocumentationCommentTrivia: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (endOfComment == null) throw new ArgumentNullException(nameof(endOfComment));
            if (endOfComment.Kind != SyntaxKind.EndOfDocumentationCommentToken) throw new ArgumentException(nameof(endOfComment));
#endif

            return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment, this.context);
        }

        public TypeCrefSyntax TypeCref(TypeEx type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, this.context, out hash);
            if (cached != null) return (TypeCrefSyntax)cached;

            var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public QualifiedCrefSyntax QualifiedCref(TypeEx container, SyntaxToken dotToken, MemberCrefSyntax member)
        {
#if DEBUG
            if (container == null) throw new ArgumentNullException(nameof(container));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (member == null) throw new ArgumentNullException(nameof(member));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, this.context, out hash);
            if (cached != null) return (QualifiedCrefSyntax)cached;

            var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NameMemberCrefSyntax NameMemberCref(TypeEx name, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, this.context, out hash);
            if (cached != null) return (NameMemberCrefSyntax)cached;

            var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
        {
#if DEBUG
            if (thisKeyword == null) throw new ArgumentNullException(nameof(thisKeyword));
            if (thisKeyword.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(thisKeyword));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context, out hash);
            if (cached != null) return (IndexerMemberCrefSyntax)cached;

            var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context, out hash);
            if (cached != null) return (OperatorMemberCrefSyntax)cached;

            var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeEx type, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (implicitOrExplicitKeyword == null) throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
            switch (implicitOrExplicitKeyword.Kind)
            {
                case SyntaxKind.ImplicitKeyword:
                case SyntaxKind.ExplicitKeyword: break;
                default: throw new ArgumentException(nameof(implicitOrExplicitKeyword));
            }
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters, this.context);
        }

        public CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (CrefParameterListSyntax)cached;

            var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (CrefBracketedParameterListSyntax)cached;

            var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CrefParameterSyntax CrefParameter(SyntaxToken? refKindKeyword, TypeEx type)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refKindKeyword, type, this.context, out hash);
            if (cached != null) return (CrefParameterSyntax)cached;

            var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
        {
#if DEBUG
            if (startTag == null) throw new ArgumentNullException(nameof(startTag));
            if (endTag == null) throw new ArgumentNullException(nameof(endTag));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context, out hash);
            if (cached != null) return (XmlElementSyntax)cached;

            var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, this.context);
        }

        public XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanSlashToken == null) throw new ArgumentNullException(nameof(lessThanSlashToken));
            if (lessThanSlashToken.Kind != SyntaxKind.LessThanSlashToken) throw new ArgumentException(nameof(lessThanSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context, out hash);
            if (cached != null) return (XmlElementEndTagSyntax)cached;

            var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (slashGreaterThanToken == null) throw new ArgumentNullException(nameof(slashGreaterThanToken));
            if (slashGreaterThanToken.Kind != SyntaxKind.SlashGreaterThanToken) throw new ArgumentException(nameof(slashGreaterThanToken));
#endif

            return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, this.context);
        }

        public XmlNameSyntax XmlName(XmlPrefixSyntax? prefix, SyntaxToken localName)
        {
#if DEBUG
            if (localName == null) throw new ArgumentNullException(nameof(localName));
            if (localName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(localName));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, this.context, out hash);
            if (cached != null) return (XmlNameSyntax)cached;

            var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
        {
#if DEBUG
            if (prefix == null) throw new ArgumentNullException(nameof(prefix));
            if (prefix.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(prefix));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, this.context, out hash);
            if (cached != null) return (XmlPrefixSyntax)cached;

            var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken, this.context);
        }

        public XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (cref == null) throw new ArgumentNullException(nameof(cref));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken, this.context);
        }

        public XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierEx identifier, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken, this.context);
        }

        public XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
        {
#if DEBUG
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, this.context, out hash);
            if (cached != null) return (XmlTextSyntax)cached;

            var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
        {
#if DEBUG
            if (startCDataToken == null) throw new ArgumentNullException(nameof(startCDataToken));
            if (startCDataToken.Kind != SyntaxKind.XmlCDataStartToken) throw new ArgumentException(nameof(startCDataToken));
            if (endCDataToken == null) throw new ArgumentNullException(nameof(endCDataToken));
            if (endCDataToken.Kind != SyntaxKind.XmlCDataEndToken) throw new ArgumentException(nameof(endCDataToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context, out hash);
            if (cached != null) return (XmlCDataSectionSyntax)cached;

            var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
        {
#if DEBUG
            if (startProcessingInstructionToken == null) throw new ArgumentNullException(nameof(startProcessingInstructionToken));
            if (startProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionStartToken) throw new ArgumentException(nameof(startProcessingInstructionToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (endProcessingInstructionToken == null) throw new ArgumentNullException(nameof(endProcessingInstructionToken));
            if (endProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionEndToken) throw new ArgumentException(nameof(endProcessingInstructionToken));
#endif

            return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken, this.context);
        }

        public XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
        {
#if DEBUG
            if (lessThanExclamationMinusMinusToken == null) throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
            if (lessThanExclamationMinusMinusToken.Kind != SyntaxKind.XmlCommentStartToken) throw new ArgumentException(nameof(lessThanExclamationMinusMinusToken));
            if (minusMinusGreaterThanToken == null) throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
            if (minusMinusGreaterThanToken.Kind != SyntaxKind.XmlCommentEndToken) throw new ArgumentException(nameof(minusMinusGreaterThanToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context, out hash);
            if (cached != null) return (XmlCommentSyntax)cached;

            var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlElementSyntax HtmlElement(HtmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> content, HtmlElementEndTagSyntax endTag)
        {
#if DEBUG
            if (startTag == null) throw new ArgumentNullException(nameof(startTag));
            if (endTag == null) throw new ArgumentNullException(nameof(endTag));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlElement, startTag, content.Node, endTag, this.context, out hash);
            if (cached != null) return (HtmlElementSyntax)cached;

            var result = new HtmlElementSyntax(SyntaxKind.HtmlElement, startTag, content.Node, endTag, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlElementStartTagSyntax HtmlElementStartTag(SyntaxToken lessThanToken, HtmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            return new HtmlElementStartTagSyntax(SyntaxKind.HtmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, this.context);
        }

        public HtmlElementEndTagSyntax HtmlElementEndTag(SyntaxToken lessThanSlashToken, HtmlNodeSyntax name, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanSlashToken == null) throw new ArgumentNullException(nameof(lessThanSlashToken));
            if (lessThanSlashToken.Kind != SyntaxKind.LessThanSlashToken) throw new ArgumentException(nameof(lessThanSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context, out hash);
            if (cached != null) return (HtmlElementEndTagSyntax)cached;

            var result = new HtmlElementEndTagSyntax(SyntaxKind.HtmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlEmptyElementSyntax HtmlEmptyElement(SyntaxToken lessThanToken, HtmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (slashGreaterThanToken == null) throw new ArgumentNullException(nameof(slashGreaterThanToken));
            if (slashGreaterThanToken.Kind != SyntaxKind.SlashGreaterThanToken) throw new ArgumentException(nameof(slashGreaterThanToken));
#endif

            return new HtmlEmptyElementSyntax(SyntaxKind.HtmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, this.context);
        }

        public HtmlNameSyntax HtmlName(SyntaxToken tagName)
        {
#if DEBUG
            if (tagName == null) throw new ArgumentNullException(nameof(tagName));
            if (tagName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(tagName));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlName, tagName, this.context, out hash);
            if (cached != null) return (HtmlNameSyntax)cached;

            var result = new HtmlNameSyntax(SyntaxKind.HtmlName, tagName, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlExpressionAttributeSyntax HtmlExpressionAttribute(ExprSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlExpressionAttribute, expression, this.context, out hash);
            if (cached != null) return (HtmlExpressionAttributeSyntax)cached;

            var result = new HtmlExpressionAttributeSyntax(SyntaxKind.HtmlExpressionAttribute, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlAttributeSyntax HtmlAttribute(HtmlNameSyntax name, SyntaxToken? equalsToken, SyntaxToken? startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode> nodes, SyntaxToken? endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken != null)
            {
                switch (equalsToken.Kind)
                {
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(equalsToken));
                }
            }
            if (startQuoteToken != null)
            {
                switch (startQuoteToken.Kind)
                {
                    case SyntaxKind.SingleQuoteToken:
                    case SyntaxKind.DoubleQuoteToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(startQuoteToken));
                }
            }
            if (endQuoteToken != null)
            {
                switch (endQuoteToken.Kind)
                {
                    case SyntaxKind.SingleQuoteToken:
                    case SyntaxKind.DoubleQuoteToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(endQuoteToken));
                }
            }
#endif

            return new HtmlAttributeSyntax(SyntaxKind.HtmlAttribute, name, equalsToken, startQuoteToken, nodes.Node, endQuoteToken, this.context);
        }

        public HtmlTextSyntax HtmlText(SyntaxToken text)
        {
#if DEBUG
            if (text == null) throw new ArgumentNullException(nameof(text));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlText, text, this.context, out hash);
            if (cached != null) return (HtmlTextSyntax)cached;

            var result = new HtmlTextSyntax(SyntaxKind.HtmlText, text, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlExpressionSyntax HtmlExpression(SyntaxToken atToken, ExprSyntax expression)
        {
#if DEBUG
            if (atToken == null) throw new ArgumentNullException(nameof(atToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlExpression, atToken, expression, this.context, out hash);
            if (cached != null) return (HtmlExpressionSyntax)cached;

            var result = new HtmlExpressionSyntax(SyntaxKind.HtmlExpression, atToken, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlStatementSyntax HtmlStatement(SyntaxToken atToken, StmtSyntax statement)
        {
#if DEBUG
            if (atToken == null) throw new ArgumentNullException(nameof(atToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = AquilaSyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlStatement, atToken, statement, this.context, out hash);
            if (cached != null) return (HtmlStatementSyntax)cached;

            var result = new HtmlStatementSyntax(SyntaxKind.HtmlStatement, atToken, statement, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public HtmlCodeSyntax HtmlCode(SyntaxToken atToken, SyntaxToken htmlCodeKeyword, SyntaxToken openBrace, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> members, SyntaxToken closeBrace)
        {
#if DEBUG
            if (atToken == null) throw new ArgumentNullException(nameof(atToken));
            if (htmlCodeKeyword == null) throw new ArgumentNullException(nameof(htmlCodeKeyword));
            if (openBrace == null) throw new ArgumentNullException(nameof(openBrace));
            if (closeBrace == null) throw new ArgumentNullException(nameof(closeBrace));
#endif

            return new HtmlCodeSyntax(SyntaxKind.HtmlCode, atToken, htmlCodeKeyword, openBrace, members.Node, closeBrace, this.context);
        }
    }

    internal static partial class SyntaxFactory
    {
        public static ModuleDecl ModuleDecl(SyntaxToken moduleKeyword, NameEx name, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (moduleKeyword == null) throw new ArgumentNullException(nameof(moduleKeyword));
            if (moduleKeyword.Kind != SyntaxKind.ModuleKeyword) throw new ArgumentException(nameof(moduleKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ModuleDecl, moduleKeyword, name, semicolonToken, out hash);
            if (cached != null) return (ModuleDecl)cached;

            var result = new ModuleDecl(SyntaxKind.ModuleDecl, moduleKeyword, name, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CompilationUnitSyntax CompilationUnit(ModuleDecl? module, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ImportDecl> imports, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> htmlNodes, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> members, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, module, imports.Node, htmlNodes.Node, members.Node, endOfFileToken);
        }

        public static ImportDecl ImportDecl(SyntaxToken importKeyword, SyntaxToken? clrKeyword, NameEx name, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (importKeyword == null) throw new ArgumentNullException(nameof(importKeyword));
            if (importKeyword.Kind != SyntaxKind.ImportKeyword) throw new ArgumentException(nameof(importKeyword));
            if (clrKeyword != null)
            {
                switch (clrKeyword.Kind)
                {
                    case SyntaxKind.ClrKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(clrKeyword));
                }
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ImportDecl(SyntaxKind.ImportDecl, importKeyword, clrKeyword, name, semicolonToken);
        }

        public static TypeDecl TypeDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken typeKeyword, NameEx name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<FieldDecl> fields, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (typeKeyword == null) throw new ArgumentNullException(nameof(typeKeyword));
            if (typeKeyword.Kind != SyntaxKind.TypeKeyword) throw new ArgumentException(nameof(typeKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new TypeDecl(SyntaxKind.TypeDecl, attributeLists.Node, modifiers.Node, typeKeyword, name, openBraceToken, fields.Node, closeBraceToken);
        }

        public static FieldDecl FieldDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx type, SyntaxToken identifier, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new FieldDecl(SyntaxKind.FieldDecl, attributeLists.Node, modifiers.Node, type, identifier, semicolonToken);
        }

        public static MethodDecl MethodDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new MethodDecl(SyntaxKind.MethodDecl, attributeLists.Node, modifiers.Node, returnType, identifier, typeParameterList, parameterList, body, expressionBody, semicolonToken);
        }

        public static FuncOwnerSyntax FuncOwner(SyntaxToken openParenToken, SyntaxToken identifier, TypeEx ownerType, SyntaxToken? closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (ownerType == null) throw new ArgumentNullException(nameof(ownerType));
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
#endif

            return new FuncOwnerSyntax(SyntaxKind.FuncOwner, openParenToken, identifier, ownerType, closeParenToken);
        }

        public static FuncDecl FuncDecl(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken fnKeyword, FuncOwnerSyntax? funcOwner, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, TypeEx? returnType, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (fnKeyword == null) throw new ArgumentNullException(nameof(fnKeyword));
            if (fnKeyword.Kind != SyntaxKind.FnKeyword) throw new ArgumentException(nameof(fnKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new FuncDecl(SyntaxKind.FuncDecl, attributeLists.Node, modifiers.Node, fnKeyword, funcOwner, identifier, typeParameterList, parameterList, returnType, body, expressionBody, semicolonToken);
        }

        public static ExtendDecl ExtendDecl(SyntaxToken extendKeyword, NameEx name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MethodDecl> methods, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (extendKeyword == null) throw new ArgumentNullException(nameof(extendKeyword));
            if (extendKeyword.Kind != SyntaxKind.ExtendKeyword) throw new ArgumentException(nameof(extendKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new ExtendDecl(SyntaxKind.ExtendDecl, extendKeyword, name, openBraceToken, methods.Node, closeBraceToken);
        }

        public static ComponentDecl ComponentDecl(SyntaxToken componentKeyword, NameEx name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExtendDecl> extends)
        {
#if DEBUG
            if (componentKeyword == null) throw new ArgumentNullException(nameof(componentKeyword));
            if (componentKeyword.Kind != SyntaxKind.ComponentKeyword) throw new ArgumentException(nameof(componentKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ComponentDecl, componentKeyword, name, extends.Node, out hash);
            if (cached != null) return (ComponentDecl)cached;

            var result = new ComponentDecl(SyntaxKind.ComponentDecl, componentKeyword, name, extends.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeList, openBracketToken, attributes.Node, closeBracketToken, out hash);
            if (cached != null) return (AttributeListSyntax)cached;

            var result = new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, attributes.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AttributeSyntax Attribute(NameEx name, AttributeArgumentListSyntax? argumentList)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, out hash);
            if (cached != null) return (AttributeSyntax)cached;

            var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
            if (cached != null) return (AttributeArgumentListSyntax)cached;

            var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax? nameEquals, ExprSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, expression, out hash);
            if (cached != null) return (AttributeArgumentSyntax)cached;

            var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NameEqualsSyntax NameEquals(IdentifierEx name, SyntaxToken equalsToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, out hash);
            if (cached != null) return (NameEqualsSyntax)cached;

            var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, out hash);
            if (cached != null) return (TypeParameterListSyntax)cached;

            var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier)
        {
#if DEBUG
            if (varianceKeyword != null)
            {
                switch (varianceKeyword.Kind)
                {
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(varianceKeyword));
                }
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, out hash);
            if (cached != null) return (TypeParameterSyntax)cached;

            var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BinaryEx BinaryEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.LogicalAndExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.IsExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.CoalesceExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarBarToken:
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.IsKeyword:
                case SyntaxKind.AsKeyword:
                case SyntaxKind.QuestionQuestionToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (BinaryEx)cached;

            var result = new BinaryEx(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedEx ParenthesizedEx(SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, out hash);
            if (cached != null) return (ParenthesizedEx)cached;

            var result = new ParenthesizedEx(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PrefixUnaryEx PrefixUnaryEx(SyntaxKind kind, SyntaxToken operatorToken, ExprSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.UnaryPlusExpression:
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                case SyntaxKind.AddressOfExpression:
                case SyntaxKind.PointerIndirectionExpression:
                case SyntaxKind.IndexExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.CaretToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, out hash);
            if (cached != null) return (PrefixUnaryEx)cached;

            var result = new PrefixUnaryEx(kind, operatorToken, operand);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PostfixUnaryEx PostfixUnaryEx(SyntaxKind kind, ExprSyntax operand, SyntaxToken operatorToken)
        {
            switch (kind)
            {
                case SyntaxKind.PostIncrementExpression:
                case SyntaxKind.PostDecrementExpression:
                case SyntaxKind.SuppressNullableWarningExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operand == null) throw new ArgumentNullException(nameof(operand));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.ExclamationToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, out hash);
            if (cached != null) return (PostfixUnaryEx)cached;

            var result = new PostfixUnaryEx(kind, operand, operatorToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InvocationEx InvocationEx(ExprSyntax expression, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, out hash);
            if (cached != null) return (InvocationEx)cached;

            var result = new InvocationEx(SyntaxKind.InvocationExpression, expression, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AssignEx AssignEx(SyntaxKind kind, ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleAssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.RightShiftAssignmentExpression:
                case SyntaxKind.CoalesceAssignmentExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.EqualsToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.AmpersandEqualsToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.QuestionQuestionEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (AssignEx)cached;

            var result = new AssignEx(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ElementAccessEx ElementAccessEx(ExprSyntax expression, BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, out hash);
            if (cached != null) return (ElementAccessEx)cached;

            var result = new ElementAccessEx(SyntaxKind.ElementAccessExpression, expression, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MemberAccessEx MemberAccessEx(SyntaxKind kind, ExprSyntax expression, SyntaxToken operatorToken, NameEx name)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.DotToken:
                case SyntaxKind.MinusGreaterThanToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, out hash);
            if (cached != null) return (MemberAccessEx)cached;

            var result = new MemberAccessEx(kind, expression, operatorToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolatedStringEx InterpolatedStringEx(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
#if DEBUG
            if (stringStartToken == null) throw new ArgumentNullException(nameof(stringStartToken));
            switch (stringStartToken.Kind)
            {
                case SyntaxKind.InterpolatedStringStartToken:
                case SyntaxKind.InterpolatedVerbatimStringStartToken: break;
                default: throw new ArgumentException(nameof(stringStartToken));
            }
            if (stringEndToken == null) throw new ArgumentNullException(nameof(stringEndToken));
            if (stringEndToken.Kind != SyntaxKind.InterpolatedStringEndToken) throw new ArgumentException(nameof(stringEndToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, out hash);
            if (cached != null) return (InterpolatedStringEx)cached;

            var result = new InterpolatedStringEx(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static RangeEx RangeEx(ExprSyntax? leftOperand, SyntaxToken operatorToken, ExprSyntax? rightOperand)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.DotDotToken) throw new ArgumentException(nameof(operatorToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, out hash);
            if (cached != null) return (RangeEx)cached;

            var result = new RangeEx(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ConditionalEx ConditionalEx(ExprSyntax condition, SyntaxToken questionToken, ExprSyntax whenTrue, SyntaxToken colonToken, ExprSyntax whenFalse)
        {
#if DEBUG
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (questionToken == null) throw new ArgumentNullException(nameof(questionToken));
            if (questionToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(questionToken));
            if (whenTrue == null) throw new ArgumentNullException(nameof(whenTrue));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (whenFalse == null) throw new ArgumentNullException(nameof(whenFalse));
#endif

            return new ConditionalEx(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse);
        }

        public static ThrowEx ThrowEx(SyntaxToken throwKeyword, ExprSyntax expression)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, out hash);
            if (cached != null) return (ThrowEx)cached;

            var result = new ThrowEx(SyntaxKind.ThrowExpression, throwKeyword, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LiteralEx LiteralEx(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.ArgListExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.CharacterLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.NullLiteralExpression:
                case SyntaxKind.DefaultLiteralExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.ArgListKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.CharacterLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.DefaultKeyword: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
            if (cached != null) return (LiteralEx)cached;

            var result = new LiteralEx(kind, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArrowExClause ArrowExClause(SyntaxToken arrowToken, ExprSyntax expression)
        {
#if DEBUG
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, out hash);
            if (cached != null) return (ArrowExClause)cached;

            var result = new ArrowExClause(SyntaxKind.ArrowExpressionClause, arrowToken, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InitializerEx InitializerEx(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> expressions, SyntaxToken closeBraceToken)
        {
            switch (kind)
            {
                case SyntaxKind.ObjectInitializerExpression:
                case SyntaxKind.CollectionInitializerExpression:
                case SyntaxKind.ArrayInitializerExpression:
                case SyntaxKind.ComplexElementInitializerExpression:
                case SyntaxKind.WithInitializerExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, out hash);
            if (cached != null) return (InitializerEx)cached;

            var result = new InitializerEx(kind, openBraceToken, expressions.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AllocEx AllocEx(TypeEx name, InitializerEx initializer)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AllocExpression, name, initializer, out hash);
            if (cached != null) return (AllocEx)cached;

            var result = new AllocEx(SyntaxKind.AllocExpression, name, initializer);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CastEx CastEx(SyntaxToken openParenToken, TypeEx type, SyntaxToken closeParenToken, ExprSyntax expression)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new CastEx(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression);
        }

        public static MatchEx MatchEx(SyntaxToken matchKeyword, SyntaxToken? openParenToken, ExprSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<MatchArm> arms, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (matchKeyword == null) throw new ArgumentNullException(nameof(matchKeyword));
            if (matchKeyword.Kind != SyntaxKind.MatchKeyword) throw new ArgumentException(nameof(matchKeyword));
            if (openParenToken != null)
            {
                switch (openParenToken.Kind)
                {
                    case SyntaxKind.OpenParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openParenToken));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new MatchEx(SyntaxKind.MatchExpression, matchKeyword, openParenToken, expression, closeParenToken, openBraceToken, arms.Node, closeBraceToken);
        }

        public static MatchArm MatchArm(SyntaxToken? barToken, ExprSyntax patternExpression, SyntaxToken? equalsGreaterThanToken, ExprSyntax resultExpression)
        {
#if DEBUG
            if (barToken != null)
            {
                switch (barToken.Kind)
                {
                    case SyntaxKind.BarToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(barToken));
                }
            }
            if (patternExpression == null) throw new ArgumentNullException(nameof(patternExpression));
            if (equalsGreaterThanToken != null)
            {
                switch (equalsGreaterThanToken.Kind)
                {
                    case SyntaxKind.EqualsGreaterThanToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(equalsGreaterThanToken));
                }
            }
            if (resultExpression == null) throw new ArgumentNullException(nameof(resultExpression));
#endif

            return new MatchArm(SyntaxKind.MatchArm, barToken, patternExpression, equalsGreaterThanToken, resultExpression);
        }

        public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
        {
#if DEBUG
            if (textToken == null) throw new ArgumentNullException(nameof(textToken));
            if (textToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(textToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, out hash);
            if (cached != null) return (InterpolatedStringTextSyntax)cached;

            var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExprSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
        }

        public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExprSyntax value)
        {
#if DEBUG
            if (commaToken == null) throw new ArgumentNullException(nameof(commaToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, out hash);
            if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

            var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (formatStringToken == null) throw new ArgumentNullException(nameof(formatStringToken));
            if (formatStringToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(formatStringToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, out hash);
            if (cached != null) return (InterpolationFormatClauseSyntax)cached;

            var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
            if (cached != null) return (ArgumentListSyntax)cached;

            var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, out hash);
            if (cached != null) return (BracketedArgumentListSyntax)cached;

            var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArgumentSyntax Argument(NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExprSyntax expression)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refKindKeyword, expression, out hash);
            if (cached != null) return (ArgumentSyntax)cached;

            var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ExprColonSyntax ExprColon(ExprSyntax expression, SyntaxToken colonToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionColon, expression, colonToken, out hash);
            if (cached != null) return (ExprColonSyntax)cached;

            var result = new ExprColonSyntax(SyntaxKind.ExpressionColon, expression, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NameColonSyntax NameColon(IdentifierEx name, SyntaxToken colonToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, out hash);
            if (cached != null) return (NameColonSyntax)cached;

            var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static QualifiedNameEx QualifiedNameEx(NameEx left, SyntaxToken dotToken, SimpleNameEx right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, out hash);
            if (cached != null) return (QualifiedNameEx)cached;

            var result = new QualifiedNameEx(SyntaxKind.QualifiedName, left, dotToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IdentifierEx IdentifierEx(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierEx, identifier, out hash);
            if (cached != null) return (IdentifierEx)cached;

            var result = new IdentifierEx(SyntaxKind.IdentifierEx, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static GenericEx GenericEx(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (typeArgumentList == null) throw new ArgumentNullException(nameof(typeArgumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, out hash);
            if (cached != null) return (GenericEx)cached;

            var result = new GenericEx(SyntaxKind.GenericName, identifier, typeArgumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PredefinedTypeEx PredefinedTypeEx(SyntaxToken keyword)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.BoolKeyword:
                case SyntaxKind.ByteKeyword:
                case SyntaxKind.SByteKeyword:
                case SyntaxKind.IntKeyword:
                case SyntaxKind.UIntKeyword:
                case SyntaxKind.ShortKeyword:
                case SyntaxKind.UShortKeyword:
                case SyntaxKind.LongKeyword:
                case SyntaxKind.ULongKeyword:
                case SyntaxKind.FloatKeyword:
                case SyntaxKind.DoubleKeyword:
                case SyntaxKind.DecimalKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.CharKeyword:
                case SyntaxKind.ObjectKeyword:
                case SyntaxKind.VoidKeyword:
                case SyntaxKind.DatetimeKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, out hash);
            if (cached != null) return (PredefinedTypeEx)cached;

            var result = new PredefinedTypeEx(SyntaxKind.PredefinedType, keyword);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArrayTypeEx ArrayTypeEx(TypeEx elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, out hash);
            if (cached != null) return (ArrayTypeEx)cached;

            var result = new ArrayTypeEx(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UnionTypeEx UnionTypeEx(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> types, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnionType, openParenToken, types.Node, closeParenToken, out hash);
            if (cached != null) return (UnionTypeEx)cached;

            var result = new UnionTypeEx(SyntaxKind.UnionType, openParenToken, types.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static RefTypeEx RefTypeEx(SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeEx type)
        {
#if DEBUG
            if (refKeyword == null) throw new ArgumentNullException(nameof(refKeyword));
            if (refKeyword.Kind != SyntaxKind.RefKeyword) throw new ArgumentException(nameof(refKeyword));
            if (readOnlyKeyword != null)
            {
                switch (readOnlyKeyword.Kind)
                {
                    case SyntaxKind.ReadOnlyKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(readOnlyKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, out hash);
            if (cached != null) return (RefTypeEx)cached;

            var result = new RefTypeEx(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeEx> arguments, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, out hash);
            if (cached != null) return (TypeArgumentListSyntax)cached;

            var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> sizes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, out hash);
            if (cached != null) return (ArrayRankSpecifierSyntax)cached;

            var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static OmittedArraySizeEx OmittedArraySizeEx(SyntaxToken omittedArraySizeExpressionToken)
        {
#if DEBUG
            if (omittedArraySizeExpressionToken == null) throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
            if (omittedArraySizeExpressionToken.Kind != SyntaxKind.OmittedArraySizeExpressionToken) throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, out hash);
            if (cached != null) return (OmittedArraySizeEx)cached;

            var result = new OmittedArraySizeEx(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
            if (cached != null) return (ParameterListSyntax)cached;

            var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
            if (cached != null) return (BracketedParameterListSyntax)cached;

            var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, TypeEx? type, EqualsValueClauseSyntax? @default)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.ArgListKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, identifier, type, @default);
        }

        public static FunctionPointerParameterSyntax FunctionPointerParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type, out hash);
            if (cached != null) return (FunctionPointerParameterSyntax)cached;

            var result = new FunctionPointerParameterSyntax(SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeEx? type)
        {
#if DEBUG
#endif

            return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type);
        }

        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
        }

        public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExprSyntax value)
        {
#if DEBUG
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, out hash);
            if (cached != null) return (EqualsValueClauseSyntax)cached;

            var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static VariableDecl VariableDecl(TypeEx type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableInit> variables)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, out hash);
            if (cached != null) return (VariableDecl)cached;

            var result = new VariableDecl(SyntaxKind.VariableDeclaration, type, variables.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static VariableInit VariableInit(SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, out hash);
            if (cached != null) return (VariableInit)cached;

            var result = new VariableInit(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BlockStmt BlockStmt(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StmtSyntax> statements, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, out hash);
            if (cached != null) return (BlockStmt)cached;

            var result = new BlockStmt(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ExpressionStmt ExpressionStmt(ExprSyntax expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, out hash);
            if (cached != null) return (ExpressionStmt)cached;

            var result = new ExpressionStmt(SyntaxKind.ExpressionStatement, expression, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static EmptyStmt EmptyStmt(SyntaxToken semicolonToken)
        {
#if DEBUG
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, out hash);
            if (cached != null) return (EmptyStmt)cached;

            var result = new EmptyStmt(SyntaxKind.EmptyStatement, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LabeledStmt LabeledStmt(SyntaxToken identifier, SyntaxToken colonToken, StmtSyntax statement)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, out hash);
            if (cached != null) return (LabeledStmt)cached;

            var result = new LabeledStmt(SyntaxKind.LabeledStatement, identifier, colonToken, statement);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static GotoStmt GotoStmt(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.GotoStatement:
                case SyntaxKind.GotoCaseStatement:
                case SyntaxKind.GotoDefaultStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (gotoKeyword == null) throw new ArgumentNullException(nameof(gotoKeyword));
            if (gotoKeyword.Kind != SyntaxKind.GotoKeyword) throw new ArgumentException(nameof(gotoKeyword));
            if (caseOrDefaultKeyword != null)
            {
                switch (caseOrDefaultKeyword.Kind)
                {
                    case SyntaxKind.CaseKeyword:
                    case SyntaxKind.DefaultKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(caseOrDefaultKeyword));
                }
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new GotoStmt(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
        }

        public static BreakStmt BreakStmt(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, out hash);
            if (cached != null) return (BreakStmt)cached;

            var result = new BreakStmt(SyntaxKind.BreakStatement, breakKeyword, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ContinueStmt ContinueStmt(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (continueKeyword == null) throw new ArgumentNullException(nameof(continueKeyword));
            if (continueKeyword.Kind != SyntaxKind.ContinueKeyword) throw new ArgumentException(nameof(continueKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, out hash);
            if (cached != null) return (ContinueStmt)cached;

            var result = new ContinueStmt(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ReturnStmt ReturnStmt(SyntaxToken returnKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (returnKeyword == null) throw new ArgumentNullException(nameof(returnKeyword));
            if (returnKeyword.Kind != SyntaxKind.ReturnKeyword) throw new ArgumentException(nameof(returnKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, out hash);
            if (cached != null) return (ReturnStmt)cached;

            var result = new ReturnStmt(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ThrowStmt ThrowStmt(SyntaxToken throwKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, out hash);
            if (cached != null) return (ThrowStmt)cached;

            var result = new ThrowStmt(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static YieldStmt YieldStmt(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.YieldReturnStatement:
                case SyntaxKind.YieldBreakStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (yieldKeyword == null) throw new ArgumentNullException(nameof(yieldKeyword));
            if (yieldKeyword.Kind != SyntaxKind.YieldKeyword) throw new ArgumentException(nameof(yieldKeyword));
            if (returnOrBreakKeyword == null) throw new ArgumentNullException(nameof(returnOrBreakKeyword));
            switch (returnOrBreakKeyword.Kind)
            {
                case SyntaxKind.ReturnKeyword:
                case SyntaxKind.BreakKeyword: break;
                default: throw new ArgumentException(nameof(returnOrBreakKeyword));
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new YieldStmt(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
        }

        public static WhileStmt WhileStmt(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new WhileStmt(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement);
        }

        public static DoStmt DoStmt(SyntaxToken doKeyword, StmtSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new DoStmt(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
        }

        public static ForStmt ForStmt(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDecl? declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> initializers, SyntaxToken firstSemicolonToken, ExprSyntax? condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExprSyntax> incrementors, SyntaxToken closeParenToken, StmtSyntax statement)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (firstSemicolonToken == null) throw new ArgumentNullException(nameof(firstSemicolonToken));
            if (firstSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(firstSemicolonToken));
            if (secondSemicolonToken == null) throw new ArgumentNullException(nameof(secondSemicolonToken));
            if (secondSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(secondSemicolonToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForStmt(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement);
        }

        public static ForEachStmt ForEachStmt(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken identifier, SyntaxToken inKeyword, ExprSyntax expression, SyntaxToken closeParenToken, StmtSyntax statement)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForEachStmt(SyntaxKind.ForEachStatement, forKeyword, openParenToken, identifier, inKeyword, expression, closeParenToken, statement);
        }

        public static LocalDeclStmt LocalDeclStmt(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDecl declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new LocalDeclStmt(SyntaxKind.LocalDeclarationStatement, attributeLists.Node, modifiers.Node, declaration, semicolonToken);
        }

        public static IfStmt IfStmt(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new IfStmt(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
        }

        public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StmtSyntax statement)
        {
#if DEBUG
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, out hash);
            if (cached != null) return (ElseClauseSyntax)cached;

            var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TryStmt TryStmt(SyntaxToken tryKeyword, BlockStmt block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax? @finally)
        {
#if DEBUG
            if (tryKeyword == null) throw new ArgumentNullException(nameof(tryKeyword));
            if (tryKeyword.Kind != SyntaxKind.TryKeyword) throw new ArgumentException(nameof(tryKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new TryStmt(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally);
        }

        public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockStmt block)
        {
#if DEBUG
            if (catchKeyword == null) throw new ArgumentNullException(nameof(catchKeyword));
            if (catchKeyword.Kind != SyntaxKind.CatchKeyword) throw new ArgumentException(nameof(catchKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block);
        }

        public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeEx type, SyntaxToken? identifier, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier != null)
            {
                switch (identifier.Kind)
                {
                    case SyntaxKind.IdentifierToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(identifier));
                }
            }
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken);
        }

        public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExprSyntax filterExpression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (filterExpression == null) throw new ArgumentNullException(nameof(filterExpression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken);
        }

        public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockStmt block)
        {
#if DEBUG
            if (finallyKeyword == null) throw new ArgumentNullException(nameof(finallyKeyword));
            if (finallyKeyword.Kind != SyntaxKind.FinallyKeyword) throw new ArgumentException(nameof(finallyKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, out hash);
            if (cached != null) return (FinallyClauseSyntax)cached;

            var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
        {
            switch (kind)
            {
                case SyntaxKind.SingleLineDocumentationCommentTrivia:
                case SyntaxKind.MultiLineDocumentationCommentTrivia: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (endOfComment == null) throw new ArgumentNullException(nameof(endOfComment));
            if (endOfComment.Kind != SyntaxKind.EndOfDocumentationCommentToken) throw new ArgumentException(nameof(endOfComment));
#endif

            return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment);
        }

        public static TypeCrefSyntax TypeCref(TypeEx type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, out hash);
            if (cached != null) return (TypeCrefSyntax)cached;

            var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static QualifiedCrefSyntax QualifiedCref(TypeEx container, SyntaxToken dotToken, MemberCrefSyntax member)
        {
#if DEBUG
            if (container == null) throw new ArgumentNullException(nameof(container));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (member == null) throw new ArgumentNullException(nameof(member));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, out hash);
            if (cached != null) return (QualifiedCrefSyntax)cached;

            var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NameMemberCrefSyntax NameMemberCref(TypeEx name, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, out hash);
            if (cached != null) return (NameMemberCrefSyntax)cached;

            var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
        {
#if DEBUG
            if (thisKeyword == null) throw new ArgumentNullException(nameof(thisKeyword));
            if (thisKeyword.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(thisKeyword));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, out hash);
            if (cached != null) return (IndexerMemberCrefSyntax)cached;

            var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, out hash);
            if (cached != null) return (OperatorMemberCrefSyntax)cached;

            var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeEx type, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (implicitOrExplicitKeyword == null) throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
            switch (implicitOrExplicitKeyword.Kind)
            {
                case SyntaxKind.ImplicitKeyword:
                case SyntaxKind.ExplicitKeyword: break;
                default: throw new ArgumentException(nameof(implicitOrExplicitKeyword));
            }
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters);
        }

        public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
            if (cached != null) return (CrefParameterListSyntax)cached;

            var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
            if (cached != null) return (CrefBracketedParameterListSyntax)cached;

            var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CrefParameterSyntax CrefParameter(SyntaxToken? refKindKeyword, TypeEx type)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refKindKeyword, type, out hash);
            if (cached != null) return (CrefParameterSyntax)cached;

            var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
        {
#if DEBUG
            if (startTag == null) throw new ArgumentNullException(nameof(startTag));
            if (endTag == null) throw new ArgumentNullException(nameof(endTag));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, out hash);
            if (cached != null) return (XmlElementSyntax)cached;

            var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
        }

        public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanSlashToken == null) throw new ArgumentNullException(nameof(lessThanSlashToken));
            if (lessThanSlashToken.Kind != SyntaxKind.LessThanSlashToken) throw new ArgumentException(nameof(lessThanSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, out hash);
            if (cached != null) return (XmlElementEndTagSyntax)cached;

            var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (slashGreaterThanToken == null) throw new ArgumentNullException(nameof(slashGreaterThanToken));
            if (slashGreaterThanToken.Kind != SyntaxKind.SlashGreaterThanToken) throw new ArgumentException(nameof(slashGreaterThanToken));
#endif

            return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
        }

        public static XmlNameSyntax XmlName(XmlPrefixSyntax? prefix, SyntaxToken localName)
        {
#if DEBUG
            if (localName == null) throw new ArgumentNullException(nameof(localName));
            if (localName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(localName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, out hash);
            if (cached != null) return (XmlNameSyntax)cached;

            var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
        {
#if DEBUG
            if (prefix == null) throw new ArgumentNullException(nameof(prefix));
            if (prefix.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(prefix));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, out hash);
            if (cached != null) return (XmlPrefixSyntax)cached;

            var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken);
        }

        public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (cref == null) throw new ArgumentNullException(nameof(cref));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken);
        }

        public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierEx identifier, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken);
        }

        public static XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, out hash);
            if (cached != null) return (XmlTextSyntax)cached;

            var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
        {
#if DEBUG
            if (startCDataToken == null) throw new ArgumentNullException(nameof(startCDataToken));
            if (startCDataToken.Kind != SyntaxKind.XmlCDataStartToken) throw new ArgumentException(nameof(startCDataToken));
            if (endCDataToken == null) throw new ArgumentNullException(nameof(endCDataToken));
            if (endCDataToken.Kind != SyntaxKind.XmlCDataEndToken) throw new ArgumentException(nameof(endCDataToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, out hash);
            if (cached != null) return (XmlCDataSectionSyntax)cached;

            var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
        {
#if DEBUG
            if (startProcessingInstructionToken == null) throw new ArgumentNullException(nameof(startProcessingInstructionToken));
            if (startProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionStartToken) throw new ArgumentException(nameof(startProcessingInstructionToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (endProcessingInstructionToken == null) throw new ArgumentNullException(nameof(endProcessingInstructionToken));
            if (endProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionEndToken) throw new ArgumentException(nameof(endProcessingInstructionToken));
#endif

            return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken);
        }

        public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
        {
#if DEBUG
            if (lessThanExclamationMinusMinusToken == null) throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
            if (lessThanExclamationMinusMinusToken.Kind != SyntaxKind.XmlCommentStartToken) throw new ArgumentException(nameof(lessThanExclamationMinusMinusToken));
            if (minusMinusGreaterThanToken == null) throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
            if (minusMinusGreaterThanToken.Kind != SyntaxKind.XmlCommentEndToken) throw new ArgumentException(nameof(minusMinusGreaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, out hash);
            if (cached != null) return (XmlCommentSyntax)cached;

            var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlElementSyntax HtmlElement(HtmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlNodeSyntax> content, HtmlElementEndTagSyntax endTag)
        {
#if DEBUG
            if (startTag == null) throw new ArgumentNullException(nameof(startTag));
            if (endTag == null) throw new ArgumentNullException(nameof(endTag));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlElement, startTag, content.Node, endTag, out hash);
            if (cached != null) return (HtmlElementSyntax)cached;

            var result = new HtmlElementSyntax(SyntaxKind.HtmlElement, startTag, content.Node, endTag);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlElementStartTagSyntax HtmlElementStartTag(SyntaxToken lessThanToken, HtmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            return new HtmlElementStartTagSyntax(SyntaxKind.HtmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
        }

        public static HtmlElementEndTagSyntax HtmlElementEndTag(SyntaxToken lessThanSlashToken, HtmlNodeSyntax name, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanSlashToken == null) throw new ArgumentNullException(nameof(lessThanSlashToken));
            if (lessThanSlashToken.Kind != SyntaxKind.LessThanSlashToken) throw new ArgumentException(nameof(lessThanSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlElementEndTag, lessThanSlashToken, name, greaterThanToken, out hash);
            if (cached != null) return (HtmlElementEndTagSyntax)cached;

            var result = new HtmlElementEndTagSyntax(SyntaxKind.HtmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlEmptyElementSyntax HtmlEmptyElement(SyntaxToken lessThanToken, HtmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<HtmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (slashGreaterThanToken == null) throw new ArgumentNullException(nameof(slashGreaterThanToken));
            if (slashGreaterThanToken.Kind != SyntaxKind.SlashGreaterThanToken) throw new ArgumentException(nameof(slashGreaterThanToken));
#endif

            return new HtmlEmptyElementSyntax(SyntaxKind.HtmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
        }

        public static HtmlNameSyntax HtmlName(SyntaxToken tagName)
        {
#if DEBUG
            if (tagName == null) throw new ArgumentNullException(nameof(tagName));
            if (tagName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(tagName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlName, tagName, out hash);
            if (cached != null) return (HtmlNameSyntax)cached;

            var result = new HtmlNameSyntax(SyntaxKind.HtmlName, tagName);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlExpressionAttributeSyntax HtmlExpressionAttribute(ExprSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlExpressionAttribute, expression, out hash);
            if (cached != null) return (HtmlExpressionAttributeSyntax)cached;

            var result = new HtmlExpressionAttributeSyntax(SyntaxKind.HtmlExpressionAttribute, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlAttributeSyntax HtmlAttribute(HtmlNameSyntax name, SyntaxToken? equalsToken, SyntaxToken? startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AquilaSyntaxNode> nodes, SyntaxToken? endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken != null)
            {
                switch (equalsToken.Kind)
                {
                    case SyntaxKind.EqualsToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(equalsToken));
                }
            }
            if (startQuoteToken != null)
            {
                switch (startQuoteToken.Kind)
                {
                    case SyntaxKind.SingleQuoteToken:
                    case SyntaxKind.DoubleQuoteToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(startQuoteToken));
                }
            }
            if (endQuoteToken != null)
            {
                switch (endQuoteToken.Kind)
                {
                    case SyntaxKind.SingleQuoteToken:
                    case SyntaxKind.DoubleQuoteToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(endQuoteToken));
                }
            }
#endif

            return new HtmlAttributeSyntax(SyntaxKind.HtmlAttribute, name, equalsToken, startQuoteToken, nodes.Node, endQuoteToken);
        }

        public static HtmlTextSyntax HtmlText(SyntaxToken text)
        {
#if DEBUG
            if (text == null) throw new ArgumentNullException(nameof(text));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlText, text, out hash);
            if (cached != null) return (HtmlTextSyntax)cached;

            var result = new HtmlTextSyntax(SyntaxKind.HtmlText, text);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlExpressionSyntax HtmlExpression(SyntaxToken atToken, ExprSyntax expression)
        {
#if DEBUG
            if (atToken == null) throw new ArgumentNullException(nameof(atToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlExpression, atToken, expression, out hash);
            if (cached != null) return (HtmlExpressionSyntax)cached;

            var result = new HtmlExpressionSyntax(SyntaxKind.HtmlExpression, atToken, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlStatementSyntax HtmlStatement(SyntaxToken atToken, StmtSyntax statement)
        {
#if DEBUG
            if (atToken == null) throw new ArgumentNullException(nameof(atToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.HtmlStatement, atToken, statement, out hash);
            if (cached != null) return (HtmlStatementSyntax)cached;

            var result = new HtmlStatementSyntax(SyntaxKind.HtmlStatement, atToken, statement);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static HtmlCodeSyntax HtmlCode(SyntaxToken atToken, SyntaxToken htmlCodeKeyword, SyntaxToken openBrace, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDecl> members, SyntaxToken closeBrace)
        {
#if DEBUG
            if (atToken == null) throw new ArgumentNullException(nameof(atToken));
            if (htmlCodeKeyword == null) throw new ArgumentNullException(nameof(htmlCodeKeyword));
            if (openBrace == null) throw new ArgumentNullException(nameof(openBrace));
            if (closeBrace == null) throw new ArgumentNullException(nameof(closeBrace));
#endif

            return new HtmlCodeSyntax(SyntaxKind.HtmlCode, atToken, htmlCodeKeyword, openBrace, members.Node, closeBrace);
        }

        internal static IEnumerable<Type> GetNodeTypes()
            => new Type[]
            {
                typeof(ModuleDecl),
                typeof(CompilationUnitSyntax),
                typeof(ImportDecl),
                typeof(TypeDecl),
                typeof(FieldDecl),
                typeof(MethodDecl),
                typeof(FuncOwnerSyntax),
                typeof(FuncDecl),
                typeof(ExtendDecl),
                typeof(ComponentDecl),
                typeof(AttributeListSyntax),
                typeof(AttributeSyntax),
                typeof(AttributeArgumentListSyntax),
                typeof(AttributeArgumentSyntax),
                typeof(NameEqualsSyntax),
                typeof(TypeParameterListSyntax),
                typeof(TypeParameterSyntax),
                typeof(BinaryEx),
                typeof(ParenthesizedEx),
                typeof(PrefixUnaryEx),
                typeof(PostfixUnaryEx),
                typeof(InvocationEx),
                typeof(AssignEx),
                typeof(ElementAccessEx),
                typeof(MemberAccessEx),
                typeof(InterpolatedStringEx),
                typeof(RangeEx),
                typeof(ConditionalEx),
                typeof(ThrowEx),
                typeof(LiteralEx),
                typeof(ArrowExClause),
                typeof(InitializerEx),
                typeof(AllocEx),
                typeof(CastEx),
                typeof(MatchEx),
                typeof(MatchArm),
                typeof(InterpolatedStringTextSyntax),
                typeof(InterpolationSyntax),
                typeof(InterpolationAlignmentClauseSyntax),
                typeof(InterpolationFormatClauseSyntax),
                typeof(ArgumentListSyntax),
                typeof(BracketedArgumentListSyntax),
                typeof(ArgumentSyntax),
                typeof(ExprColonSyntax),
                typeof(NameColonSyntax),
                typeof(QualifiedNameEx),
                typeof(IdentifierEx),
                typeof(GenericEx),
                typeof(PredefinedTypeEx),
                typeof(ArrayTypeEx),
                typeof(UnionTypeEx),
                typeof(RefTypeEx),
                typeof(TypeArgumentListSyntax),
                typeof(ArrayRankSpecifierSyntax),
                typeof(OmittedArraySizeEx),
                typeof(ParameterListSyntax),
                typeof(BracketedParameterListSyntax),
                typeof(ParameterSyntax),
                typeof(FunctionPointerParameterSyntax),
                typeof(IncompleteMemberSyntax),
                typeof(SkippedTokensTriviaSyntax),
                typeof(EqualsValueClauseSyntax),
                typeof(VariableDecl),
                typeof(VariableInit),
                typeof(BlockStmt),
                typeof(ExpressionStmt),
                typeof(EmptyStmt),
                typeof(LabeledStmt),
                typeof(GotoStmt),
                typeof(BreakStmt),
                typeof(ContinueStmt),
                typeof(ReturnStmt),
                typeof(ThrowStmt),
                typeof(YieldStmt),
                typeof(WhileStmt),
                typeof(DoStmt),
                typeof(ForStmt),
                typeof(ForEachStmt),
                typeof(LocalDeclStmt),
                typeof(IfStmt),
                typeof(ElseClauseSyntax),
                typeof(TryStmt),
                typeof(CatchClauseSyntax),
                typeof(CatchDeclarationSyntax),
                typeof(CatchFilterClauseSyntax),
                typeof(FinallyClauseSyntax),
                typeof(DocumentationCommentTriviaSyntax),
                typeof(TypeCrefSyntax),
                typeof(QualifiedCrefSyntax),
                typeof(NameMemberCrefSyntax),
                typeof(IndexerMemberCrefSyntax),
                typeof(OperatorMemberCrefSyntax),
                typeof(ConversionOperatorMemberCrefSyntax),
                typeof(CrefParameterListSyntax),
                typeof(CrefBracketedParameterListSyntax),
                typeof(CrefParameterSyntax),
                typeof(XmlElementSyntax),
                typeof(XmlElementStartTagSyntax),
                typeof(XmlElementEndTagSyntax),
                typeof(XmlEmptyElementSyntax),
                typeof(XmlNameSyntax),
                typeof(XmlPrefixSyntax),
                typeof(XmlTextAttributeSyntax),
                typeof(XmlCrefAttributeSyntax),
                typeof(XmlNameAttributeSyntax),
                typeof(XmlTextSyntax),
                typeof(XmlCDataSectionSyntax),
                typeof(XmlProcessingInstructionSyntax),
                typeof(XmlCommentSyntax),
                typeof(HtmlElementSyntax),
                typeof(HtmlElementStartTagSyntax),
                typeof(HtmlElementEndTagSyntax),
                typeof(HtmlEmptyElementSyntax),
                typeof(HtmlNameSyntax),
                typeof(HtmlExpressionAttributeSyntax),
                typeof(HtmlAttributeSyntax),
                typeof(HtmlTextSyntax),
                typeof(HtmlExpressionSyntax),
                typeof(HtmlStatementSyntax),
                typeof(HtmlCodeSyntax),
            };
    }
}
