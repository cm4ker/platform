// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;

namespace Aquila.CodeAnalysis.Syntax
{
    using Microsoft.CodeAnalysis;

    public abstract partial class ExprSyntax : AquilaSyntaxNode
    {
        internal ExprSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    public abstract partial class StmtSyntax : AquilaSyntaxNode
    {
        internal StmtSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.CompilationUnit"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class CompilationUnitSyntax : AquilaSyntaxNode
    {
        private SyntaxNode? imports;
        private SyntaxNode? methods;
        private SyntaxNode? extends;
        private SyntaxNode? components;
        private SyntaxNode? types;

        internal CompilationUnitSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxList<ImportDecl> Imports => new SyntaxList<ImportDecl>(GetRed(ref this.imports, 0));

        public SyntaxList<MethodDecl> Methods => new SyntaxList<MethodDecl>(GetRed(ref this.methods, 1));

        public SyntaxList<ExtendDecl> Extends => new SyntaxList<ExtendDecl>(GetRed(ref this.extends, 2));

        public SyntaxList<ComponentDecl> Components => new SyntaxList<ComponentDecl>(GetRed(ref this.components, 3));

        public SyntaxList<TypeDecl> Types => new SyntaxList<TypeDecl>(GetRed(ref this.types, 4));

        public SyntaxToken EndOfFileToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CompilationUnitSyntax)this.Green).endOfFileToken, GetChildPosition(5), GetChildIndex(5));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.imports)!,
                1 => GetRed(ref this.methods, 1)!,
                2 => GetRed(ref this.extends, 2)!,
                3 => GetRed(ref this.components, 3)!,
                4 => GetRed(ref this.types, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.imports,
                1 => this.methods,
                2 => this.extends,
                3 => this.components,
                4 => this.types,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCompilationUnit(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitCompilationUnit(this);

        public CompilationUnitSyntax Update(SyntaxList<ImportDecl> imports, SyntaxList<MethodDecl> methods, SyntaxList<ExtendDecl> extends, SyntaxList<ComponentDecl> components, SyntaxList<TypeDecl> types, SyntaxToken endOfFileToken)
        {
            if (imports != this.Imports || methods != this.Methods || extends != this.Extends || components != this.Components || types != this.Types || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.CompilationUnit(imports, methods, extends, components, types, endOfFileToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public CompilationUnitSyntax WithImports(SyntaxList<ImportDecl> imports) => Update(imports, this.Methods, this.Extends, this.Components, this.Types, this.EndOfFileToken);
        public CompilationUnitSyntax WithMethods(SyntaxList<MethodDecl> methods) => Update(this.Imports, methods, this.Extends, this.Components, this.Types, this.EndOfFileToken);
        public CompilationUnitSyntax WithExtends(SyntaxList<ExtendDecl> extends) => Update(this.Imports, this.Methods, extends, this.Components, this.Types, this.EndOfFileToken);
        public CompilationUnitSyntax WithComponents(SyntaxList<ComponentDecl> components) => Update(this.Imports, this.Methods, this.Extends, components, this.Types, this.EndOfFileToken);
        public CompilationUnitSyntax WithTypes(SyntaxList<TypeDecl> types) => Update(this.Imports, this.Methods, this.Extends, this.Components, types, this.EndOfFileToken);
        public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken) => Update(this.Imports, this.Methods, this.Extends, this.Components, this.Types, endOfFileToken);

        public CompilationUnitSyntax AddImports(params ImportDecl[] items) => WithImports(this.Imports.AddRange(items));
        public CompilationUnitSyntax AddMethods(params MethodDecl[] items) => WithMethods(this.Methods.AddRange(items));
        public CompilationUnitSyntax AddExtends(params ExtendDecl[] items) => WithExtends(this.Extends.AddRange(items));
        public CompilationUnitSyntax AddComponents(params ComponentDecl[] items) => WithComponents(this.Components.AddRange(items));
        public CompilationUnitSyntax AddTypes(params TypeDecl[] items) => WithTypes(this.Types.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ImportDecl"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ImportDecl : AquilaSyntaxNode
    {
        private NameEx? name;

        internal ImportDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ImportKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ImportDecl)this.Green).importKeyword, Position, 0);

        public NameEx Name => GetRed(ref this.name, 1)!;

        /// <summary>SyntaxToken representing the semicolon token.</summary>
        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ImportDecl)this.Green).semicolonToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.name, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.name : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitImportDecl(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitImportDecl(this);

        public ImportDecl Update(SyntaxToken importKeyword, NameEx name, SyntaxToken semicolonToken)
        {
            if (importKeyword != this.ImportKeyword || name != this.Name || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ImportDecl(importKeyword, name, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ImportDecl WithImportKeyword(SyntaxToken importKeyword) => Update(importKeyword, this.Name, this.SemicolonToken);
        public ImportDecl WithName(NameEx name) => Update(this.ImportKeyword, name, this.SemicolonToken);
        public ImportDecl WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ImportKeyword, this.Name, semicolonToken);
    }

    /// <summary>Member declaration syntax.</summary>
    public abstract partial class MemberDecl : AquilaSyntaxNode
    {
        internal MemberDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public MemberDecl WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => WithAttributeListsCore(attributeLists);
        internal abstract MemberDecl WithAttributeListsCore(SyntaxList<AttributeListSyntax> attributeLists);

        public MemberDecl AddAttributeLists(params AttributeListSyntax[] items) => AddAttributeListsCore(items);
        internal abstract MemberDecl AddAttributeListsCore(params AttributeListSyntax[] items);

        /// <summary>Gets the modifier list.</summary>
        public abstract SyntaxTokenList Modifiers { get; }
        public MemberDecl WithModifiers(SyntaxTokenList modifiers) => WithModifiersCore(modifiers);
        internal abstract MemberDecl WithModifiersCore(SyntaxTokenList modifiers);

        public MemberDecl AddModifiers(params SyntaxToken[] items) => AddModifiersCore(items);
        internal abstract MemberDecl AddModifiersCore(params SyntaxToken[] items);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.FieldDecl"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FieldDecl : MemberDecl
    {
        private SyntaxNode? attributeLists;
        private TypeEx? type;

        internal FieldDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxList<AttributeListSyntax> AttributeLists => new SyntaxList<AttributeListSyntax>(GetRed(ref this.attributeLists, 0));

        public override SyntaxTokenList Modifiers
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the type of syntax.</summary>
        public TypeEx Type => GetRed(ref this.type, 2)!;

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.FieldDecl)this.Green).identifier, GetChildPosition(3), GetChildIndex(3));

        /// <summary>Gets the semicolon token.</summary>
        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.FieldDecl)this.Green).semicolonToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.attributeLists)!,
                2 => GetRed(ref this.type, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                2 => this.type,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitFieldDecl(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitFieldDecl(this);

        public FieldDecl Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeEx type, SyntaxToken identifier, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.FieldDecl(attributeLists, modifiers, type, identifier, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override MemberDecl WithAttributeListsCore(SyntaxList<AttributeListSyntax> attributeLists) => WithAttributeLists(attributeLists);
        public new FieldDecl WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => Update(attributeLists, this.Modifiers, this.Type, this.Identifier, this.SemicolonToken);
        internal override MemberDecl WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
        public new FieldDecl WithModifiers(SyntaxTokenList modifiers) => Update(this.AttributeLists, modifiers, this.Type, this.Identifier, this.SemicolonToken);
        public FieldDecl WithType(TypeEx type) => Update(this.AttributeLists, this.Modifiers, type, this.Identifier, this.SemicolonToken);
        public FieldDecl WithIdentifier(SyntaxToken identifier) => Update(this.AttributeLists, this.Modifiers, this.Type, identifier, this.SemicolonToken);
        public FieldDecl WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.AttributeLists, this.Modifiers, this.Type, this.Identifier, semicolonToken);

        internal override MemberDecl AddAttributeListsCore(params AttributeListSyntax[] items) => AddAttributeLists(items);
        public new FieldDecl AddAttributeLists(params AttributeListSyntax[] items) => WithAttributeLists(this.AttributeLists.AddRange(items));
        internal override MemberDecl AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);
        public new FieldDecl AddModifiers(params SyntaxToken[] items) => WithModifiers(this.Modifiers.AddRange(items));
    }

    /// <summary>Base type for method declaration syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MethodDecl"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MethodDecl : MemberDecl
    {
        private SyntaxNode? attributeLists;
        private TypeEx? returnType;
        private TypeParameterListSyntax? typeParameterList;
        private ParameterListSyntax? parameterList;
        private BlockStmt? body;
        private ArrowExClause? expressionBody;

        internal MethodDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxList<AttributeListSyntax> AttributeLists => new SyntaxList<AttributeListSyntax>(GetRed(ref this.attributeLists, 0));

        public override SyntaxTokenList Modifiers
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the return type syntax.</summary>
        public TypeEx ReturnType => GetRed(ref this.returnType, 2)!;

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.MethodDecl)this.Green).identifier, GetChildPosition(3), GetChildIndex(3));

        public TypeParameterListSyntax? TypeParameterList => GetRed(ref this.typeParameterList, 4);

        /// <summary>Gets the parameter list.</summary>
        public ParameterListSyntax ParameterList => GetRed(ref this.parameterList, 5)!;

        public BlockStmt? Body => GetRed(ref this.body, 6);

        public ArrowExClause? ExpressionBody => GetRed(ref this.expressionBody, 7);

        /// <summary>Gets the optional semicolon token.</summary>
        public SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.MethodDecl)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(8), GetChildIndex(8)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.attributeLists)!,
                2 => GetRed(ref this.returnType, 2)!,
                4 => GetRed(ref this.typeParameterList, 4),
                5 => GetRed(ref this.parameterList, 5)!,
                6 => GetRed(ref this.body, 6),
                7 => GetRed(ref this.expressionBody, 7),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                2 => this.returnType,
                4 => this.typeParameterList,
                5 => this.parameterList,
                6 => this.body,
                7 => this.expressionBody,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMethodDecl(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMethodDecl(this);

        public MethodDecl Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeEx returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, BlockStmt? body, ArrowExClause? expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.MethodDecl(attributeLists, modifiers, returnType, identifier, typeParameterList, parameterList, body, expressionBody, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override MemberDecl WithAttributeListsCore(SyntaxList<AttributeListSyntax> attributeLists) => WithAttributeLists(attributeLists);
        public new MethodDecl WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => Update(attributeLists, this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
        internal override MemberDecl WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
        public new MethodDecl WithModifiers(SyntaxTokenList modifiers) => Update(this.AttributeLists, modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
        public MethodDecl WithReturnType(TypeEx returnType) => Update(this.AttributeLists, this.Modifiers, returnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
        public MethodDecl WithIdentifier(SyntaxToken identifier) => Update(this.AttributeLists, this.Modifiers, this.ReturnType, identifier, this.TypeParameterList, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
        public MethodDecl WithTypeParameterList(TypeParameterListSyntax? typeParameterList) => Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.Identifier, typeParameterList, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
        public MethodDecl WithParameterList(ParameterListSyntax parameterList) => Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, parameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
        public MethodDecl WithBody(BlockStmt? body) => Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, body, this.ExpressionBody, this.SemicolonToken);
        public MethodDecl WithExpressionBody(ArrowExClause? expressionBody) => Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.Body, expressionBody, this.SemicolonToken);
        public MethodDecl WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.Body, this.ExpressionBody, semicolonToken);

        internal override MemberDecl AddAttributeListsCore(params AttributeListSyntax[] items) => AddAttributeLists(items);
        public new MethodDecl AddAttributeLists(params AttributeListSyntax[] items) => WithAttributeLists(this.AttributeLists.AddRange(items));
        internal override MemberDecl AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);
        public new MethodDecl AddModifiers(params SyntaxToken[] items) => WithModifiers(this.Modifiers.AddRange(items));
        public MethodDecl AddTypeParameterListParameters(params TypeParameterSyntax[] items)
        {
            var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
            return WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
        }
        public MethodDecl AddParameterListParameters(params ParameterSyntax[] items) => WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
        public MethodDecl AddBodyStatements(params StmtSyntax[] items)
        {
            var body = this.Body ?? SyntaxFactory.BlockStmt();
            return WithBody(body.WithStatements(body.Statements.AddRange(items)));
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExtendDecl"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExtendDecl : AquilaSyntaxNode
    {
        private NameEx? name;
        private SyntaxNode? methods;

        internal ExtendDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ExtendKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ExtendDecl)this.Green).extendKeyword, Position, 0);

        public NameEx Name => GetRed(ref this.name, 1)!;

        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExtendDecl)this.Green).openBraceToken, GetChildPosition(2), GetChildIndex(2));

        public SyntaxList<MethodDecl> Methods => new SyntaxList<MethodDecl>(GetRed(ref this.methods, 3));

        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExtendDecl)this.Green).closeBraceToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.methods, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.methods,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitExtendDecl(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExtendDecl(this);

        public ExtendDecl Update(SyntaxToken extendKeyword, NameEx name, SyntaxToken openBraceToken, SyntaxList<MethodDecl> methods, SyntaxToken closeBraceToken)
        {
            if (extendKeyword != this.ExtendKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || methods != this.Methods || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.ExtendDecl(extendKeyword, name, openBraceToken, methods, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExtendDecl WithExtendKeyword(SyntaxToken extendKeyword) => Update(extendKeyword, this.Name, this.OpenBraceToken, this.Methods, this.CloseBraceToken);
        public ExtendDecl WithName(NameEx name) => Update(this.ExtendKeyword, name, this.OpenBraceToken, this.Methods, this.CloseBraceToken);
        public ExtendDecl WithOpenBraceToken(SyntaxToken openBraceToken) => Update(this.ExtendKeyword, this.Name, openBraceToken, this.Methods, this.CloseBraceToken);
        public ExtendDecl WithMethods(SyntaxList<MethodDecl> methods) => Update(this.ExtendKeyword, this.Name, this.OpenBraceToken, methods, this.CloseBraceToken);
        public ExtendDecl WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.ExtendKeyword, this.Name, this.OpenBraceToken, this.Methods, closeBraceToken);

        public ExtendDecl AddMethods(params MethodDecl[] items) => WithMethods(this.Methods.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ComponentDecl"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ComponentDecl : AquilaSyntaxNode
    {
        private NameEx? name;
        private SyntaxNode? extends;

        internal ComponentDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ComponentKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ComponentDecl)this.Green).componentKeyword, Position, 0);

        public NameEx Name => GetRed(ref this.name, 1)!;

        public SyntaxList<ExtendDecl> Extends => new SyntaxList<ExtendDecl>(GetRed(ref this.extends, 2));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                2 => GetRed(ref this.extends, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                2 => this.extends,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitComponentDecl(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitComponentDecl(this);

        public ComponentDecl Update(SyntaxToken componentKeyword, NameEx name, SyntaxList<ExtendDecl> extends)
        {
            if (componentKeyword != this.ComponentKeyword || name != this.Name || extends != this.Extends)
            {
                var newNode = SyntaxFactory.ComponentDecl(componentKeyword, name, extends);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ComponentDecl WithComponentKeyword(SyntaxToken componentKeyword) => Update(componentKeyword, this.Name, this.Extends);
        public ComponentDecl WithName(NameEx name) => Update(this.ComponentKeyword, name, this.Extends);
        public ComponentDecl WithExtends(SyntaxList<ExtendDecl> extends) => Update(this.ComponentKeyword, this.Name, extends);

        public ComponentDecl AddExtends(params ExtendDecl[] items) => WithExtends(this.Extends.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeDecl"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeDecl : AquilaSyntaxNode
    {
        private NameEx? name;
        private SyntaxNode? fields;

        internal TypeDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken TypeKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeDecl)this.Green).typeKeyword, Position, 0);

        public NameEx Name => GetRed(ref this.name, 1)!;

        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeDecl)this.Green).openBraceToken, GetChildPosition(2), GetChildIndex(2));

        public SyntaxList<FieldDecl> Fields => new SyntaxList<FieldDecl>(GetRed(ref this.fields, 3));

        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeDecl)this.Green).closeBraceToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                3 => GetRed(ref this.fields, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                3 => this.fields,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeDecl(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeDecl(this);

        public TypeDecl Update(SyntaxToken typeKeyword, NameEx name, SyntaxToken openBraceToken, SyntaxList<FieldDecl> fields, SyntaxToken closeBraceToken)
        {
            if (typeKeyword != this.TypeKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || fields != this.Fields || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TypeDecl(typeKeyword, name, openBraceToken, fields, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeDecl WithTypeKeyword(SyntaxToken typeKeyword) => Update(typeKeyword, this.Name, this.OpenBraceToken, this.Fields, this.CloseBraceToken);
        public TypeDecl WithName(NameEx name) => Update(this.TypeKeyword, name, this.OpenBraceToken, this.Fields, this.CloseBraceToken);
        public TypeDecl WithOpenBraceToken(SyntaxToken openBraceToken) => Update(this.TypeKeyword, this.Name, openBraceToken, this.Fields, this.CloseBraceToken);
        public TypeDecl WithFields(SyntaxList<FieldDecl> fields) => Update(this.TypeKeyword, this.Name, this.OpenBraceToken, fields, this.CloseBraceToken);
        public TypeDecl WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.TypeKeyword, this.Name, this.OpenBraceToken, this.Fields, closeBraceToken);

        public TypeDecl AddFields(params FieldDecl[] items) => WithFields(this.Fields.AddRange(items));
    }

    /// <summary>Class representing one or more attributes applied to a language construct.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AttributeList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AttributeListSyntax : AquilaSyntaxNode
    {
        private SyntaxNode? attributes;

        internal AttributeListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.AttributeListSyntax)this.Green).openBracketToken, Position, 0);

        /// <summary>Gets the attribute declaration list.</summary>
        public SeparatedSyntaxList<AttributeSyntax> Attributes
        {
            get
            {
                var red = GetRed(ref this.attributes, 1);
                return red != null ? new SeparatedSyntaxList<AttributeSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.AttributeListSyntax)this.Green).closeBracketToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.attributes, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.attributes : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttributeList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAttributeList(this);

        public AttributeListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.AttributeList(openBracketToken, attributes, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AttributeListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.Attributes, this.CloseBracketToken);
        public AttributeListSyntax WithAttributes(SeparatedSyntaxList<AttributeSyntax> attributes) => Update(this.OpenBracketToken, attributes, this.CloseBracketToken);
        public AttributeListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.Attributes, closeBracketToken);

        public AttributeListSyntax AddAttributes(params AttributeSyntax[] items) => WithAttributes(this.Attributes.AddRange(items));
    }

    /// <summary>Attribute syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Attribute"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AttributeSyntax : AquilaSyntaxNode
    {
        private NameEx? name;
        private AttributeArgumentListSyntax? argumentList;

        internal AttributeSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the name.</summary>
        public NameEx Name => GetRedAtZero(ref this.name)!;

        public AttributeArgumentListSyntax? ArgumentList => GetRed(ref this.argumentList, 1);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.name)!,
                1 => GetRed(ref this.argumentList, 1),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.argumentList,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttribute(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAttribute(this);

        public AttributeSyntax Update(NameEx name, AttributeArgumentListSyntax? argumentList)
        {
            if (name != this.Name || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.Attribute(name, argumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AttributeSyntax WithName(NameEx name) => Update(name, this.ArgumentList);
        public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax? argumentList) => Update(this.Name, argumentList);

        public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items)
        {
            var argumentList = this.ArgumentList ?? SyntaxFactory.AttributeArgumentList();
            return WithArgumentList(argumentList.WithArguments(argumentList.Arguments.AddRange(items)));
        }
    }

    /// <summary>Attribute argument list syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AttributeArgumentList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AttributeArgumentListSyntax : AquilaSyntaxNode
    {
        private SyntaxNode? arguments;

        internal AttributeArgumentListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.AttributeArgumentListSyntax)this.Green).openParenToken, Position, 0);

        /// <summary>Gets the arguments syntax list.</summary>
        public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments
        {
            get
            {
                var red = GetRed(ref this.arguments, 1);
                return red != null ? new SeparatedSyntaxList<AttributeArgumentSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.AttributeArgumentListSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.arguments, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.arguments : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttributeArgumentList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAttributeArgumentList(this);

        public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Arguments, this.CloseParenToken);
        public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList<AttributeArgumentSyntax> arguments) => Update(this.OpenParenToken, arguments, this.CloseParenToken);
        public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Arguments, closeParenToken);

        public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items) => WithArguments(this.Arguments.AddRange(items));
    }

    /// <summary>Attribute argument syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AttributeArgument"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AttributeArgumentSyntax : AquilaSyntaxNode
    {
        private NameEqualsSyntax? nameEquals;
        private ExprSyntax? expression;

        internal AttributeArgumentSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public NameEqualsSyntax? NameEquals => GetRedAtZero(ref this.nameEquals);

        /// <summary>Gets the expression.</summary>
        public ExprSyntax Expression => GetRed(ref this.expression, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.nameEquals),
                1 => GetRed(ref this.expression, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.nameEquals,
                1 => this.expression,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAttributeArgument(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAttributeArgument(this);

        public AttributeArgumentSyntax Update(NameEqualsSyntax? nameEquals, ExprSyntax expression)
        {
            if (nameEquals != this.NameEquals || expression != this.Expression)
            {
                var newNode = SyntaxFactory.AttributeArgument(nameEquals, expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax? nameEquals) => Update(nameEquals, this.Expression);
        public AttributeArgumentSyntax WithExpression(ExprSyntax expression) => Update(this.NameEquals, expression);
    }

    /// <summary>Class representing an identifier name followed by an equals token.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NameEquals"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NameEqualsSyntax : AquilaSyntaxNode
    {
        private IdentifierEx? name;

        internal NameEqualsSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the identifier name.</summary>
        public IdentifierEx Name => GetRedAtZero(ref this.name)!;

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.NameEqualsSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.name)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.name : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitNameEquals(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNameEquals(this);

        public NameEqualsSyntax Update(IdentifierEx name, SyntaxToken equalsToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken)
            {
                var newNode = SyntaxFactory.NameEquals(name, equalsToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NameEqualsSyntax WithName(IdentifierEx name) => Update(name, this.EqualsToken);
        public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Name, equalsToken);
    }

    /// <summary>Type parameter list syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeParameterListSyntax : AquilaSyntaxNode
    {
        private SyntaxNode? parameters;

        internal TypeParameterListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the &lt; token.</summary>
        public SyntaxToken LessThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).lessThanToken, Position, 0);

        /// <summary>Gets the parameter list.</summary>
        public SeparatedSyntaxList<TypeParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<TypeParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the &gt; token.</summary>
        public SyntaxToken GreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).greaterThanToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeParameterList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeParameterList(this);

        public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken) => Update(lessThanToken, this.Parameters, this.GreaterThanToken);
        public TypeParameterListSyntax WithParameters(SeparatedSyntaxList<TypeParameterSyntax> parameters) => Update(this.LessThanToken, parameters, this.GreaterThanToken);
        public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) => Update(this.LessThanToken, this.Parameters, greaterThanToken);

        public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>Type parameter syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeParameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeParameterSyntax : AquilaSyntaxNode
    {
        private SyntaxNode? attributeLists;

        internal TypeParameterSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public SyntaxList<AttributeListSyntax> AttributeLists => new SyntaxList<AttributeListSyntax>(GetRed(ref this.attributeLists, 0));

        public SyntaxToken VarianceKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.TypeParameterSyntax)this.Green).varianceKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeParameterSyntax)this.Green).identifier, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.attributeLists)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.attributeLists : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeParameter(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeParameter(this);

        public TypeParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
        {
            if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => Update(attributeLists, this.VarianceKeyword, this.Identifier);
        public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword) => Update(this.AttributeLists, varianceKeyword, this.Identifier);
        public TypeParameterSyntax WithIdentifier(SyntaxToken identifier) => Update(this.AttributeLists, this.VarianceKeyword, identifier);

        public TypeParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) => WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    /// <summary>Class which represents an expression that has a binary operator.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AddExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.SubtractExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiplyExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.DivideExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ModuloExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LeftShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.RightShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalAndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseAndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExclusiveOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.EqualsExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NotEqualsExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.IsExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.AsExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.CoalesceExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BinaryEx : ExprSyntax
    {
        private ExprSyntax? left;
        private ExprSyntax? right;

        internal BinaryEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        public ExprSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BinaryEx)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.
        /// </summary>
        public ExprSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBinaryEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBinaryEx(this);

        public BinaryEx Update(ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryEx(this.Kind(), left, operatorToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BinaryEx WithLeft(ExprSyntax left) => Update(left, this.OperatorToken, this.Right);
        public BinaryEx WithOperatorToken(SyntaxToken operatorToken) => Update(this.Left, operatorToken, this.Right);
        public BinaryEx WithRight(ExprSyntax right) => Update(this.Left, this.OperatorToken, right);
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParenthesizedExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParenthesizedEx : ExprSyntax
    {
        private ExprSyntax? expression;

        internal ParenthesizedEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedEx)this.Green).openParenToken, Position, 0);

        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExprSyntax Expression => GetRed(ref this.expression, 1)!;

        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedEx)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitParenthesizedEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParenthesizedEx(this);

        public ParenthesizedEx Update(SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedEx(openParenToken, expression, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParenthesizedEx WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Expression, this.CloseParenToken);
        public ParenthesizedEx WithExpression(ExprSyntax expression) => Update(this.OpenParenToken, expression, this.CloseParenToken);
        public ParenthesizedEx WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Expression, closeParenToken);
    }

    /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnaryPlusExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.UnaryMinusExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseNotExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalNotExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.PreIncrementExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.PreDecrementExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.AddressOfExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.PointerIndirectionExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.IndexExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class PrefixUnaryEx : ExprSyntax
    {
        private ExprSyntax? operand;

        internal PrefixUnaryEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.PrefixUnaryEx)this.Green).operatorToken, Position, 0);

        /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        public ExprSyntax Operand => GetRed(ref this.operand, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.operand, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.operand : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitPrefixUnaryEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitPrefixUnaryEx(this);

        public PrefixUnaryEx Update(SyntaxToken operatorToken, ExprSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.PrefixUnaryEx(this.Kind(), operatorToken, operand);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public PrefixUnaryEx WithOperatorToken(SyntaxToken operatorToken) => Update(operatorToken, this.Operand);
        public PrefixUnaryEx WithOperand(ExprSyntax operand) => Update(this.OperatorToken, operand);
    }

    /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.PostIncrementExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.PostDecrementExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.SuppressNullableWarningExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class PostfixUnaryEx : ExprSyntax
    {
        private ExprSyntax? operand;

        internal PostfixUnaryEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        public ExprSyntax Operand => GetRedAtZero(ref this.operand)!;

        /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.PostfixUnaryEx)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.operand)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.operand : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitPostfixUnaryEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitPostfixUnaryEx(this);

        public PostfixUnaryEx Update(ExprSyntax operand, SyntaxToken operatorToken)
        {
            if (operand != this.Operand || operatorToken != this.OperatorToken)
            {
                var newNode = SyntaxFactory.PostfixUnaryEx(this.Kind(), operand, operatorToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public PostfixUnaryEx WithOperand(ExprSyntax operand) => Update(operand, this.OperatorToken);
        public PostfixUnaryEx WithOperatorToken(SyntaxToken operatorToken) => Update(this.Operand, operatorToken);
    }

    /// <summary>Class which represents the syntax node for invocation expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InvocationExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InvocationEx : ExprSyntax
    {
        private ExprSyntax? expression;
        private ArgumentListSyntax? argumentList;

        internal InvocationEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        public ExprSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.
        /// </summary>
        public ArgumentListSyntax ArgumentList => GetRed(ref this.argumentList, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.argumentList, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argumentList,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInvocationEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInvocationEx(this);

        public InvocationEx Update(ExprSyntax expression, ArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.InvocationEx(expression, argumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InvocationEx WithExpression(ExprSyntax expression) => Update(expression, this.ArgumentList);
        public InvocationEx WithArgumentList(ArgumentListSyntax argumentList) => Update(this.Expression, argumentList);

        public InvocationEx AddArgumentListArguments(params ArgumentSyntax[] items) => WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }

    /// <summary>Class which represents an expression that has an assignment operator.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SimpleAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.AddAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.SubtractAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiplyAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.DivideAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ModuloAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.AndAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExclusiveOrAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.OrAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LeftShiftAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.RightShiftAssignmentExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.CoalesceAssignmentExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AssignEx : ExprSyntax
    {
        private ExprSyntax? left;
        private ExprSyntax? right;

        internal AssignEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.
        /// </summary>
        public ExprSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.AssignEx)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.
        /// </summary>
        public ExprSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAssignEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAssignEx(this);

        public AssignEx Update(ExprSyntax left, SyntaxToken operatorToken, ExprSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.AssignEx(this.Kind(), left, operatorToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AssignEx WithLeft(ExprSyntax left) => Update(left, this.OperatorToken, this.Right);
        public AssignEx WithOperatorToken(SyntaxToken operatorToken) => Update(this.Left, operatorToken, this.Right);
        public AssignEx WithRight(ExprSyntax right) => Update(this.Left, this.OperatorToken, right);
    }

    /// <summary>Class which represents the syntax node for element access expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElementAccessExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElementAccessEx : ExprSyntax
    {
        private ExprSyntax? expression;
        private BracketedArgumentListSyntax? argumentList;

        internal ElementAccessEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        public ExprSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access
        /// expression.
        /// </summary>
        public BracketedArgumentListSyntax ArgumentList => GetRed(ref this.argumentList, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.argumentList, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argumentList,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitElementAccessEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElementAccessEx(this);

        public ElementAccessEx Update(ExprSyntax expression, BracketedArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.ElementAccessEx(expression, argumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElementAccessEx WithExpression(ExprSyntax expression) => Update(expression, this.ArgumentList);
        public ElementAccessEx WithArgumentList(BracketedArgumentListSyntax argumentList) => Update(this.Expression, argumentList);

        public ElementAccessEx AddArgumentListArguments(params ArgumentSyntax[] items) => WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }

    /// <summary>Class which represents the syntax node for member access expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SimpleMemberAccessExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.PointerMemberAccessExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MemberAccessEx : ExprSyntax
    {
        private ExprSyntax? expression;
        private NameEx? name;

        internal MemberAccessEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        public ExprSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.MemberAccessEx)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        public NameEx Name => GetRed(ref this.name, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                2 => GetRed(ref this.name, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                2 => this.name,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMemberAccessEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMemberAccessEx(this);

        public MemberAccessEx Update(ExprSyntax expression, SyntaxToken operatorToken, NameEx name)
        {
            if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MemberAccessEx(this.Kind(), expression, operatorToken, name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MemberAccessEx WithExpression(ExprSyntax expression) => Update(expression, this.OperatorToken, this.Name);
        public MemberAccessEx WithOperatorToken(SyntaxToken operatorToken) => Update(this.Expression, operatorToken, this.Name);
        public MemberAccessEx WithName(NameEx name) => Update(this.Expression, this.OperatorToken, name);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InterpolatedStringExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolatedStringEx : ExprSyntax
    {
        private SyntaxNode? contents;

        internal InterpolatedStringEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The first part of an interpolated string, $" or $@"</summary>
        public SyntaxToken StringStartToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolatedStringEx)this.Green).stringStartToken, Position, 0);

        /// <summary>List of parts of the interpolated string, each one is either a literal part or an
        /// interpolation.
        /// </summary>
        public SyntaxList<InterpolatedStringContentSyntax> Contents => new SyntaxList<InterpolatedStringContentSyntax>(GetRed(ref this.contents, 1));

        /// <summary>The closing quote of the interpolated string.</summary>
        public SyntaxToken StringEndToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolatedStringEx)this.Green).stringEndToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.contents, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.contents : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolatedStringEx(this);

        public InterpolatedStringEx Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
            if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringEx(stringStartToken, contents, stringEndToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolatedStringEx WithStringStartToken(SyntaxToken stringStartToken) => Update(stringStartToken, this.Contents, this.StringEndToken);
        public InterpolatedStringEx WithContents(SyntaxList<InterpolatedStringContentSyntax> contents) => Update(this.StringStartToken, contents, this.StringEndToken);
        public InterpolatedStringEx WithStringEndToken(SyntaxToken stringEndToken) => Update(this.StringStartToken, this.Contents, stringEndToken);

        public InterpolatedStringEx AddContents(params InterpolatedStringContentSyntax[] items) => WithContents(this.Contents.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for a range expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.RangeExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class RangeEx : ExprSyntax
    {
        private ExprSyntax? leftOperand;
        private ExprSyntax? rightOperand;

        internal RangeEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
        public ExprSyntax? LeftOperand => GetRedAtZero(ref this.leftOperand);

        /// <summary>SyntaxToken representing the operator of the range expression.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.RangeEx)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
        public ExprSyntax? RightOperand => GetRed(ref this.rightOperand, 2);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.leftOperand),
                2 => GetRed(ref this.rightOperand, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.leftOperand,
                2 => this.rightOperand,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitRangeEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitRangeEx(this);

        public RangeEx Update(ExprSyntax? leftOperand, SyntaxToken operatorToken, ExprSyntax? rightOperand)
        {
            if (leftOperand != this.LeftOperand || operatorToken != this.OperatorToken || rightOperand != this.RightOperand)
            {
                var newNode = SyntaxFactory.RangeEx(leftOperand, operatorToken, rightOperand);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public RangeEx WithLeftOperand(ExprSyntax? leftOperand) => Update(leftOperand, this.OperatorToken, this.RightOperand);
        public RangeEx WithOperatorToken(SyntaxToken operatorToken) => Update(this.LeftOperand, operatorToken, this.RightOperand);
        public RangeEx WithRightOperand(ExprSyntax? rightOperand) => Update(this.LeftOperand, this.OperatorToken, rightOperand);
    }

    /// <summary>Class which represents the syntax node for conditional expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ConditionalExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ConditionalEx : ExprSyntax
    {
        private ExprSyntax? condition;
        private ExprSyntax? whenTrue;
        private ExprSyntax? whenFalse;

        internal ConditionalEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        public ExprSyntax Condition => GetRedAtZero(ref this.condition)!;

        /// <summary>SyntaxToken representing the question mark.</summary>
        public SyntaxToken QuestionToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ConditionalEx)this.Green).questionToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.
        /// </summary>
        public ExprSyntax WhenTrue => GetRed(ref this.whenTrue, 2)!;

        /// <summary>SyntaxToken representing the colon.</summary>
        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ConditionalEx)this.Green).colonToken, GetChildPosition(3), GetChildIndex(3));

        /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.
        /// </summary>
        public ExprSyntax WhenFalse => GetRed(ref this.whenFalse, 4)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.condition)!,
                2 => GetRed(ref this.whenTrue, 2)!,
                4 => GetRed(ref this.whenFalse, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.condition,
                2 => this.whenTrue,
                4 => this.whenFalse,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitConditionalEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitConditionalEx(this);

        public ConditionalEx Update(ExprSyntax condition, SyntaxToken questionToken, ExprSyntax whenTrue, SyntaxToken colonToken, ExprSyntax whenFalse)
        {
            if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
            {
                var newNode = SyntaxFactory.ConditionalEx(condition, questionToken, whenTrue, colonToken, whenFalse);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ConditionalEx WithCondition(ExprSyntax condition) => Update(condition, this.QuestionToken, this.WhenTrue, this.ColonToken, this.WhenFalse);
        public ConditionalEx WithQuestionToken(SyntaxToken questionToken) => Update(this.Condition, questionToken, this.WhenTrue, this.ColonToken, this.WhenFalse);
        public ConditionalEx WithWhenTrue(ExprSyntax whenTrue) => Update(this.Condition, this.QuestionToken, whenTrue, this.ColonToken, this.WhenFalse);
        public ConditionalEx WithColonToken(SyntaxToken colonToken) => Update(this.Condition, this.QuestionToken, this.WhenTrue, colonToken, this.WhenFalse);
        public ConditionalEx WithWhenFalse(ExprSyntax whenFalse) => Update(this.Condition, this.QuestionToken, this.WhenTrue, this.ColonToken, whenFalse);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ThrowExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ThrowEx : ExprSyntax
    {
        private ExprSyntax? expression;

        internal ThrowEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ThrowKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ThrowEx)this.Green).throwKeyword, Position, 0);

        public ExprSyntax Expression => GetRed(ref this.expression, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitThrowEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitThrowEx(this);

        public ThrowEx Update(SyntaxToken throwKeyword, ExprSyntax expression)
        {
            if (throwKeyword != this.ThrowKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.ThrowEx(throwKeyword, expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ThrowEx WithThrowKeyword(SyntaxToken throwKeyword) => Update(throwKeyword, this.Expression);
        public ThrowEx WithExpression(ExprSyntax expression) => Update(this.ThrowKeyword, expression);
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArgListExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NumericLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.StringLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.CharacterLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.TrueLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FalseLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NullLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.DefaultLiteralExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LiteralEx : ExprSyntax
    {
        internal LiteralEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.
        /// </summary>
        public SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.LiteralEx)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitLiteralEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLiteralEx(this);

        public LiteralEx Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralEx(this.Kind(), token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LiteralEx WithToken(SyntaxToken token) => Update(token);
    }

    /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArrowExpressionClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArrowExClause : AquilaSyntaxNode
    {
        private ExprSyntax? expression;

        internal ArrowExClause(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ArrowToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ArrowExClause)this.Green).arrowToken, Position, 0);

        public ExprSyntax Expression => GetRed(ref this.expression, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArrowExClause(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArrowExClause(this);

        public ArrowExClause Update(SyntaxToken arrowToken, ExprSyntax expression)
        {
            if (arrowToken != this.ArrowToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.ArrowExClause(arrowToken, expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArrowExClause WithArrowToken(SyntaxToken arrowToken) => Update(arrowToken, this.Expression);
        public ArrowExClause WithExpression(ExprSyntax expression) => Update(this.ArrowToken, expression);
    }

    /// <summary>Class which represents the syntax node for initializer expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ObjectInitializerExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.CollectionInitializerExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ArrayInitializerExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ComplexElementInitializerExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.WithInitializerExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InitializerEx : ExprSyntax
    {
        private SyntaxNode? expressions;

        internal InitializerEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InitializerEx)this.Green).openBraceToken, Position, 0);

        /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer
        /// expression.
        /// </summary>
        public SeparatedSyntaxList<ExprSyntax> Expressions
        {
            get
            {
                var red = GetRed(ref this.expressions, 1);
                return red != null ? new SeparatedSyntaxList<ExprSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InitializerEx)this.Green).closeBraceToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expressions, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expressions : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInitializerEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInitializerEx(this);

        public InitializerEx Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExprSyntax> expressions, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.InitializerEx(this.Kind(), openBraceToken, expressions, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InitializerEx WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Expressions, this.CloseBraceToken);
        public InitializerEx WithExpressions(SeparatedSyntaxList<ExprSyntax> expressions) => Update(this.OpenBraceToken, expressions, this.CloseBraceToken);
        public InitializerEx WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Expressions, closeBraceToken);

        public InitializerEx AddExpressions(params ExprSyntax[] items) => WithExpressions(this.Expressions.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AllocExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AllocEx : ExprSyntax
    {
        private TypeEx? name;
        private InitializerEx? initializer;

        internal AllocEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public TypeEx Name => GetRedAtZero(ref this.name)!;

        /// <summary>Initializer for type</summary>
        public InitializerEx Initializer => GetRed(ref this.initializer, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.name)!,
                1 => GetRed(ref this.initializer, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.initializer,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitAllocEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAllocEx(this);

        public AllocEx Update(TypeEx name, InitializerEx initializer)
        {
            if (name != this.Name || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.AllocEx(name, initializer);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AllocEx WithName(TypeEx name) => Update(name, this.Initializer);
        public AllocEx WithInitializer(InitializerEx initializer) => Update(this.Name, initializer);

        public AllocEx AddInitializerExpressions(params ExprSyntax[] items) => WithInitializer(this.Initializer.WithExpressions(this.Initializer.Expressions.AddRange(items)));
    }

    /// <summary>Represents a match expression syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MatchExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MatchEx : ExprSyntax
    {
        private ExprSyntax? expression;
        private SyntaxNode? arms;

        internal MatchEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the match keyword.
        /// </summary>
        public SyntaxToken MatchKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.MatchEx)this.Green).matchKeyword, Position, 0);

        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
        /// </summary>
        public SyntaxToken OpenParenToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.MatchEx)this.Green).openParenToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>
        /// Gets an ExpressionSyntax representing the expression of the match ex.
        /// </summary>
        public ExprSyntax Expression => GetRed(ref this.expression, 2)!;

        /// <summary>
        /// Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
        /// </summary>
        public SyntaxToken CloseParenToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.MatchEx)this.Green).closeParenToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
        /// </summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.MatchEx)this.Green).openBraceToken, GetChildPosition(4), GetChildIndex(4));

        /// <summary>
        /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch
        /// statement.
        /// </summary>
        public SeparatedSyntaxList<MatchArm> Arms
        {
            get
            {
                var red = GetRed(ref this.arms, 5);
                return red != null ? new SeparatedSyntaxList<MatchArm>(red, GetChildIndex(5)) : default;
            }
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the open braces following the switch sections.
        /// </summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.MatchEx)this.Green).closeBraceToken, GetChildPosition(6), GetChildIndex(6));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                2 => GetRed(ref this.expression, 2)!,
                5 => GetRed(ref this.arms, 5)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                2 => this.expression,
                5 => this.arms,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMatchEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMatchEx(this);

        public MatchEx Update(SyntaxToken matchKeyword, SyntaxToken openParenToken, ExprSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SeparatedSyntaxList<MatchArm> arms, SyntaxToken closeBraceToken)
        {
            if (matchKeyword != this.MatchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || arms != this.Arms || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.MatchEx(matchKeyword, openParenToken, expression, closeParenToken, openBraceToken, arms, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MatchEx WithMatchKeyword(SyntaxToken matchKeyword) => Update(matchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Arms, this.CloseBraceToken);
        public MatchEx WithOpenParenToken(SyntaxToken openParenToken) => Update(this.MatchKeyword, openParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Arms, this.CloseBraceToken);
        public MatchEx WithExpression(ExprSyntax expression) => Update(this.MatchKeyword, this.OpenParenToken, expression, this.CloseParenToken, this.OpenBraceToken, this.Arms, this.CloseBraceToken);
        public MatchEx WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.MatchKeyword, this.OpenParenToken, this.Expression, closeParenToken, this.OpenBraceToken, this.Arms, this.CloseBraceToken);
        public MatchEx WithOpenBraceToken(SyntaxToken openBraceToken) => Update(this.MatchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, openBraceToken, this.Arms, this.CloseBraceToken);
        public MatchEx WithArms(SeparatedSyntaxList<MatchArm> arms) => Update(this.MatchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, arms, this.CloseBraceToken);
        public MatchEx WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.MatchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Arms, closeBraceToken);

        public MatchEx AddArms(params MatchArm[] items) => WithArms(this.Arms.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MatchArm"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MatchArm : AquilaSyntaxNode
    {
        private ExprSyntax? patternExpression;
        private ExprSyntax? resultExpression;

        internal MatchArm(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
        /// </summary>
        public SyntaxToken BarToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.MatchArm)this.Green).barToken;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        /// <summary>
        /// Gets an ExpressionSyntax representing the expression of the match ex.
        /// </summary>
        public ExprSyntax PatternExpression => GetRed(ref this.patternExpression, 1)!;

        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
        /// </summary>
        public SyntaxToken EqualsGreaterThanToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.MatchArm)this.Green).equalsGreaterThanToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        /// <summary>
        /// Gets an ExpressionSyntax representing the expression of the match ex.
        /// </summary>
        public ExprSyntax ResultExpression => GetRed(ref this.resultExpression, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.patternExpression, 1)!,
                3 => GetRed(ref this.resultExpression, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.patternExpression,
                3 => this.resultExpression,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitMatchArm(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMatchArm(this);

        public MatchArm Update(SyntaxToken barToken, ExprSyntax patternExpression, SyntaxToken equalsGreaterThanToken, ExprSyntax resultExpression)
        {
            if (barToken != this.BarToken || patternExpression != this.PatternExpression || equalsGreaterThanToken != this.EqualsGreaterThanToken || resultExpression != this.ResultExpression)
            {
                var newNode = SyntaxFactory.MatchArm(barToken, patternExpression, equalsGreaterThanToken, resultExpression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MatchArm WithBarToken(SyntaxToken barToken) => Update(barToken, this.PatternExpression, this.EqualsGreaterThanToken, this.ResultExpression);
        public MatchArm WithPatternExpression(ExprSyntax patternExpression) => Update(this.BarToken, patternExpression, this.EqualsGreaterThanToken, this.ResultExpression);
        public MatchArm WithEqualsGreaterThanToken(SyntaxToken equalsGreaterThanToken) => Update(this.BarToken, this.PatternExpression, equalsGreaterThanToken, this.ResultExpression);
        public MatchArm WithResultExpression(ExprSyntax resultExpression) => Update(this.BarToken, this.PatternExpression, this.EqualsGreaterThanToken, resultExpression);
    }

    public abstract partial class InterpolatedStringContentSyntax : AquilaSyntaxNode
    {
        internal InterpolatedStringContentSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InterpolatedStringText"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
    {
        internal InterpolatedStringTextSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The text contents of a part of the interpolated string.</summary>
        public SyntaxToken TextToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolatedStringTextSyntax)this.Green).textToken, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringText(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolatedStringText(this);

        public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
        {
            if (textToken != this.TextToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringText(textToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken) => Update(textToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Interpolation"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
    {
        private ExprSyntax? expression;
        private InterpolationAlignmentClauseSyntax? alignmentClause;
        private InterpolationFormatClauseSyntax? formatClause;

        internal InterpolationSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolationSyntax)this.Green).openBraceToken, Position, 0);

        public ExprSyntax Expression => GetRed(ref this.expression, 1)!;

        public InterpolationAlignmentClauseSyntax? AlignmentClause => GetRed(ref this.alignmentClause, 2);

        public InterpolationFormatClauseSyntax? FormatClause => GetRed(ref this.formatClause, 3);

        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolationSyntax)this.Green).closeBraceToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.expression, 1)!,
                2 => GetRed(ref this.alignmentClause, 2),
                3 => GetRed(ref this.formatClause, 3),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.expression,
                2 => this.alignmentClause,
                3 => this.formatClause,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolation(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolation(this);

        public InterpolationSyntax Update(SyntaxToken openBraceToken, ExprSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Expression, this.AlignmentClause, this.FormatClause, this.CloseBraceToken);
        public InterpolationSyntax WithExpression(ExprSyntax expression) => Update(this.OpenBraceToken, expression, this.AlignmentClause, this.FormatClause, this.CloseBraceToken);
        public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax? alignmentClause) => Update(this.OpenBraceToken, this.Expression, alignmentClause, this.FormatClause, this.CloseBraceToken);
        public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax? formatClause) => Update(this.OpenBraceToken, this.Expression, this.AlignmentClause, formatClause, this.CloseBraceToken);
        public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Expression, this.AlignmentClause, this.FormatClause, closeBraceToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InterpolationAlignmentClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolationAlignmentClauseSyntax : AquilaSyntaxNode
    {
        private ExprSyntax? value;

        internal InterpolationAlignmentClauseSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken CommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax)this.Green).commaToken, Position, 0);

        public ExprSyntax Value => GetRed(ref this.value, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.value, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.value : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolationAlignmentClause(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolationAlignmentClause(this);

        public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExprSyntax value)
        {
            if (commaToken != this.CommaToken || value != this.Value)
            {
                var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken) => Update(commaToken, this.Value);
        public InterpolationAlignmentClauseSyntax WithValue(ExprSyntax value) => Update(this.CommaToken, value);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InterpolationFormatClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolationFormatClauseSyntax : AquilaSyntaxNode
    {
        internal InterpolationFormatClauseSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolationFormatClauseSyntax)this.Green).colonToken, Position, 0);

        /// <summary>The text contents of the format specifier for an interpolation.</summary>
        public SyntaxToken FormatStringToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolationFormatClauseSyntax)this.Green).formatStringToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitInterpolationFormatClause(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolationFormatClause(this);

        public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
        {
            if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
            {
                var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken) => Update(colonToken, this.FormatStringToken);
        public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken) => Update(this.ColonToken, formatStringToken);
    }

    /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are
    /// derived. This is an abstract class.
    /// </summary>
    public abstract partial class BaseArgumentListSyntax : AquilaSyntaxNode
    {
        internal BaseArgumentListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
        public BaseArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) => WithArgumentsCore(arguments);
        internal abstract BaseArgumentListSyntax WithArgumentsCore(SeparatedSyntaxList<ArgumentSyntax> arguments);

        public BaseArgumentListSyntax AddArguments(params ArgumentSyntax[] items) => AddArgumentsCore(items);
        internal abstract BaseArgumentListSyntax AddArgumentsCore(params ArgumentSyntax[] items);
    }

    /// <summary>Class which represents the syntax node for the list of arguments.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArgumentList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
    {
        private SyntaxNode? arguments;

        internal ArgumentListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ArgumentListSyntax)this.Green).openParenToken, Position, 0);

        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public override SeparatedSyntaxList<ArgumentSyntax> Arguments
        {
            get
            {
                var red = GetRed(ref this.arguments, 1);
                return red != null ? new SeparatedSyntaxList<ArgumentSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ArgumentListSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.arguments, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.arguments : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArgumentList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArgumentList(this);

        public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Arguments, this.CloseParenToken);
        internal override BaseArgumentListSyntax WithArgumentsCore(SeparatedSyntaxList<ArgumentSyntax> arguments) => WithArguments(arguments);
        public new ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) => Update(this.OpenParenToken, arguments, this.CloseParenToken);
        public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Arguments, closeParenToken);

        internal override BaseArgumentListSyntax AddArgumentsCore(params ArgumentSyntax[] items) => AddArguments(items);
        public new ArgumentListSyntax AddArguments(params ArgumentSyntax[] items) => WithArguments(this.Arguments.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BracketedArgumentList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
    {
        private SyntaxNode? arguments;

        internal BracketedArgumentListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing open bracket.</summary>
        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BracketedArgumentListSyntax)this.Green).openBracketToken, Position, 0);

        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public override SeparatedSyntaxList<ArgumentSyntax> Arguments
        {
            get
            {
                var red = GetRed(ref this.arguments, 1);
                return red != null ? new SeparatedSyntaxList<ArgumentSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>SyntaxToken representing close bracket.</summary>
        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BracketedArgumentListSyntax)this.Green).closeBracketToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.arguments, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.arguments : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBracketedArgumentList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBracketedArgumentList(this);

        public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.Arguments, this.CloseBracketToken);
        internal override BaseArgumentListSyntax WithArgumentsCore(SeparatedSyntaxList<ArgumentSyntax> arguments) => WithArguments(arguments);
        public new BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) => Update(this.OpenBracketToken, arguments, this.CloseBracketToken);
        public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.Arguments, closeBracketToken);

        internal override BaseArgumentListSyntax AddArgumentsCore(params ArgumentSyntax[] items) => AddArguments(items);
        public new BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items) => WithArguments(this.Arguments.AddRange(items));
    }

    /// <summary>Class which represents the syntax node for argument.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Argument"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArgumentSyntax : AquilaSyntaxNode
    {
        private NameColonSyntax? nameColon;
        private ExprSyntax? expression;

        internal ArgumentSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
        public NameColonSyntax? NameColon => GetRedAtZero(ref this.nameColon);

        /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        public SyntaxToken RefKindKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ArgumentSyntax)this.Green).refKindKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>ExpressionSyntax node representing the argument.</summary>
        public ExprSyntax Expression => GetRed(ref this.expression, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.nameColon),
                2 => GetRed(ref this.expression, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.nameColon,
                2 => this.expression,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArgument(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArgument(this);

        public ArgumentSyntax Update(NameColonSyntax? nameColon, SyntaxToken refKindKeyword, ExprSyntax expression)
        {
            if (nameColon != this.NameColon || refKindKeyword != this.RefKindKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.Argument(nameColon, refKindKeyword, expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArgumentSyntax WithNameColon(NameColonSyntax? nameColon) => Update(nameColon, this.RefKindKeyword, this.Expression);
        public ArgumentSyntax WithRefKindKeyword(SyntaxToken refKindKeyword) => Update(this.NameColon, refKindKeyword, this.Expression);
        public ArgumentSyntax WithExpression(ExprSyntax expression) => Update(this.NameColon, this.RefKindKeyword, expression);
    }

    public abstract partial class BaseExpressionColonSyntax : AquilaSyntaxNode
    {
        internal BaseExpressionColonSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract ExprSyntax Expression { get; }
        public BaseExpressionColonSyntax WithExpression(ExprSyntax expression) => WithExpressionCore(expression);
        internal abstract BaseExpressionColonSyntax WithExpressionCore(ExprSyntax expression);

        public abstract SyntaxToken ColonToken { get; }
        public BaseExpressionColonSyntax WithColonToken(SyntaxToken colonToken) => WithColonTokenCore(colonToken);
        internal abstract BaseExpressionColonSyntax WithColonTokenCore(SyntaxToken colonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionColon"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExprColonSyntax : BaseExpressionColonSyntax
    {
        private ExprSyntax? expression;

        internal ExprColonSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override ExprSyntax Expression => GetRedAtZero(ref this.expression)!;

        public override SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExprColonSyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expression)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitExprColon(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExprColon(this);

        public ExprColonSyntax Update(ExprSyntax expression, SyntaxToken colonToken)
        {
            if (expression != this.Expression || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.ExprColon(expression, colonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseExpressionColonSyntax WithExpressionCore(ExprSyntax expression) => WithExpression(expression);
        public new ExprColonSyntax WithExpression(ExprSyntax expression) => Update(expression, this.ColonToken);
        internal override BaseExpressionColonSyntax WithColonTokenCore(SyntaxToken colonToken) => WithColonToken(colonToken);
        public new ExprColonSyntax WithColonToken(SyntaxToken colonToken) => Update(this.Expression, colonToken);
    }

    /// <summary>Class which represents the syntax node for name colon syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NameColon"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NameColonSyntax : BaseExpressionColonSyntax
    {
        private IdentifierEx? name;

        internal NameColonSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public IdentifierEx Name => GetRedAtZero(ref this.name)!;

        /// <summary>SyntaxToken representing colon.</summary>
        public override SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.NameColonSyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.name)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.name : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitNameColon(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNameColon(this);

        public NameColonSyntax Update(IdentifierEx name, SyntaxToken colonToken)
        {
            if (name != this.Name || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.NameColon(name, colonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NameColonSyntax WithName(IdentifierEx name) => Update(name, this.ColonToken);
        internal override BaseExpressionColonSyntax WithColonTokenCore(SyntaxToken colonToken) => WithColonToken(colonToken);
        public new NameColonSyntax WithColonToken(SyntaxToken colonToken) => Update(this.Name, colonToken);
    }

    public abstract partial class TypeEx : ExprSyntax
    {
        internal TypeEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    public abstract partial class NameEx : TypeEx
    {
        internal NameEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Class which represents the syntax node for qualified name.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.QualifiedName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class QualifiedNameEx : NameEx
    {
        private NameEx? left;
        private SimpleNameEx? right;

        internal QualifiedNameEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified
        /// name.
        /// </summary>
        public NameEx Left => GetRedAtZero(ref this.left)!;

        /// <summary>SyntaxToken representing the dot.</summary>
        public SyntaxToken DotToken => new SyntaxToken(this, ((Syntax.InternalSyntax.QualifiedNameEx)this.Green).dotToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified
        /// name.
        /// </summary>
        public SimpleNameEx Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitQualifiedNameEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitQualifiedNameEx(this);

        public QualifiedNameEx Update(NameEx left, SyntaxToken dotToken, SimpleNameEx right)
        {
            if (left != this.Left || dotToken != this.DotToken || right != this.Right)
            {
                var newNode = SyntaxFactory.QualifiedNameEx(left, dotToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public QualifiedNameEx WithLeft(NameEx left) => Update(left, this.DotToken, this.Right);
        public QualifiedNameEx WithDotToken(SyntaxToken dotToken) => Update(this.Left, dotToken, this.Right);
        public QualifiedNameEx WithRight(SimpleNameEx right) => Update(this.Left, this.DotToken, right);
    }

    /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived.
    /// This is an abstract class.
    /// </summary>
    public abstract partial class SimpleNameEx : NameEx
    {
        internal SimpleNameEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
        public abstract SyntaxToken Identifier { get; }
        public SimpleNameEx WithIdentifier(SyntaxToken identifier) => WithIdentifierCore(identifier);
        internal abstract SimpleNameEx WithIdentifierCore(SyntaxToken identifier);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IdentifierEx"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IdentifierEx : SimpleNameEx
    {
        internal IdentifierEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the identifier.</summary>
        public override SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.IdentifierEx)this.Green).identifier, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIdentifierEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIdentifierEx(this);

        public IdentifierEx Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierEx(identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override SimpleNameEx WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
        public new IdentifierEx WithIdentifier(SyntaxToken identifier) => Update(identifier);
    }

    /// <summary>Class which represents the syntax node for generic name.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.GenericName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class GenericEx : SimpleNameEx
    {
        private TypeArgumentListSyntax? typeArgumentList;

        internal GenericEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        public override SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.GenericEx)this.Green).identifier, Position, 0);

        /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.
        /// </summary>
        public TypeArgumentListSyntax TypeArgumentList => GetRed(ref this.typeArgumentList, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.typeArgumentList, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.typeArgumentList : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitGenericEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitGenericEx(this);

        public GenericEx Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        {
            if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
            {
                var newNode = SyntaxFactory.GenericEx(identifier, typeArgumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override SimpleNameEx WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
        public new GenericEx WithIdentifier(SyntaxToken identifier) => Update(identifier, this.TypeArgumentList);
        public GenericEx WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList) => Update(this.Identifier, typeArgumentList);

        public GenericEx AddTypeArgumentListArguments(params TypeEx[] items) => WithTypeArgumentList(this.TypeArgumentList.WithArguments(this.TypeArgumentList.Arguments.AddRange(items)));
    }

    /// <summary>Class which represents the syntax node for predefined types.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.PredefinedType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class PredefinedTypeEx : TypeEx
    {
        internal PredefinedTypeEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        public SyntaxToken Keyword => new SyntaxToken(this, ((Syntax.InternalSyntax.PredefinedTypeEx)this.Green).keyword, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitPredefinedTypeEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitPredefinedTypeEx(this);

        public PredefinedTypeEx Update(SyntaxToken keyword)
        {
            if (keyword != this.Keyword)
            {
                var newNode = SyntaxFactory.PredefinedTypeEx(keyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public PredefinedTypeEx WithKeyword(SyntaxToken keyword) => Update(keyword);
    }

    /// <summary>Class which represents the syntax node for the array type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArrayType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArrayTypeEx : TypeEx
    {
        private TypeEx? elementType;
        private SyntaxNode? rankSpecifiers;

        internal ArrayTypeEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
        public TypeEx ElementType => GetRedAtZero(ref this.elementType)!;

        /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the
        /// array.
        /// </summary>
        public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers => new SyntaxList<ArrayRankSpecifierSyntax>(GetRed(ref this.rankSpecifiers, 1));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.elementType)!,
                1 => GetRed(ref this.rankSpecifiers, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.elementType,
                1 => this.rankSpecifiers,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArrayTypeEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArrayTypeEx(this);

        public ArrayTypeEx Update(TypeEx elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
        {
            if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
            {
                var newNode = SyntaxFactory.ArrayTypeEx(elementType, rankSpecifiers);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArrayTypeEx WithElementType(TypeEx elementType) => Update(elementType, this.RankSpecifiers);
        public ArrayTypeEx WithRankSpecifiers(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers) => Update(this.ElementType, rankSpecifiers);

        public ArrayTypeEx AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items) => WithRankSpecifiers(this.RankSpecifiers.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnionType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnionTypeEx : TypeEx
    {
        private SyntaxNode? types;

        internal UnionTypeEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.UnionTypeEx)this.Green).openParenToken, Position, 0);

        /// <summary>
        /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch
        /// statement.
        /// </summary>
        public SeparatedSyntaxList<TypeEx> Types
        {
            get
            {
                var red = GetRed(ref this.types, 1);
                return red != null ? new SeparatedSyntaxList<TypeEx>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.UnionTypeEx)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.types, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.types : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitUnionTypeEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnionTypeEx(this);

        public UnionTypeEx Update(SyntaxToken openParenToken, SeparatedSyntaxList<TypeEx> types, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || types != this.Types || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.UnionTypeEx(openParenToken, types, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnionTypeEx WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Types, this.CloseParenToken);
        public UnionTypeEx WithTypes(SeparatedSyntaxList<TypeEx> types) => Update(this.OpenParenToken, types, this.CloseParenToken);
        public UnionTypeEx WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Types, closeParenToken);

        public UnionTypeEx AddTypes(params TypeEx[] items) => WithTypes(this.Types.AddRange(items));
    }

    /// <summary>The ref modifier of a method's return value or a local.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.RefType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class RefTypeEx : TypeEx
    {
        private TypeEx? type;

        internal RefTypeEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken RefKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.RefTypeEx)this.Green).refKeyword, Position, 0);

        /// <summary>Gets the optional "readonly" keyword.</summary>
        public SyntaxToken ReadOnlyKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.RefTypeEx)this.Green).readOnlyKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public TypeEx Type => GetRed(ref this.type, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.type, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.type : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitRefTypeEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitRefTypeEx(this);

        public RefTypeEx Update(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeEx type)
        {
            if (refKeyword != this.RefKeyword || readOnlyKeyword != this.ReadOnlyKeyword || type != this.Type)
            {
                var newNode = SyntaxFactory.RefTypeEx(refKeyword, readOnlyKeyword, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public RefTypeEx WithRefKeyword(SyntaxToken refKeyword) => Update(refKeyword, this.ReadOnlyKeyword, this.Type);
        public RefTypeEx WithReadOnlyKeyword(SyntaxToken readOnlyKeyword) => Update(this.RefKeyword, readOnlyKeyword, this.Type);
        public RefTypeEx WithType(TypeEx type) => Update(this.RefKeyword, this.ReadOnlyKeyword, type);
    }

    /// <summary>Class which represents the syntax node for type argument list.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeArgumentList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeArgumentListSyntax : AquilaSyntaxNode
    {
        private SyntaxNode? arguments;

        internal TypeArgumentListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing less than.</summary>
        public SyntaxToken LessThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).lessThanToken, Position, 0);

        /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        public SeparatedSyntaxList<TypeEx> Arguments
        {
            get
            {
                var red = GetRed(ref this.arguments, 1);
                return red != null ? new SeparatedSyntaxList<TypeEx>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>SyntaxToken representing greater than.</summary>
        public SyntaxToken GreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).greaterThanToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.arguments, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.arguments : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeArgumentList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeArgumentList(this);

        public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeEx> arguments, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken) => Update(lessThanToken, this.Arguments, this.GreaterThanToken);
        public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeEx> arguments) => Update(this.LessThanToken, arguments, this.GreaterThanToken);
        public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) => Update(this.LessThanToken, this.Arguments, greaterThanToken);

        public TypeArgumentListSyntax AddArguments(params TypeEx[] items) => WithArguments(this.Arguments.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArrayRankSpecifier"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArrayRankSpecifierSyntax : AquilaSyntaxNode
    {
        private SyntaxNode? sizes;

        internal ArrayRankSpecifierSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ArrayRankSpecifierSyntax)this.Green).openBracketToken, Position, 0);

        public SeparatedSyntaxList<ExprSyntax> Sizes
        {
            get
            {
                var red = GetRed(ref this.sizes, 1);
                return red != null ? new SeparatedSyntaxList<ExprSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ArrayRankSpecifierSyntax)this.Green).closeBracketToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.sizes, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.sizes : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitArrayRankSpecifier(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArrayRankSpecifier(this);

        public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExprSyntax> sizes, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.Sizes, this.CloseBracketToken);
        public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList<ExprSyntax> sizes) => Update(this.OpenBracketToken, sizes, this.CloseBracketToken);
        public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.Sizes, closeBracketToken);

        public ArrayRankSpecifierSyntax AddSizes(params ExprSyntax[] items) => WithSizes(this.Sizes.AddRange(items));
    }

    /// <summary>Class which represents a placeholder in an array size list.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.OmittedArraySizeExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class OmittedArraySizeEx : ExprSyntax
    {
        internal OmittedArraySizeEx(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>SyntaxToken representing the omitted array size expression.</summary>
        public SyntaxToken OmittedArraySizeExpressionToken => new SyntaxToken(this, ((Syntax.InternalSyntax.OmittedArraySizeEx)this.Green).omittedArraySizeExpressionToken, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitOmittedArraySizeEx(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitOmittedArraySizeEx(this);

        public OmittedArraySizeEx Update(SyntaxToken omittedArraySizeExpressionToken)
        {
            if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
            {
                var newNode = SyntaxFactory.OmittedArraySizeEx(omittedArraySizeExpressionToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public OmittedArraySizeEx WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken) => Update(omittedArraySizeExpressionToken);
    }

    /// <summary>Base type for parameter list syntax.</summary>
    public abstract partial class BaseParameterListSyntax : AquilaSyntaxNode
    {
        internal BaseParameterListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the parameter list.</summary>
        public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
        public BaseParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) => WithParametersCore(parameters);
        internal abstract BaseParameterListSyntax WithParametersCore(SeparatedSyntaxList<ParameterSyntax> parameters);

        public BaseParameterListSyntax AddParameters(params ParameterSyntax[] items) => AddParametersCore(items);
        internal abstract BaseParameterListSyntax AddParametersCore(params ParameterSyntax[] items);
    }

    /// <summary>Parameter list syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterListSyntax : BaseParameterListSyntax
    {
        private SyntaxNode? parameters;

        internal ParameterListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).openParenToken, Position, 0);

        public override SeparatedSyntaxList<ParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<ParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Parameters, this.CloseParenToken);
        internal override BaseParameterListSyntax WithParametersCore(SeparatedSyntaxList<ParameterSyntax> parameters) => WithParameters(parameters);
        public new ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) => Update(this.OpenParenToken, parameters, this.CloseParenToken);
        public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Parameters, closeParenToken);

        internal override BaseParameterListSyntax AddParametersCore(params ParameterSyntax[] items) => AddParameters(items);
        public new ParameterListSyntax AddParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>Parameter list syntax with surrounding brackets.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BracketedParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
    {
        private SyntaxNode? parameters;

        internal BracketedParameterListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BracketedParameterListSyntax)this.Green).openBracketToken, Position, 0);

        public override SeparatedSyntaxList<ParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<ParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BracketedParameterListSyntax)this.Green).closeBracketToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBracketedParameterList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBracketedParameterList(this);

        public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.Parameters, this.CloseBracketToken);
        internal override BaseParameterListSyntax WithParametersCore(SeparatedSyntaxList<ParameterSyntax> parameters) => WithParameters(parameters);
        public new BracketedParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) => Update(this.OpenBracketToken, parameters, this.CloseBracketToken);
        public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.Parameters, closeBracketToken);

        internal override BaseParameterListSyntax AddParametersCore(params ParameterSyntax[] items) => AddParameters(items);
        public new BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>Base parameter syntax.</summary>
    public abstract partial class BaseParameterSyntax : AquilaSyntaxNode
    {
        internal BaseParameterSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public BaseParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => WithAttributeListsCore(attributeLists);
        internal abstract BaseParameterSyntax WithAttributeListsCore(SyntaxList<AttributeListSyntax> attributeLists);

        public BaseParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) => AddAttributeListsCore(items);
        internal abstract BaseParameterSyntax AddAttributeListsCore(params AttributeListSyntax[] items);

        /// <summary>Gets the modifier list.</summary>
        public abstract SyntaxTokenList Modifiers { get; }
        public BaseParameterSyntax WithModifiers(SyntaxTokenList modifiers) => WithModifiersCore(modifiers);
        internal abstract BaseParameterSyntax WithModifiersCore(SyntaxTokenList modifiers);

        public BaseParameterSyntax AddModifiers(params SyntaxToken[] items) => AddModifiersCore(items);
        internal abstract BaseParameterSyntax AddModifiersCore(params SyntaxToken[] items);

        public abstract TypeEx? Type { get; }
        public BaseParameterSyntax WithType(TypeEx? type) => WithTypeCore(type);
        internal abstract BaseParameterSyntax WithTypeCore(TypeEx? type);
    }

    /// <summary>Parameter syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Parameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterSyntax : BaseParameterSyntax
    {
        private SyntaxNode? attributeLists;
        private TypeEx? type;
        private EqualsValueClauseSyntax? @default;

        internal ParameterSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public override SyntaxList<AttributeListSyntax> AttributeLists => new SyntaxList<AttributeListSyntax>(GetRed(ref this.attributeLists, 0));

        /// <summary>Gets the modifier list.</summary>
        public override SyntaxTokenList Modifiers
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public override TypeEx? Type => GetRed(ref this.type, 2);

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterSyntax)this.Green).identifier, GetChildPosition(3), GetChildIndex(3));

        public EqualsValueClauseSyntax? Default => GetRed(ref this.@default, 4);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.attributeLists)!,
                2 => GetRed(ref this.type, 2),
                4 => GetRed(ref this.@default, 4),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                2 => this.type,
                4 => this.@default,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameter(this);

        public ParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeEx? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
            {
                var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, @default);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseParameterSyntax WithAttributeListsCore(SyntaxList<AttributeListSyntax> attributeLists) => WithAttributeLists(attributeLists);
        public new ParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => Update(attributeLists, this.Modifiers, this.Type, this.Identifier, this.Default);
        internal override BaseParameterSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
        public new ParameterSyntax WithModifiers(SyntaxTokenList modifiers) => Update(this.AttributeLists, modifiers, this.Type, this.Identifier, this.Default);
        internal override BaseParameterSyntax WithTypeCore(TypeEx? type) => WithType(type);
        public new ParameterSyntax WithType(TypeEx? type) => Update(this.AttributeLists, this.Modifiers, type, this.Identifier, this.Default);
        public ParameterSyntax WithIdentifier(SyntaxToken identifier) => Update(this.AttributeLists, this.Modifiers, this.Type, identifier, this.Default);
        public ParameterSyntax WithDefault(EqualsValueClauseSyntax? @default) => Update(this.AttributeLists, this.Modifiers, this.Type, this.Identifier, @default);

        internal override BaseParameterSyntax AddAttributeListsCore(params AttributeListSyntax[] items) => AddAttributeLists(items);
        public new ParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) => WithAttributeLists(this.AttributeLists.AddRange(items));
        internal override BaseParameterSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);
        public new ParameterSyntax AddModifiers(params SyntaxToken[] items) => WithModifiers(this.Modifiers.AddRange(items));
    }

    /// <summary>Parameter syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.FunctionPointerParameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FunctionPointerParameterSyntax : BaseParameterSyntax
    {
        private SyntaxNode? attributeLists;
        private TypeEx? type;

        internal FunctionPointerParameterSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public override SyntaxList<AttributeListSyntax> AttributeLists => new SyntaxList<AttributeListSyntax>(GetRed(ref this.attributeLists, 0));

        /// <summary>Gets the modifier list.</summary>
        public override SyntaxTokenList Modifiers
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public override TypeEx Type => GetRed(ref this.type, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.attributeLists)!,
                2 => GetRed(ref this.type, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                2 => this.type,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitFunctionPointerParameter(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitFunctionPointerParameter(this);

        public FunctionPointerParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeEx type)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
            {
                var newNode = SyntaxFactory.FunctionPointerParameter(attributeLists, modifiers, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override BaseParameterSyntax WithAttributeListsCore(SyntaxList<AttributeListSyntax> attributeLists) => WithAttributeLists(attributeLists);
        public new FunctionPointerParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => Update(attributeLists, this.Modifiers, this.Type);
        internal override BaseParameterSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
        public new FunctionPointerParameterSyntax WithModifiers(SyntaxTokenList modifiers) => Update(this.AttributeLists, modifiers, this.Type);
        internal override BaseParameterSyntax WithTypeCore(TypeEx? type) => WithType(type ?? throw new ArgumentNullException(nameof(type)));
        public new FunctionPointerParameterSyntax WithType(TypeEx type) => Update(this.AttributeLists, this.Modifiers, type);

        internal override BaseParameterSyntax AddAttributeListsCore(params AttributeListSyntax[] items) => AddAttributeLists(items);
        public new FunctionPointerParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) => WithAttributeLists(this.AttributeLists.AddRange(items));
        internal override BaseParameterSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);
        public new FunctionPointerParameterSyntax AddModifiers(params SyntaxToken[] items) => WithModifiers(this.Modifiers.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IncompleteMember"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IncompleteMemberSyntax : MemberDecl
    {
        private SyntaxNode? attributeLists;
        private TypeEx? type;

        internal IncompleteMemberSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override SyntaxList<AttributeListSyntax> AttributeLists => new SyntaxList<AttributeListSyntax>(GetRed(ref this.attributeLists, 0));

        public override SyntaxTokenList Modifiers
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public TypeEx? Type => GetRed(ref this.type, 2);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.attributeLists)!,
                2 => GetRed(ref this.type, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                2 => this.type,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIncompleteMember(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIncompleteMember(this);

        public IncompleteMemberSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeEx? type)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
            {
                var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override MemberDecl WithAttributeListsCore(SyntaxList<AttributeListSyntax> attributeLists) => WithAttributeLists(attributeLists);
        public new IncompleteMemberSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => Update(attributeLists, this.Modifiers, this.Type);
        internal override MemberDecl WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
        public new IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers) => Update(this.AttributeLists, modifiers, this.Type);
        public IncompleteMemberSyntax WithType(TypeEx? type) => Update(this.AttributeLists, this.Modifiers, type);

        internal override MemberDecl AddAttributeListsCore(params AttributeListSyntax[] items) => AddAttributeLists(items);
        public new IncompleteMemberSyntax AddAttributeLists(params AttributeListSyntax[] items) => WithAttributeLists(this.AttributeLists.AddRange(items));
        internal override MemberDecl AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);
        public new IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items) => WithModifiers(this.Modifiers.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SkippedTokensTrivia"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {
        internal SkippedTokensTriviaSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxTokenList Tokens
        {
            get
            {
                var slot = this.Green.GetSlot(0);
                return slot != null ? new SyntaxTokenList(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens) => Update(tokens);

        public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items) => WithTokens(this.Tokens.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.EqualsValueClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class EqualsValueClauseSyntax : AquilaSyntaxNode
    {
        private ExprSyntax? value;

        internal EqualsValueClauseSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.EqualsValueClauseSyntax)this.Green).equalsToken, Position, 0);

        public ExprSyntax Value => GetRed(ref this.value, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.value, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.value : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitEqualsValueClause(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitEqualsValueClause(this);

        public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExprSyntax value)
        {
            if (equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.EqualsValueClause(equalsToken, value);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(equalsToken, this.Value);
        public EqualsValueClauseSyntax WithValue(ExprSyntax value) => Update(this.EqualsToken, value);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.VariableDeclaration"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class VariableDecl : AquilaSyntaxNode
    {
        private TypeEx? type;
        private SyntaxNode? variables;

        internal VariableDecl(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public TypeEx Type => GetRedAtZero(ref this.type)!;

        public SeparatedSyntaxList<VariableInit> Variables
        {
            get
            {
                var red = GetRed(ref this.variables, 1);
                return red != null ? new SeparatedSyntaxList<VariableInit>(red, GetChildIndex(1)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.type)!,
                1 => GetRed(ref this.variables, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.variables,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitVariableDecl(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitVariableDecl(this);

        public VariableDecl Update(TypeEx type, SeparatedSyntaxList<VariableInit> variables)
        {
            if (type != this.Type || variables != this.Variables)
            {
                var newNode = SyntaxFactory.VariableDecl(type, variables);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public VariableDecl WithType(TypeEx type) => Update(type, this.Variables);
        public VariableDecl WithVariables(SeparatedSyntaxList<VariableInit> variables) => Update(this.Type, variables);

        public VariableDecl AddVariables(params VariableInit[] items) => WithVariables(this.Variables.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.VariableDeclarator"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class VariableInit : AquilaSyntaxNode
    {
        private BracketedArgumentListSyntax? argumentList;
        private EqualsValueClauseSyntax? initializer;

        internal VariableInit(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.VariableInit)this.Green).identifier, Position, 0);

        public BracketedArgumentListSyntax? ArgumentList => GetRed(ref this.argumentList, 1);

        public EqualsValueClauseSyntax? Initializer => GetRed(ref this.initializer, 2);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.argumentList, 1),
                2 => GetRed(ref this.initializer, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.argumentList,
                2 => this.initializer,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitVariableInit(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitVariableInit(this);

        public VariableInit Update(SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
        {
            if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.VariableInit(identifier, argumentList, initializer);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public VariableInit WithIdentifier(SyntaxToken identifier) => Update(identifier, this.ArgumentList, this.Initializer);
        public VariableInit WithArgumentList(BracketedArgumentListSyntax? argumentList) => Update(this.Identifier, argumentList, this.Initializer);
        public VariableInit WithInitializer(EqualsValueClauseSyntax? initializer) => Update(this.Identifier, this.ArgumentList, initializer);

        public VariableInit AddArgumentListArguments(params ArgumentSyntax[] items)
        {
            var argumentList = this.ArgumentList ?? SyntaxFactory.BracketedArgumentList();
            return WithArgumentList(argumentList.WithArguments(argumentList.Arguments.AddRange(items)));
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Block"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BlockStmt : StmtSyntax
    {
        private SyntaxNode? statements;

        internal BlockStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BlockStmt)this.Green).openBraceToken, Position, 0);

        public SyntaxList<StmtSyntax> Statements => new SyntaxList<StmtSyntax>(GetRed(ref this.statements, 1));

        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BlockStmt)this.Green).closeBraceToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.statements, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.statements : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBlockStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBlockStmt(this);

        public BlockStmt Update(SyntaxToken openBraceToken, SyntaxList<StmtSyntax> statements, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.BlockStmt(openBraceToken, statements, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BlockStmt WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Statements, this.CloseBraceToken);
        public BlockStmt WithStatements(SyntaxList<StmtSyntax> statements) => Update(this.OpenBraceToken, statements, this.CloseBraceToken);
        public BlockStmt WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Statements, closeBraceToken);

        public BlockStmt AddStatements(params StmtSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionStmt : StmtSyntax
    {
        private ExprSyntax? expression;

        internal ExpressionStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public ExprSyntax Expression => GetRedAtZero(ref this.expression)!;

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExpressionStmt)this.Green).semicolonToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expression)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitExpressionStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionStmt(this);

        public ExpressionStmt Update(ExprSyntax expression, SyntaxToken semicolonToken)
        {
            if (expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ExpressionStmt(expression, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionStmt WithExpression(ExprSyntax expression) => Update(expression, this.SemicolonToken);
        public ExpressionStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.Expression, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.EmptyStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class EmptyStmt : StmtSyntax
    {
        internal EmptyStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.EmptyStmt)this.Green).semicolonToken, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitEmptyStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitEmptyStmt(this);

        public EmptyStmt Update(SyntaxToken semicolonToken)
        {
            if (semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EmptyStmt(semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public EmptyStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(semicolonToken);
    }

    /// <summary>Represents a labeled statement syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LabeledStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LabeledStmt : StmtSyntax
    {
        private StmtSyntax? statement;

        internal LabeledStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.LabeledStmt)this.Green).identifier, Position, 0);

        /// <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.LabeledStmt)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        public StmtSyntax Statement => GetRed(ref this.statement, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.statement, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.statement : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitLabeledStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLabeledStmt(this);

        public LabeledStmt Update(SyntaxToken identifier, SyntaxToken colonToken, StmtSyntax statement)
        {
            if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.LabeledStmt(identifier, colonToken, statement);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LabeledStmt WithIdentifier(SyntaxToken identifier) => Update(identifier, this.ColonToken, this.Statement);
        public LabeledStmt WithColonToken(SyntaxToken colonToken) => Update(this.Identifier, colonToken, this.Statement);
        public LabeledStmt WithStatement(StmtSyntax statement) => Update(this.Identifier, this.ColonToken, statement);
    }

    /// <summary>
    /// Represents a goto statement syntax
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.GotoStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.GotoCaseStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.GotoDefaultStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class GotoStmt : StmtSyntax
    {
        private ExprSyntax? expression;

        internal GotoStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the goto keyword.
        /// </summary>
        public SyntaxToken GotoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoStmt)this.Green).gotoKeyword, Position, 0);

        /// <summary>
        /// Gets a SyntaxToken that represents the case or default keywords if any exists.
        /// </summary>
        public SyntaxToken CaseOrDefaultKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.GotoStmt)this.Green).caseOrDefaultKeyword;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        /// <summary>
        /// Gets a constant expression for a goto case statement.
        /// </summary>
        public ExprSyntax? Expression => GetRed(ref this.expression, 2);

        /// <summary>
        /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
        /// </summary>
        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoStmt)this.Green).semicolonToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.expression, 2) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitGotoStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitGotoStmt(this);

        public GotoStmt Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoStmt(this.Kind(), gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public GotoStmt WithGotoKeyword(SyntaxToken gotoKeyword) => Update(gotoKeyword, this.CaseOrDefaultKeyword, this.Expression, this.SemicolonToken);
        public GotoStmt WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword) => Update(this.GotoKeyword, caseOrDefaultKeyword, this.Expression, this.SemicolonToken);
        public GotoStmt WithExpression(ExprSyntax? expression) => Update(this.GotoKeyword, this.CaseOrDefaultKeyword, expression, this.SemicolonToken);
        public GotoStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.GotoKeyword, this.CaseOrDefaultKeyword, this.Expression, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BreakStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BreakStmt : StmtSyntax
    {
        internal BreakStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken BreakKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.BreakStmt)this.Green).breakKeyword, Position, 0);

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BreakStmt)this.Green).semicolonToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitBreakStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBreakStmt(this);

        public BreakStmt Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
            if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.BreakStmt(breakKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BreakStmt WithBreakKeyword(SyntaxToken breakKeyword) => Update(breakKeyword, this.SemicolonToken);
        public BreakStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.BreakKeyword, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ContinueStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ContinueStmt : StmtSyntax
    {
        internal ContinueStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ContinueKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ContinueStmt)this.Green).continueKeyword, Position, 0);

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ContinueStmt)this.Green).semicolonToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitContinueStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitContinueStmt(this);

        public ContinueStmt Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
            if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ContinueStmt(continueKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ContinueStmt WithContinueKeyword(SyntaxToken continueKeyword) => Update(continueKeyword, this.SemicolonToken);
        public ContinueStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ContinueKeyword, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ReturnStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ReturnStmt : StmtSyntax
    {
        private ExprSyntax? expression;

        internal ReturnStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ReturnKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ReturnStmt)this.Green).returnKeyword, Position, 0);

        public ExprSyntax? Expression => GetRed(ref this.expression, 1);

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ReturnStmt)this.Green).semicolonToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitReturnStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitReturnStmt(this);

        public ReturnStmt Update(SyntaxToken returnKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            if (returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ReturnStmt(returnKeyword, expression, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ReturnStmt WithReturnKeyword(SyntaxToken returnKeyword) => Update(returnKeyword, this.Expression, this.SemicolonToken);
        public ReturnStmt WithExpression(ExprSyntax? expression) => Update(this.ReturnKeyword, expression, this.SemicolonToken);
        public ReturnStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ReturnKeyword, this.Expression, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ThrowStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ThrowStmt : StmtSyntax
    {
        private ExprSyntax? expression;

        internal ThrowStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ThrowKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ThrowStmt)this.Green).throwKeyword, Position, 0);

        public ExprSyntax? Expression => GetRed(ref this.expression, 1);

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ThrowStmt)this.Green).semicolonToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitThrowStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitThrowStmt(this);

        public ThrowStmt Update(SyntaxToken throwKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ThrowStmt(throwKeyword, expression, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ThrowStmt WithThrowKeyword(SyntaxToken throwKeyword) => Update(throwKeyword, this.Expression, this.SemicolonToken);
        public ThrowStmt WithExpression(ExprSyntax? expression) => Update(this.ThrowKeyword, expression, this.SemicolonToken);
        public ThrowStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ThrowKeyword, this.Expression, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.YieldReturnStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.YieldBreakStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class YieldStmt : StmtSyntax
    {
        private ExprSyntax? expression;

        internal YieldStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken YieldKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.YieldStmt)this.Green).yieldKeyword, Position, 0);

        public SyntaxToken ReturnOrBreakKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.YieldStmt)this.Green).returnOrBreakKeyword, GetChildPosition(1), GetChildIndex(1));

        public ExprSyntax? Expression => GetRed(ref this.expression, 2);

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.YieldStmt)this.Green).semicolonToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.expression, 2) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.expression : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitYieldStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitYieldStmt(this);

        public YieldStmt Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExprSyntax? expression, SyntaxToken semicolonToken)
        {
            if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.YieldStmt(this.Kind(), yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public YieldStmt WithYieldKeyword(SyntaxToken yieldKeyword) => Update(yieldKeyword, this.ReturnOrBreakKeyword, this.Expression, this.SemicolonToken);
        public YieldStmt WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword) => Update(this.YieldKeyword, returnOrBreakKeyword, this.Expression, this.SemicolonToken);
        public YieldStmt WithExpression(ExprSyntax? expression) => Update(this.YieldKeyword, this.ReturnOrBreakKeyword, expression, this.SemicolonToken);
        public YieldStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.YieldKeyword, this.ReturnOrBreakKeyword, this.Expression, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhileStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhileStmt : StmtSyntax
    {
        private ExprSyntax? condition;
        private StmtSyntax? statement;

        internal WhileStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken WhileKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStmt)this.Green).whileKeyword, Position, 0);

        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStmt)this.Green).openParenToken, GetChildPosition(1), GetChildIndex(1));

        public ExprSyntax Condition => GetRed(ref this.condition, 2)!;

        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStmt)this.Green).closeParenToken, GetChildPosition(3), GetChildIndex(3));

        public StmtSyntax Statement => GetRed(ref this.statement, 4)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                2 => GetRed(ref this.condition, 2)!,
                4 => GetRed(ref this.statement, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                2 => this.condition,
                4 => this.statement,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitWhileStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhileStmt(this);

        public WhileStmt Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement)
        {
            if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.WhileStmt(whileKeyword, openParenToken, condition, closeParenToken, statement);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhileStmt WithWhileKeyword(SyntaxToken whileKeyword) => Update(whileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement);
        public WhileStmt WithOpenParenToken(SyntaxToken openParenToken) => Update(this.WhileKeyword, openParenToken, this.Condition, this.CloseParenToken, this.Statement);
        public WhileStmt WithCondition(ExprSyntax condition) => Update(this.WhileKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.Statement);
        public WhileStmt WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.WhileKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.Statement);
        public WhileStmt WithStatement(StmtSyntax statement) => Update(this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, statement);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DoStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DoStmt : StmtSyntax
    {
        private StmtSyntax? statement;
        private ExprSyntax? condition;

        internal DoStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStmt)this.Green).doKeyword, Position, 0);

        public StmtSyntax Statement => GetRed(ref this.statement, 1)!;

        public SyntaxToken WhileKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStmt)this.Green).whileKeyword, GetChildPosition(2), GetChildIndex(2));

        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStmt)this.Green).openParenToken, GetChildPosition(3), GetChildIndex(3));

        public ExprSyntax Condition => GetRed(ref this.condition, 4)!;

        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStmt)this.Green).closeParenToken, GetChildPosition(5), GetChildIndex(5));

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStmt)this.Green).semicolonToken, GetChildPosition(6), GetChildIndex(6));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.statement, 1)!,
                4 => GetRed(ref this.condition, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.statement,
                4 => this.condition,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitDoStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDoStmt(this);

        public DoStmt Update(SyntaxToken doKeyword, StmtSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        {
            if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.DoStmt(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DoStmt WithDoKeyword(SyntaxToken doKeyword) => Update(doKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
        public DoStmt WithStatement(StmtSyntax statement) => Update(this.DoKeyword, statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
        public DoStmt WithWhileKeyword(SyntaxToken whileKeyword) => Update(this.DoKeyword, this.Statement, whileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
        public DoStmt WithOpenParenToken(SyntaxToken openParenToken) => Update(this.DoKeyword, this.Statement, this.WhileKeyword, openParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
        public DoStmt WithCondition(ExprSyntax condition) => Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.SemicolonToken);
        public DoStmt WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.SemicolonToken);
        public DoStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, semicolonToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ForStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ForStmt : StmtSyntax
    {
        private VariableDecl? declaration;
        private SyntaxNode? initializers;
        private ExprSyntax? condition;
        private SyntaxNode? incrementors;
        private StmtSyntax? statement;

        internal ForStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStmt)this.Green).forKeyword, Position, 0);

        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStmt)this.Green).openParenToken, GetChildPosition(1), GetChildIndex(1));

        public VariableDecl? Declaration => GetRed(ref this.declaration, 2);

        public SeparatedSyntaxList<ExprSyntax> Initializers
        {
            get
            {
                var red = GetRed(ref this.initializers, 3);
                return red != null ? new SeparatedSyntaxList<ExprSyntax>(red, GetChildIndex(3)) : default;
            }
        }

        public SyntaxToken FirstSemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStmt)this.Green).firstSemicolonToken, GetChildPosition(4), GetChildIndex(4));

        public ExprSyntax? Condition => GetRed(ref this.condition, 5);

        public SyntaxToken SecondSemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStmt)this.Green).secondSemicolonToken, GetChildPosition(6), GetChildIndex(6));

        public SeparatedSyntaxList<ExprSyntax> Incrementors
        {
            get
            {
                var red = GetRed(ref this.incrementors, 7);
                return red != null ? new SeparatedSyntaxList<ExprSyntax>(red, GetChildIndex(7)) : default;
            }
        }

        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ForStmt)this.Green).closeParenToken, GetChildPosition(8), GetChildIndex(8));

        public StmtSyntax Statement => GetRed(ref this.statement, 9)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                2 => GetRed(ref this.declaration, 2),
                3 => GetRed(ref this.initializers, 3)!,
                5 => GetRed(ref this.condition, 5),
                7 => GetRed(ref this.incrementors, 7)!,
                9 => GetRed(ref this.statement, 9)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                2 => this.declaration,
                3 => this.initializers,
                5 => this.condition,
                7 => this.incrementors,
                9 => this.statement,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitForStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitForStmt(this);

        public ForStmt Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDecl? declaration, SeparatedSyntaxList<ExprSyntax> initializers, SyntaxToken firstSemicolonToken, ExprSyntax? condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExprSyntax> incrementors, SyntaxToken closeParenToken, StmtSyntax statement)
        {
            if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ForStmt(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ForStmt WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithOpenParenToken(SyntaxToken openParenToken) => Update(this.ForKeyword, openParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithDeclaration(VariableDecl? declaration) => Update(this.ForKeyword, this.OpenParenToken, declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithInitializers(SeparatedSyntaxList<ExprSyntax> initializers) => Update(this.ForKeyword, this.OpenParenToken, this.Declaration, initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithFirstSemicolonToken(SyntaxToken firstSemicolonToken) => Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, firstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithCondition(ExprSyntax? condition) => Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithSecondSemicolonToken(SyntaxToken secondSemicolonToken) => Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, secondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithIncrementors(SeparatedSyntaxList<ExprSyntax> incrementors) => Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, incrementors, this.CloseParenToken, this.Statement);
        public ForStmt WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, closeParenToken, this.Statement);
        public ForStmt WithStatement(StmtSyntax statement) => Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, statement);

        public ForStmt AddInitializers(params ExprSyntax[] items) => WithInitializers(this.Initializers.AddRange(items));
        public ForStmt AddIncrementors(params ExprSyntax[] items) => WithIncrementors(this.Incrementors.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LocalDeclarationStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LocalDeclStmt : StmtSyntax
    {
        private SyntaxNode? attributeLists;
        private VariableDecl? declaration;

        internal LocalDeclStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxList<AttributeListSyntax> AttributeLists => new SyntaxList<AttributeListSyntax>(GetRed(ref this.attributeLists, 0));

        /// <summary>Gets the modifier list.</summary>
        public SyntaxTokenList Modifiers
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public VariableDecl Declaration => GetRed(ref this.declaration, 2)!;

        public SyntaxToken SemicolonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.LocalDeclStmt)this.Green).semicolonToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.attributeLists)!,
                2 => GetRed(ref this.declaration, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                2 => this.declaration,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitLocalDeclStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLocalDeclStmt(this);

        public LocalDeclStmt Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDecl declaration, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalDeclStmt(attributeLists, modifiers, declaration, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LocalDeclStmt WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) => Update(attributeLists, this.Modifiers, this.Declaration, this.SemicolonToken);
        public LocalDeclStmt WithModifiers(SyntaxTokenList modifiers) => Update(this.AttributeLists, modifiers, this.Declaration, this.SemicolonToken);
        public LocalDeclStmt WithDeclaration(VariableDecl declaration) => Update(this.AttributeLists, this.Modifiers, declaration, this.SemicolonToken);
        public LocalDeclStmt WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.AttributeLists, this.Modifiers, this.Declaration, semicolonToken);

        public LocalDeclStmt AddAttributeLists(params AttributeListSyntax[] items) => WithAttributeLists(this.AttributeLists.AddRange(items));
        public LocalDeclStmt AddModifiers(params SyntaxToken[] items) => WithModifiers(this.Modifiers.AddRange(items));
        public LocalDeclStmt AddDeclarationVariables(params VariableInit[] items) => WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.AddRange(items)));
    }

    /// <summary>
    /// Represents an if statement syntax.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IfStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IfStmt : StmtSyntax
    {
        private ExprSyntax? condition;
        private StmtSyntax? statement;
        private ElseClauseSyntax? @else;

        internal IfStmt(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents the if keyword.
        /// </summary>
        public SyntaxToken IfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStmt)this.Green).ifKeyword, Position, 0);

        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition
        /// expression.
        /// </summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStmt)this.Green).openParenToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>
        /// Gets an ExpressionSyntax that represents the condition of the if statement.
        /// </summary>
        public ExprSyntax Condition => GetRed(ref this.condition, 2)!;

        /// <summary>
        /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition
        /// expression.
        /// </summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStmt)this.Green).closeParenToken, GetChildPosition(3), GetChildIndex(3));

        /// <summary>
        /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
        /// </summary>
        public StmtSyntax Statement => GetRed(ref this.statement, 4)!;

        /// <summary>
        /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if
        /// such statement exists.
        /// </summary>
        public ElseClauseSyntax? Else => GetRed(ref this.@else, 5);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                2 => GetRed(ref this.condition, 2)!,
                4 => GetRed(ref this.statement, 4)!,
                5 => GetRed(ref this.@else, 5),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                2 => this.condition,
                4 => this.statement,
                5 => this.@else,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIfStmt(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIfStmt(this);

        public IfStmt Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExprSyntax condition, SyntaxToken closeParenToken, StmtSyntax statement, ElseClauseSyntax? @else)
        {
            if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
            {
                var newNode = SyntaxFactory.IfStmt(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IfStmt WithIfKeyword(SyntaxToken ifKeyword) => Update(ifKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement, this.Else);
        public IfStmt WithOpenParenToken(SyntaxToken openParenToken) => Update(this.IfKeyword, openParenToken, this.Condition, this.CloseParenToken, this.Statement, this.Else);
        public IfStmt WithCondition(ExprSyntax condition) => Update(this.IfKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.Statement, this.Else);
        public IfStmt WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.IfKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.Statement, this.Else);
        public IfStmt WithStatement(StmtSyntax statement) => Update(this.IfKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, statement, this.Else);
        public IfStmt WithElse(ElseClauseSyntax? @else) => Update(this.IfKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement, @else);
    }

    /// <summary>Represents an else statement syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseClauseSyntax : AquilaSyntaxNode
    {
        private StmtSyntax? statement;

        internal ElseClauseSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets a syntax token
        /// </summary>
        public SyntaxToken ElseKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseClauseSyntax)this.Green).elseKeyword, Position, 0);

        public StmtSyntax Statement => GetRed(ref this.statement, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.statement, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.statement : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StmtSyntax statement)
        {
            if (elseKeyword != this.ElseKeyword || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword) => Update(elseKeyword, this.Statement);
        public ElseClauseSyntax WithStatement(StmtSyntax statement) => Update(this.ElseKeyword, statement);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SingleLineDocumentationCommentTrivia"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiLineDocumentationCommentTrivia"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
    {
        private SyntaxNode? content;

        internal DocumentationCommentTriviaSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxList<XmlNodeSyntax> Content => new SyntaxList<XmlNodeSyntax>(GetRed(ref this.content, 0));

        public SyntaxToken EndOfComment => new SyntaxToken(this, ((Syntax.InternalSyntax.DocumentationCommentTriviaSyntax)this.Green).endOfComment, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.content)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.content : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitDocumentationCommentTrivia(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDocumentationCommentTrivia(this);

        public DocumentationCommentTriviaSyntax Update(SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
        {
            if (content != this.Content || endOfComment != this.EndOfComment)
            {
                var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind(), content, endOfComment);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DocumentationCommentTriviaSyntax WithContent(SyntaxList<XmlNodeSyntax> content) => Update(content, this.EndOfComment);
        public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment) => Update(this.Content, endOfComment);

        public DocumentationCommentTriviaSyntax AddContent(params XmlNodeSyntax[] items) => WithContent(this.Content.AddRange(items));
    }

    /// <summary>
    /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment
    /// tag).
    /// For example, the M in &lt;see cref="M" /&gt;.
    /// </summary>
    public abstract partial class CrefSyntax : AquilaSyntaxNode
    {
        internal CrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>
    /// A symbol reference that definitely refers to a type.
    /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeCref"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeCrefSyntax : CrefSyntax
    {
        private TypeEx? type;

        internal TypeCrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public TypeEx Type => GetRedAtZero(ref this.type)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.type)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.type : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitTypeCref(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeCref(this);

        public TypeCrefSyntax Update(TypeEx type)
        {
            if (type != this.Type)
            {
                var newNode = SyntaxFactory.TypeCref(type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeCrefSyntax WithType(TypeEx type) => Update(type);
    }

    /// <summary>
    /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
    /// For example, cref="System.String.ToString()".
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.QualifiedCref"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class QualifiedCrefSyntax : CrefSyntax
    {
        private TypeEx? container;
        private MemberCrefSyntax? member;

        internal QualifiedCrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public TypeEx Container => GetRedAtZero(ref this.container)!;

        public SyntaxToken DotToken => new SyntaxToken(this, ((Syntax.InternalSyntax.QualifiedCrefSyntax)this.Green).dotToken, GetChildPosition(1), GetChildIndex(1));

        public MemberCrefSyntax Member => GetRed(ref this.member, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.container)!,
                2 => GetRed(ref this.member, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.container,
                2 => this.member,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitQualifiedCref(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitQualifiedCref(this);

        public QualifiedCrefSyntax Update(TypeEx container, SyntaxToken dotToken, MemberCrefSyntax member)
        {
            if (container != this.Container || dotToken != this.DotToken || member != this.Member)
            {
                var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public QualifiedCrefSyntax WithContainer(TypeEx container) => Update(container, this.DotToken, this.Member);
        public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken) => Update(this.Container, dotToken, this.Member);
        public QualifiedCrefSyntax WithMember(MemberCrefSyntax member) => Update(this.Container, this.DotToken, member);
    }

    /// <summary>
    /// The unqualified part of a CrefSyntax.
    /// For example, "ToString()" in "object.ToString()".
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    public abstract partial class MemberCrefSyntax : CrefSyntax
    {
        internal MemberCrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified
    /// name,
    /// with an optional type parameter list) and an optional parameter list.
    /// For example, "M", "M&lt;T&gt;" or "M(int)".
    /// Also, "A::B()" or "string()".
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NameMemberCref"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
    {
        private TypeEx? name;
        private CrefParameterListSyntax? parameters;

        internal NameMemberCrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public TypeEx Name => GetRedAtZero(ref this.name)!;

        public CrefParameterListSyntax? Parameters => GetRed(ref this.parameters, 1);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.name)!,
                1 => GetRed(ref this.parameters, 1),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.parameters,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitNameMemberCref(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNameMemberCref(this);

        public NameMemberCrefSyntax Update(TypeEx name, CrefParameterListSyntax? parameters)
        {
            if (name != this.Name || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.NameMemberCref(name, parameters);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NameMemberCrefSyntax WithName(TypeEx name) => Update(name, this.Parameters);
        public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax? parameters) => Update(this.Name, parameters);

        public NameMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
        {
            var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
            return WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
    /// For example, "this" or "this[int]".
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IndexerMemberCref"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
    {
        private CrefBracketedParameterListSyntax? parameters;

        internal IndexerMemberCrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ThisKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IndexerMemberCrefSyntax)this.Green).thisKeyword, Position, 0);

        public CrefBracketedParameterListSyntax? Parameters => GetRed(ref this.parameters, 1);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitIndexerMemberCref(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIndexerMemberCref(this);

        public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
        {
            if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword) => Update(thisKeyword, this.Parameters);
        public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax? parameters) => Update(this.ThisKeyword, parameters);

        public IndexerMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
        {
            var parameters = this.Parameters ?? SyntaxFactory.CrefBracketedParameterList();
            return WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
    /// For example, "operator +" or "operator -[int]".
    /// NOTE: the operator must be overloadable.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.OperatorMemberCref"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
    {
        private CrefParameterListSyntax? parameters;

        internal OperatorMemberCrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken OperatorKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.OperatorMemberCrefSyntax)this.Green).operatorKeyword, Position, 0);

        /// <summary>Gets the operator token.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.OperatorMemberCrefSyntax)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        public CrefParameterListSyntax? Parameters => GetRed(ref this.parameters, 2);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.parameters, 2) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.parameters : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitOperatorMemberCref(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitOperatorMemberCref(this);

        public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
        {
            if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword) => Update(operatorKeyword, this.OperatorToken, this.Parameters);
        public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(this.OperatorKeyword, operatorToken, this.Parameters);
        public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax? parameters) => Update(this.OperatorKeyword, this.OperatorToken, parameters);

        public OperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
        {
            var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
            return WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination
    /// type, and an optional parameter list.
    /// For example, "implicit operator int" or "explicit operator MyType(int)".
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ConversionOperatorMemberCref"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
    {
        private TypeEx? type;
        private CrefParameterListSyntax? parameters;

        internal ConversionOperatorMemberCrefSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken ImplicitOrExplicitKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax)this.Green).implicitOrExplicitKeyword, Position, 0);

        public SyntaxToken OperatorKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax)this.Green).operatorKeyword, GetChildPosition(1), GetChildIndex(1));

        public TypeEx Type => GetRed(ref this.type, 2)!;

        public CrefParameterListSyntax? Parameters => GetRed(ref this.parameters, 3);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                2 => GetRed(ref this.type, 2)!,
                3 => GetRed(ref this.parameters, 3),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                2 => this.type,
                3 => this.parameters,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitConversionOperatorMemberCref(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitConversionOperatorMemberCref(this);

        public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeEx type, CrefParameterListSyntax? parameters)
        {
            if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword) => Update(implicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.Parameters);
        public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword) => Update(this.ImplicitOrExplicitKeyword, operatorKeyword, this.Type, this.Parameters);
        public ConversionOperatorMemberCrefSyntax WithType(TypeEx type) => Update(this.ImplicitOrExplicitKeyword, this.OperatorKeyword, type, this.Parameters);
        public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax? parameters) => Update(this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, parameters);

        public ConversionOperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
        {
            var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
            return WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
        }
    }

    /// <summary>
    /// A list of cref parameters with surrounding punctuation.
    /// Unlike regular parameters, cref parameters do not have names.
    /// </summary>
    public abstract partial class BaseCrefParameterListSyntax : AquilaSyntaxNode
    {
        internal BaseCrefParameterListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the parameter list.</summary>
        public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
        public BaseCrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters) => WithParametersCore(parameters);
        internal abstract BaseCrefParameterListSyntax WithParametersCore(SeparatedSyntaxList<CrefParameterSyntax> parameters);

        public BaseCrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items) => AddParametersCore(items);
        internal abstract BaseCrefParameterListSyntax AddParametersCore(params CrefParameterSyntax[] items);
    }

    /// <summary>
    /// A parenthesized list of cref parameters.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.CrefParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
    {
        private SyntaxNode? parameters;

        internal CrefParameterListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CrefParameterListSyntax)this.Green).openParenToken, Position, 0);

        public override SeparatedSyntaxList<CrefParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<CrefParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CrefParameterListSyntax)this.Green).closeParenToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCrefParameterList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitCrefParameterList(this);

        public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken) => Update(openParenToken, this.Parameters, this.CloseParenToken);
        internal override BaseCrefParameterListSyntax WithParametersCore(SeparatedSyntaxList<CrefParameterSyntax> parameters) => WithParameters(parameters);
        public new CrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters) => Update(this.OpenParenToken, parameters, this.CloseParenToken);
        public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken) => Update(this.OpenParenToken, this.Parameters, closeParenToken);

        internal override BaseCrefParameterListSyntax AddParametersCore(params CrefParameterSyntax[] items) => AddParameters(items);
        public new CrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>
    /// A bracketed list of cref parameters.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.CrefBracketedParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
    {
        private SyntaxNode? parameters;

        internal CrefBracketedParameterListSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CrefBracketedParameterListSyntax)this.Green).openBracketToken, Position, 0);

        public override SeparatedSyntaxList<CrefParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<CrefParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CrefBracketedParameterListSyntax)this.Green).closeBracketToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCrefBracketedParameterList(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitCrefBracketedParameterList(this);

        public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.Parameters, this.CloseBracketToken);
        internal override BaseCrefParameterListSyntax WithParametersCore(SeparatedSyntaxList<CrefParameterSyntax> parameters) => WithParameters(parameters);
        public new CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters) => Update(this.OpenBracketToken, parameters, this.CloseBracketToken);
        public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.Parameters, closeBracketToken);

        internal override BaseCrefParameterListSyntax AddParametersCore(params CrefParameterSyntax[] items) => AddParameters(items);
        public new CrefBracketedParameterListSyntax AddParameters(params CrefParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>
    /// An element of a BaseCrefParameterListSyntax.
    /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
    /// there is no name and there are no attributes or other modifiers.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.CrefParameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class CrefParameterSyntax : AquilaSyntaxNode
    {
        private TypeEx? type;

        internal CrefParameterSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken RefKindKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.CrefParameterSyntax)this.Green).refKindKeyword;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        public TypeEx Type => GetRed(ref this.type, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.type, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.type : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitCrefParameter(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitCrefParameter(this);

        public CrefParameterSyntax Update(SyntaxToken refKindKeyword, TypeEx type)
        {
            if (refKindKeyword != this.RefKindKeyword || type != this.Type)
            {
                var newNode = SyntaxFactory.CrefParameter(refKindKeyword, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public CrefParameterSyntax WithRefKindKeyword(SyntaxToken refKindKeyword) => Update(refKindKeyword, this.Type);
        public CrefParameterSyntax WithType(TypeEx type) => Update(this.RefKindKeyword, type);
    }

    public abstract partial class XmlNodeSyntax : AquilaSyntaxNode
    {
        internal XmlNodeSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlElement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlElementSyntax : XmlNodeSyntax
    {
        private XmlElementStartTagSyntax? startTag;
        private SyntaxNode? content;
        private XmlElementEndTagSyntax? endTag;

        internal XmlElementSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public XmlElementStartTagSyntax StartTag => GetRedAtZero(ref this.startTag)!;

        public SyntaxList<XmlNodeSyntax> Content => new SyntaxList<XmlNodeSyntax>(GetRed(ref this.content, 1));

        public XmlElementEndTagSyntax EndTag => GetRed(ref this.endTag, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.startTag)!,
                1 => GetRed(ref this.content, 1)!,
                2 => GetRed(ref this.endTag, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.startTag,
                1 => this.content,
                2 => this.endTag,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlElement(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlElement(this);

        public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
        {
            if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
            {
                var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag) => Update(startTag, this.Content, this.EndTag);
        public XmlElementSyntax WithContent(SyntaxList<XmlNodeSyntax> content) => Update(this.StartTag, content, this.EndTag);
        public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag) => Update(this.StartTag, this.Content, endTag);

        public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items) => WithStartTag(this.StartTag.WithAttributes(this.StartTag.Attributes.AddRange(items)));
        public XmlElementSyntax AddContent(params XmlNodeSyntax[] items) => WithContent(this.Content.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlElementStartTag"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlElementStartTagSyntax : AquilaSyntaxNode
    {
        private XmlNameSyntax? name;
        private SyntaxNode? attributes;

        internal XmlElementStartTagSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken LessThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlElementStartTagSyntax)this.Green).lessThanToken, Position, 0);

        public XmlNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxList<XmlAttributeSyntax> Attributes => new SyntaxList<XmlAttributeSyntax>(GetRed(ref this.attributes, 2));

        public SyntaxToken GreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlElementStartTagSyntax)this.Green).greaterThanToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                2 => GetRed(ref this.attributes, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                2 => this.attributes,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlElementStartTag(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlElementStartTag(this);

        public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken) => Update(lessThanToken, this.Name, this.Attributes, this.GreaterThanToken);
        public XmlElementStartTagSyntax WithName(XmlNameSyntax name) => Update(this.LessThanToken, name, this.Attributes, this.GreaterThanToken);
        public XmlElementStartTagSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes) => Update(this.LessThanToken, this.Name, attributes, this.GreaterThanToken);
        public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) => Update(this.LessThanToken, this.Name, this.Attributes, greaterThanToken);

        public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items) => WithAttributes(this.Attributes.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlElementEndTag"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlElementEndTagSyntax : AquilaSyntaxNode
    {
        private XmlNameSyntax? name;

        internal XmlElementEndTagSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken LessThanSlashToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlElementEndTagSyntax)this.Green).lessThanSlashToken, Position, 0);

        public XmlNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxToken GreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlElementEndTagSyntax)this.Green).greaterThanToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.name, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.name : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlElementEndTag(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlElementEndTag(this);

        public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        {
            if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken) => Update(lessThanSlashToken, this.Name, this.GreaterThanToken);
        public XmlElementEndTagSyntax WithName(XmlNameSyntax name) => Update(this.LessThanSlashToken, name, this.GreaterThanToken);
        public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) => Update(this.LessThanSlashToken, this.Name, greaterThanToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlEmptyElement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
    {
        private XmlNameSyntax? name;
        private SyntaxNode? attributes;

        internal XmlEmptyElementSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken LessThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlEmptyElementSyntax)this.Green).lessThanToken, Position, 0);

        public XmlNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxList<XmlAttributeSyntax> Attributes => new SyntaxList<XmlAttributeSyntax>(GetRed(ref this.attributes, 2));

        public SyntaxToken SlashGreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlEmptyElementSyntax)this.Green).slashGreaterThanToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                2 => GetRed(ref this.attributes, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                2 => this.attributes,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlEmptyElement(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlEmptyElement(this);

        public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken) => Update(lessThanToken, this.Name, this.Attributes, this.SlashGreaterThanToken);
        public XmlEmptyElementSyntax WithName(XmlNameSyntax name) => Update(this.LessThanToken, name, this.Attributes, this.SlashGreaterThanToken);
        public XmlEmptyElementSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes) => Update(this.LessThanToken, this.Name, attributes, this.SlashGreaterThanToken);
        public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken) => Update(this.LessThanToken, this.Name, this.Attributes, slashGreaterThanToken);

        public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items) => WithAttributes(this.Attributes.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlNameSyntax : AquilaSyntaxNode
    {
        private XmlPrefixSyntax? prefix;

        internal XmlNameSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public XmlPrefixSyntax? Prefix => GetRedAtZero(ref this.prefix);

        public SyntaxToken LocalName => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlNameSyntax)this.Green).localName, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.prefix) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.prefix : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlName(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlName(this);

        public XmlNameSyntax Update(XmlPrefixSyntax? prefix, SyntaxToken localName)
        {
            if (prefix != this.Prefix || localName != this.LocalName)
            {
                var newNode = SyntaxFactory.XmlName(prefix, localName);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlNameSyntax WithPrefix(XmlPrefixSyntax? prefix) => Update(prefix, this.LocalName);
        public XmlNameSyntax WithLocalName(SyntaxToken localName) => Update(this.Prefix, localName);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlPrefix"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlPrefixSyntax : AquilaSyntaxNode
    {
        internal XmlPrefixSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken Prefix => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlPrefixSyntax)this.Green).prefix, Position, 0);

        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlPrefixSyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlPrefix(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlPrefix(this);

        public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
        {
            if (prefix != this.Prefix || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlPrefixSyntax WithPrefix(SyntaxToken prefix) => Update(prefix, this.ColonToken);
        public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken) => Update(this.Prefix, colonToken);
    }

    public abstract partial class XmlAttributeSyntax : AquilaSyntaxNode
    {
        internal XmlAttributeSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public abstract XmlNameSyntax Name { get; }
        public XmlAttributeSyntax WithName(XmlNameSyntax name) => WithNameCore(name);
        internal abstract XmlAttributeSyntax WithNameCore(XmlNameSyntax name);

        public abstract SyntaxToken EqualsToken { get; }
        public XmlAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) => WithEqualsTokenCore(equalsToken);
        internal abstract XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken);

        public abstract SyntaxToken StartQuoteToken { get; }
        public XmlAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) => WithStartQuoteTokenCore(startQuoteToken);
        internal abstract XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken);

        public abstract SyntaxToken EndQuoteToken { get; }
        public XmlAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) => WithEndQuoteTokenCore(endQuoteToken);
        internal abstract XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlTextAttribute"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
    {
        private XmlNameSyntax? name;

        internal XmlTextAttributeSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override XmlNameSyntax Name => GetRedAtZero(ref this.name)!;

        public override SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        public override SyntaxToken StartQuoteToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).startQuoteToken, GetChildPosition(2), GetChildIndex(2));

        public SyntaxTokenList TextTokens
        {
            get
            {
                var slot = this.Green.GetSlot(3);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        public override SyntaxToken EndQuoteToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).endQuoteToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.name)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.name : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlTextAttribute(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlTextAttribute(this);

        public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override XmlAttributeSyntax WithNameCore(XmlNameSyntax name) => WithName(name);
        public new XmlTextAttributeSyntax WithName(XmlNameSyntax name) => Update(name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken) => WithEqualsToken(equalsToken);
        public new XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Name, equalsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken) => WithStartQuoteToken(startQuoteToken);
        public new XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) => Update(this.Name, this.EqualsToken, startQuoteToken, this.TextTokens, this.EndQuoteToken);
        public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens) => Update(this.Name, this.EqualsToken, this.StartQuoteToken, textTokens, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken) => WithEndQuoteToken(endQuoteToken);
        public new XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) => Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, endQuoteToken);

        public XmlTextAttributeSyntax AddTextTokens(params SyntaxToken[] items) => WithTextTokens(this.TextTokens.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlCrefAttribute"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
    {
        private XmlNameSyntax? name;
        private CrefSyntax? cref;

        internal XmlCrefAttributeSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override XmlNameSyntax Name => GetRedAtZero(ref this.name)!;

        public override SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        public override SyntaxToken StartQuoteToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).startQuoteToken, GetChildPosition(2), GetChildIndex(2));

        public CrefSyntax Cref => GetRed(ref this.cref, 3)!;

        public override SyntaxToken EndQuoteToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).endQuoteToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.name)!,
                3 => GetRed(ref this.cref, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.name,
                3 => this.cref,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlCrefAttribute(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlCrefAttribute(this);

        public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override XmlAttributeSyntax WithNameCore(XmlNameSyntax name) => WithName(name);
        public new XmlCrefAttributeSyntax WithName(XmlNameSyntax name) => Update(name, this.EqualsToken, this.StartQuoteToken, this.Cref, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken) => WithEqualsToken(equalsToken);
        public new XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Name, equalsToken, this.StartQuoteToken, this.Cref, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken) => WithStartQuoteToken(startQuoteToken);
        public new XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) => Update(this.Name, this.EqualsToken, startQuoteToken, this.Cref, this.EndQuoteToken);
        public XmlCrefAttributeSyntax WithCref(CrefSyntax cref) => Update(this.Name, this.EqualsToken, this.StartQuoteToken, cref, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken) => WithEndQuoteToken(endQuoteToken);
        public new XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) => Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.Cref, endQuoteToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlNameAttribute"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
    {
        private XmlNameSyntax? name;
        private IdentifierEx? identifier;

        internal XmlNameAttributeSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public override XmlNameSyntax Name => GetRedAtZero(ref this.name)!;

        public override SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        public override SyntaxToken StartQuoteToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).startQuoteToken, GetChildPosition(2), GetChildIndex(2));

        public IdentifierEx Identifier => GetRed(ref this.identifier, 3)!;

        public override SyntaxToken EndQuoteToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).endQuoteToken, GetChildPosition(4), GetChildIndex(4));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.name)!,
                3 => GetRed(ref this.identifier, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.name,
                3 => this.identifier,
                _ => null,
            };

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlNameAttribute(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlNameAttribute(this);

        public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierEx identifier, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override XmlAttributeSyntax WithNameCore(XmlNameSyntax name) => WithName(name);
        public new XmlNameAttributeSyntax WithName(XmlNameSyntax name) => Update(name, this.EqualsToken, this.StartQuoteToken, this.Identifier, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken) => WithEqualsToken(equalsToken);
        public new XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Name, equalsToken, this.StartQuoteToken, this.Identifier, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken) => WithStartQuoteToken(startQuoteToken);
        public new XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) => Update(this.Name, this.EqualsToken, startQuoteToken, this.Identifier, this.EndQuoteToken);
        public XmlNameAttributeSyntax WithIdentifier(IdentifierEx identifier) => Update(this.Name, this.EqualsToken, this.StartQuoteToken, identifier, this.EndQuoteToken);
        internal override XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken) => WithEndQuoteToken(endQuoteToken);
        public new XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) => Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.Identifier, endQuoteToken);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlText"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlTextSyntax : XmlNodeSyntax
    {
        internal XmlTextSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxTokenList TextTokens
        {
            get
            {
                var slot = this.Green.GetSlot(0);
                return slot != null ? new SyntaxTokenList(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlText(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlText(this);

        public XmlTextSyntax Update(SyntaxTokenList textTokens)
        {
            if (textTokens != this.TextTokens)
            {
                var newNode = SyntaxFactory.XmlText(textTokens);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens) => Update(textTokens);

        public XmlTextSyntax AddTextTokens(params SyntaxToken[] items) => WithTextTokens(this.TextTokens.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlCDataSection"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
    {
        internal XmlCDataSectionSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken StartCDataToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlCDataSectionSyntax)this.Green).startCDataToken, Position, 0);

        public SyntaxTokenList TextTokens
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken EndCDataToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlCDataSectionSyntax)this.Green).endCDataToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlCDataSection(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlCDataSection(this);

        public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
        {
            if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
            {
                var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken) => Update(startCDataToken, this.TextTokens, this.EndCDataToken);
        public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens) => Update(this.StartCDataToken, textTokens, this.EndCDataToken);
        public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken) => Update(this.StartCDataToken, this.TextTokens, endCDataToken);

        public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items) => WithTextTokens(this.TextTokens.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlProcessingInstruction"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
    {
        private XmlNameSyntax? name;

        internal XmlProcessingInstructionSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken StartProcessingInstructionToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlProcessingInstructionSyntax)this.Green).startProcessingInstructionToken, Position, 0);

        public XmlNameSyntax Name => GetRed(ref this.name, 1)!;

        public SyntaxTokenList TextTokens
        {
            get
            {
                var slot = this.Green.GetSlot(2);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        public SyntaxToken EndProcessingInstructionToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlProcessingInstructionSyntax)this.Green).endProcessingInstructionToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.name, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.name : null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlProcessingInstruction(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlProcessingInstruction(this);

        public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)
        {
            if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
            {
                var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken) => Update(startProcessingInstructionToken, this.Name, this.TextTokens, this.EndProcessingInstructionToken);
        public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name) => Update(this.StartProcessingInstructionToken, name, this.TextTokens, this.EndProcessingInstructionToken);
        public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens) => Update(this.StartProcessingInstructionToken, this.Name, textTokens, this.EndProcessingInstructionToken);
        public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken) => Update(this.StartProcessingInstructionToken, this.Name, this.TextTokens, endProcessingInstructionToken);

        public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items) => WithTextTokens(this.TextTokens.AddRange(items));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.XmlComment"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class XmlCommentSyntax : XmlNodeSyntax
    {
        internal XmlCommentSyntax(InternalSyntax.AquilaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxToken LessThanExclamationMinusMinusToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlCommentSyntax)this.Green).lessThanExclamationMinusMinusToken, Position, 0);

        public SyntaxTokenList TextTokens
        {
            get
            {
                var slot = this.Green.GetSlot(1);
                return slot != null ? new SyntaxTokenList(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public SyntaxToken MinusMinusGreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.XmlCommentSyntax)this.Green).minusMinusGreaterThanToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(AquilaSyntaxVisitor visitor) => visitor.VisitXmlComment(this);
        public override TResult? Accept<TResult>(AquilaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitXmlComment(this);

        public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
        {
            if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken) => Update(lessThanExclamationMinusMinusToken, this.TextTokens, this.MinusMinusGreaterThanToken);
        public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens) => Update(this.LessThanExclamationMinusMinusToken, textTokens, this.MinusMinusGreaterThanToken);
        public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken) => Update(this.LessThanExclamationMinusMinusToken, this.TextTokens, minusMinusGreaterThanToken);

        public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items) => WithTextTokens(this.TextTokens.AddRange(items));
    }
}
