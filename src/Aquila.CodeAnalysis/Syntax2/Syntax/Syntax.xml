<?xml version="1.0" encoding="utf-8"?>
<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->

<!-- 
 To re-generate source from this file, run eng/generate-compiler-code.cmd
-->

<Tree Root="SyntaxNode">
    <PredefinedNode Name="CSharpSyntaxNode" Base="SyntaxNode"/>
    <PredefinedNode Name="SyntaxToken" Base="CSharpSyntaxNode"/>
    <PredefinedNode Name="StructuredTriviaSyntax" Base="CSharpSyntaxNode"/>

    <AbstractNode Name="ExprSyntax" Base="CSharpSyntaxNode">
    </AbstractNode>
    <AbstractNode Name="StmtSyntax" Base="CSharpSyntaxNode">
    </AbstractNode>

    <Node Name="CompilationUnitSyntax" Base="CSharpSyntaxNode">
        <Kind Name="CompilationUnit"/>
        <Field Name="Imports" Type="SyntaxList&lt;ImportDeclBase&gt;"/>
        <Field Name="Methods" Type="SyntaxList&lt;MethodDecl&gt;"/>
        <Field Name="Extends" Type="SyntaxList&lt;ExtendDecl&gt;"/>
        <Field Name="Components" Type="SyntaxList&lt;ComponentDecl&gt;"/>
        <Field Name="EndOfFileToken" Type="SyntaxToken">
            <Kind Name="EndOfFileToken"/>
        </Field>
    </Node>

    <AbstractNode Name="ImportDeclBase" Base="CSharpSyntaxNode"/>
    <Node Name="ImportDecl" Base="ImportDeclBase">
        <Kind Name="ImportDecl"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="SemicolonToken" Type="SyntaxToken">
            <Kind Name="SemicolonToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the semicolon token.</summary>
            </PropertyComment>
        </Field>
    </Node>

    <AbstractNode Name="MemberDecl" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Member declaration syntax.</summary>
        </TypeComment>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;">
            <PropertyComment>
                <summary>Gets the attribute declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;">
            <PropertyComment>
                <summary>Gets the modifier list.</summary>
            </PropertyComment>
        </Field>
    </AbstractNode>

    <Node Name="MethodDecl" Base="MemberDecl">
        <Kind Name="MethodDecl"/>

        <TypeComment>
            <summary>Base type for method declaration syntax.</summary>
        </TypeComment>

        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="ReturnType" Type="TypeEx">
            <PropertyComment>
                <summary>Gets the return type syntax.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="ParameterList" Type="ParameterListSyntax">
            <PropertyComment>
                <summary>Gets the parameter list.</summary>
            </PropertyComment>
        </Field>
        <Choice>
            <Field Name="Body" Type="BlockStmt"/>
        </Choice>
    </Node>

    <Node Name="ExtendDecl" Base="CSharpSyntaxNode">
        <Kind Name="ExtendDecl"/>
        <Field Name="ExtendKeyword" Type="SyntaxToken">
            <Kind Name="ExtendKeyword"/>
        </Field>
        <Field Name="Name" Type="NameEx"/>
        <Field Name="Methods" Type="SyntaxList&lt;MethodDecl&gt;"/>
    </Node>
    <Node Name="ComponentDecl" Base="CSharpSyntaxNode">
        <Kind Name="ComponentDecl"/>
        <Field Name="ComponentKeyword" Type="SyntaxToken">
            <Kind Name="ComponentKeyword"/>
        </Field>
        <Field Name="Name" Type="NameEx"/>
        <Field Name="Extends" Type="SyntaxList&lt;ExtendDecl&gt;"/>
    </Node>

    <!--region Attributes-->
    <Node Name="AttributeListSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </TypeComment>
        <Kind Name="AttributeList"/>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <Kind Name="OpenBracketToken"/>
            <PropertyComment>
                <summary>Gets the open bracket token.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Attributes" Type="SeparatedSyntaxList&lt;AttributeSyntax&gt;" MinCount="1">
            <PropertyComment>
                <summary>Gets the attribute declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <Kind Name="CloseBracketToken"/>
            <PropertyComment>
                <summary>Gets the close bracket token.</summary>
            </PropertyComment>
        </Field>
    </Node>
    <Node Name="AttributeSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Attribute syntax.</summary>
        </TypeComment>
        <Kind Name="Attribute"/>
        <Field Name="Name" Type="NameEx">
            <PropertyComment>
                <summary>Gets the name.</summary>
            </PropertyComment>
        </Field>
        <Field Name="ArgumentList" Type="AttributeArgumentListSyntax" Optional="true"/>
    </Node>
    <Node Name="AttributeArgumentListSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Attribute argument list syntax.</summary>
        </TypeComment>
        <Kind Name="AttributeArgumentList"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the open paren token.</summary>
            </PropertyComment>
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Arguments" Type="SeparatedSyntaxList&lt;AttributeArgumentSyntax&gt;">
            <PropertyComment>
                <summary>Gets the arguments syntax list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the close paren token.</summary>
            </PropertyComment>
            <Kind Name="CloseParenToken"/>
        </Field>
    </Node>
    <Node Name="AttributeArgumentSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Attribute argument syntax.</summary>
        </TypeComment>
        <Kind Name="AttributeArgument"/>
        <Choice>
            <Field Name="NameEquals" Type="NameEqualsSyntax" Optional="true"/>
            <!--            <Field Name="NameColon" Type="NameColonSyntax" Optional="true"/>-->
        </Choice>
        <Field Name="Expression" Type="ExprSyntax">
            <PropertyComment>
                <summary>Gets the expression.</summary>
            </PropertyComment>
        </Field>
    </Node>
    <Node Name="NameEqualsSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Class representing an identifier name followed by an equals token.</summary>
        </TypeComment>
        <Kind Name="NameEquals"/>
        <Field Name="Name" Type="IdentifierEx">
            <PropertyComment>
                <summary>Gets the identifier name.</summary>
            </PropertyComment>
            <Kind Name="IdentifierName"/>
        </Field>
        <Field Name="EqualsToken" Type="SyntaxToken">
            <Kind Name="EqualsToken"/>
        </Field>
    </Node>
    <!--endregion Attributes-->

    <!--region Expressions-->
    <Node Name="BinaryEx" Base="ExprSyntax">
        <Kind Name="AddExpression"/>
        <Kind Name="SubtractExpression"/>
        <Kind Name="MultiplyExpression"/>
        <Kind Name="DivideExpression"/>
        <Kind Name="ModuloExpression"/>
        <Kind Name="LeftShiftExpression"/>
        <Kind Name="RightShiftExpression"/>
        <Kind Name="LogicalOrExpression"/>
        <Kind Name="LogicalAndExpression"/>
        <Kind Name="BitwiseOrExpression"/>
        <Kind Name="BitwiseAndExpression"/>
        <Kind Name="ExclusiveOrExpression"/>
        <Kind Name="EqualsExpression"/>
        <Kind Name="NotEqualsExpression"/>
        <Kind Name="LessThanExpression"/>
        <Kind Name="LessThanOrEqualExpression"/>
        <Kind Name="GreaterThanExpression"/>
        <Kind Name="GreaterThanOrEqualExpression"/>
        <Kind Name="IsExpression"/>
        <Kind Name="AsExpression"/>
        <Kind Name="CoalesceExpression"/>
        <Field Name="Left" Type="ExprSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
            </PropertyComment>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <Kind Name="PlusToken"/>
            <Kind Name="MinusToken"/>
            <Kind Name="AsteriskToken"/>
            <Kind Name="SlashToken"/>
            <Kind Name="PercentToken"/>
            <Kind Name="LessThanLessThanToken"/>
            <Kind Name="GreaterThanGreaterThanToken"/>
            <Kind Name="BarBarToken"/>
            <Kind Name="AmpersandAmpersandToken"/>
            <Kind Name="BarToken"/>
            <Kind Name="AmpersandToken"/>
            <Kind Name="CaretToken"/>
            <Kind Name="EqualsEqualsToken"/>
            <Kind Name="ExclamationEqualsToken"/>
            <Kind Name="LessThanToken"/>
            <Kind Name="LessThanEqualsToken"/>
            <Kind Name="GreaterThanToken"/>
            <Kind Name="GreaterThanEqualsToken"/>
            <Kind Name="IsKeyword"/>
            <Kind Name="AsKeyword"/>
            <Kind Name="QuestionQuestionToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the operator of the binary expression.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Right" Type="ExprSyntax">
            <PropertyComment>
                <summary>ExpressionSyntax node representing the expression on the right of the binary operator.
                </summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents an expression that has a binary operator.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a BinaryExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>
    <!--endregion Expressions-->

    <!--region Type-->
    <AbstractNode Name="TypeEx" Base="ExprSyntax"/>
    <AbstractNode Name="NameEx" Base="TypeEx"/>

    <Node Name="QualifiedNameEx" Base="NameEx">
        <Kind Name="QualifiedName"/>
        <Field Name="Left" Type="NameEx">
            <PropertyComment>
                <summary>NameSyntax node representing the name on the left side of the dot token of the qualified
                    name.
                </summary>
            </PropertyComment>
        </Field>
        <Field Name="DotToken" Type="SyntaxToken">
            <Kind Name="DotToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the dot.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Right" Type="NameEx">
            <PropertyComment>
                <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified
                    name.
                </summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for qualified name.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a QualifiedNameSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="IdentifierEx" Base="NameEx">
        <Kind Name="IdentifierEx"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
    </Node>
    <Node Name="NamedTypeEx" Base="NameEx">
        <Kind Name="NamedTypeEx"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
        </Field>
    </Node>

    <Node Name="PredefinedTypeEx" Base="TypeEx">
        <Kind Name="PredefinedType"/>
        <Field Name="Keyword" Type="SyntaxToken">
            <Kind Name="BoolKeyword"/>
            <Kind Name="ByteKeyword"/>
            <Kind Name="SByteKeyword"/>
            <Kind Name="IntKeyword"/>
            <Kind Name="UIntKeyword"/>
            <Kind Name="ShortKeyword"/>
            <Kind Name="UShortKeyword"/>
            <Kind Name="LongKeyword"/>
            <Kind Name="ULongKeyword"/>
            <Kind Name="FloatKeyword"/>
            <Kind Name="DoubleKeyword"/>
            <Kind Name="DecimalKeyword"/>
            <Kind Name="StringKeyword"/>
            <Kind Name="CharKeyword"/>
            <Kind Name="ObjectKeyword"/>
            <Kind Name="VoidKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for predefined types.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a PredefinedTypeSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="ArrayTypeEx" Base="TypeEx">
        <Kind Name="ArrayType"/>
        <Field Name="ElementType" Type="TypeEx">
            <PropertyComment>
                <summary>TypeSyntax node representing the type of the element of the array.</summary>
            </PropertyComment>
        </Field>
        <Field Name="RankSpecifiers" Type="SyntaxList&lt;ArrayRankSpecifierSyntax&gt;" MinCount="1">
            <PropertyComment>
                <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the
                    array.
                </summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for the array type.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an ArrayTypeSyntax node.</summary>
        </FactoryComment>
    </Node>
    <Node Name="UnionTypeEx" Base="TypeEx">
        <Kind Name="PredefinedType"/>
        <Field Name="Keyword" Type="SyntaxToken">
            <Kind Name="BoolKeyword"/>
            <Kind Name="ByteKeyword"/>
            <Kind Name="SByteKeyword"/>
            <Kind Name="IntKeyword"/>
            <Kind Name="UIntKeyword"/>
            <Kind Name="ShortKeyword"/>
            <Kind Name="UShortKeyword"/>
            <Kind Name="LongKeyword"/>
            <Kind Name="ULongKeyword"/>
            <Kind Name="FloatKeyword"/>
            <Kind Name="DoubleKeyword"/>
            <Kind Name="DecimalKeyword"/>
            <Kind Name="StringKeyword"/>
            <Kind Name="CharKeyword"/>
            <Kind Name="ObjectKeyword"/>
            <Kind Name="VoidKeyword"/>
            <PropertyComment>
                <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents the syntax node for predefined types.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates a PredefinedTypeSyntax node.</summary>
        </FactoryComment>
    </Node>
    <!--endregion Type-->

    <Node Name="ArrayRankSpecifierSyntax" Base="CSharpSyntaxNode">
        <Kind Name="ArrayRankSpecifier"/>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <Kind Name="OpenBracketToken"/>
        </Field>
        <Field Name="Sizes" Type="SeparatedSyntaxList&lt;ExprSyntax&gt;"/>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <Kind Name="CloseBracketToken"/>
        </Field>
    </Node>
    <Node Name="OmittedArraySizeEx" Base="ExprSyntax">
        <Kind Name="OmittedArraySizeExpression"/>
        <Field Name="OmittedArraySizeExpressionToken" Type="SyntaxToken">
            <Kind Name="OmittedArraySizeExpressionToken"/>
            <PropertyComment>
                <summary>SyntaxToken representing the omitted array size expression.</summary>
            </PropertyComment>
        </Field>
        <TypeComment>
            <summary>Class which represents a placeholder in an array size list.</summary>
        </TypeComment>
        <FactoryComment>
            <summary>Creates an OmittedArraySizeExpressionSyntax node.</summary>
        </FactoryComment>
    </Node>

    <!--region Parameters-->
    <AbstractNode Name="BaseParameterListSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Base type for parameter list syntax.</summary>
        </TypeComment>
        <Field Name="Parameters" Type="SeparatedSyntaxList&lt;ParameterSyntax&gt;">
            <PropertyComment>
                <summary>Gets the parameter list.</summary>
            </PropertyComment>
        </Field>
    </AbstractNode>
    <Node Name="ParameterListSyntax" Base="BaseParameterListSyntax">
        <TypeComment>
            <summary>Parameter list syntax.</summary>
        </TypeComment>
        <Kind Name="ParameterList"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the open paren token.</summary>
            </PropertyComment>
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Parameters" Type="SeparatedSyntaxList&lt;ParameterSyntax&gt;" Override="true"/>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the close paren token.</summary>
            </PropertyComment>
            <Kind Name="CloseParenToken"/>
        </Field>
    </Node>
    <Node Name="BracketedParameterListSyntax" Base="BaseParameterListSyntax">
        <TypeComment>
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </TypeComment>
        <Kind Name="BracketedParameterList"/>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the open bracket token.</summary>
            </PropertyComment>
            <Kind Name="OpenBracketToken"/>
        </Field>
        <Field Name="Parameters" Type="SeparatedSyntaxList&lt;ParameterSyntax&gt;" Override="true" MinCount="1"/>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the close bracket token.</summary>
            </PropertyComment>
            <Kind Name="CloseBracketToken"/>
        </Field>
    </Node>
    <AbstractNode Name="BaseParameterSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>Base parameter syntax.</summary>
        </TypeComment>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;">
            <PropertyComment>
                <summary>Gets the attribute declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;">
            <PropertyComment>
                <summary>Gets the modifier list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="TypeEx" Optional="true"/>
    </AbstractNode>
    <Node Name="ParameterSyntax" Base="BaseParameterSyntax">
        <TypeComment>
            <summary>Parameter syntax.</summary>
        </TypeComment>
        <Kind Name="Parameter"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true">
            <PropertyComment>
                <summary>Gets the attribute declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true">
            <PropertyComment>
                <summary>Gets the modifier list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="TypeEx" Optional="true" Override="true"/>
        <Field Name="Identifier" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the identifier.</summary>
            </PropertyComment>
            <Kind Name="IdentifierToken"/>
            <Kind Name="ArgListKeyword"/>
        </Field>
        <Field Name="Default" Type="EqualsValueClauseSyntax" Optional="true"/>
    </Node>
    <Node Name="FunctionPointerParameterSyntax" Base="BaseParameterSyntax">
        <TypeComment>
            <summary>Parameter syntax.</summary>
        </TypeComment>
        <Kind Name="FunctionPointerParameter"/>
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true">
            <PropertyComment>
                <summary>Gets the attribute declaration list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true">
            <PropertyComment>
                <summary>Gets the modifier list.</summary>
            </PropertyComment>
        </Field>
        <Field Name="Type" Type="TypeEx" Optional="false" Override="true"/>
    </Node>
    <Node Name="IncompleteMemberSyntax" Base="MemberDecl">
        <Kind Name="IncompleteMember"/>n
        <Field Name="AttributeLists" Type="SyntaxList&lt;AttributeListSyntax&gt;" Override="true"/>
        <Field Name="Modifiers" Type="SyntaxList&lt;SyntaxToken&gt;" Override="true"/>
        <Field Name="Type" Type="TypeEx" Optional="true"/>
    </Node>
    <Node Name="SkippedTokensTriviaSyntax" Base="StructuredTriviaSyntax">
        <Kind Name="SkippedTokensTrivia"/>
        <Field Name="Tokens" Type="SyntaxList&lt;SyntaxToken&gt;"/>
    </Node>
    <!--endregion parameters-->

    <!--region Variables-->
    <Node Name="EqualsValueClauseSyntax" Base="CSharpSyntaxNode">
        <Kind Name="EqualsValueClause"/>
        <Field Name="EqualsToken" Type="SyntaxToken">
            <Kind Name="EqualsToken"/>
        </Field>
        <Field Name="Value" Type="ExprSyntax"/>
    </Node>
    <!--endregion Variables-->

    <!--region Statements-->
    <Node Name="BlockStmt" Base="StmtSyntax">
        <Kind Name="Block"/>
        <Field Name="OpenBraceToken" Type="SyntaxToken">
            <Kind Name="OpenBraceToken"/>
        </Field>
        <Field Name="Statements" Type="SyntaxList&lt;StmtSyntax&gt;"/>
        <Field Name="CloseBraceToken" Type="SyntaxToken">
            <Kind Name="CloseBraceToken"/>
        </Field>
    </Node>
    <!--endregion Statements-->

    <!--region Xml -->
    <Node Name="DocumentationCommentTriviaSyntax" Base="StructuredTriviaSyntax">
        <Kind Name="SingleLineDocumentationCommentTrivia"/>
        <Kind Name="MultiLineDocumentationCommentTrivia"/>
        <Field Name="Content" Type="SyntaxList&lt;XmlNodeSyntax&gt;"/>
        <Field Name="EndOfComment" Type="SyntaxToken">
            <!-- should be renamed to EndOfCommentToken -->
            <Kind Name="EndOfDocumentationCommentToken"/>
        </Field>
    </Node>
    <AbstractNode Name="CrefSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>
                A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment
                tag).
                For example, the M in &lt;see cref="M" /&gt;.
            </summary>
        </TypeComment>
    </AbstractNode>
    <Node Name="TypeCrefSyntax" Base="CrefSyntax">
        <TypeComment>
            <summary>
                A symbol reference that definitely refers to a type.
                For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
                NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
                will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
                might be a non-type member.
            </summary>
        </TypeComment>
        <Kind Name="TypeCref"/>
        <Field Name="Type" Type="TypeEx"/>
    </Node>
    <Node Name="QualifiedCrefSyntax" Base="CrefSyntax">
        <TypeComment>
            <summary>
                A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
                For example, cref="System.String.ToString()".
                NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
                will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
                might be a non-type member.
            </summary>
        </TypeComment>
        <Kind Name="QualifiedCref"/>
        <Field Name="Container" Type="TypeEx"/>
        <Field Name="DotToken" Type="SyntaxToken">
            <Kind Name="DotToken"/>
        </Field>
        <Field Name="Member" Type="MemberCrefSyntax"/>
    </Node>
    <AbstractNode Name="MemberCrefSyntax" Base="CrefSyntax">
        <TypeComment>
            <summary>
                The unqualified part of a CrefSyntax.
                For example, "ToString()" in "object.ToString()".
                NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap. The syntax in a TypeCrefSyntax
                will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
                might be a non-type member.
            </summary>
        </TypeComment>
    </AbstractNode>
    <Node Name="NameMemberCrefSyntax" Base="MemberCrefSyntax">
        <TypeComment>
            <summary>
                A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified
                name,
                with an optional type parameter list) and an optional parameter list.
                For example, "M", "M&lt;T&gt;" or "M(int)".
                Also, "A::B()" or "string()".
            </summary>
        </TypeComment>
        <Kind Name="NameMemberCref"/>
        <Field Name="Name" Type="TypeEx"/>
        <Field Name="Parameters" Type="CrefParameterListSyntax" Optional="true"/>
    </Node>
    <Node Name="IndexerMemberCrefSyntax" Base="MemberCrefSyntax">
        <TypeComment>
            <summary>
                A MemberCrefSyntax specified by a this keyword and an optional parameter list.
                For example, "this" or "this[int]".
            </summary>
        </TypeComment>
        <Kind Name="IndexerMemberCref"/>
        <Field Name="ThisKeyword" Type="SyntaxToken">
            <Kind Name="ThisKeyword"/>
        </Field>
        <Field Name="Parameters" Type="CrefBracketedParameterListSyntax" Optional="true"/>
    </Node>
    <Node Name="OperatorMemberCrefSyntax" Base="MemberCrefSyntax">
        <TypeComment>
            <summary>
                A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
                For example, "operator +" or "operator -[int]".
                NOTE: the operator must be overloadable.
            </summary>
        </TypeComment>
        <Kind Name="OperatorMemberCref"/>
        <Field Name="OperatorKeyword" Type="SyntaxToken">
            <Kind Name="OperatorKeyword"/>
        </Field>
        <Field Name="OperatorToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the operator token.</summary>
            </PropertyComment>
            <Kind Name="PlusToken"/>
            <Kind Name="MinusToken"/>
            <Kind Name="ExclamationToken"/>
            <Kind Name="TildeToken"/>
            <Kind Name="PlusPlusToken"/>
            <Kind Name="MinusMinusToken"/>
            <Kind Name="AsteriskToken"/>
            <Kind Name="SlashToken"/>
            <Kind Name="PercentToken"/>
            <Kind Name="LessThanLessThanToken"/>
            <Kind Name="GreaterThanGreaterThanToken"/>
            <Kind Name="BarToken"/>
            <Kind Name="AmpersandToken"/>
            <Kind Name="CaretToken"/>
            <Kind Name="EqualsEqualsToken"/>
            <Kind Name="ExclamationEqualsToken"/>
            <Kind Name="LessThanToken"/>
            <Kind Name="LessThanEqualsToken"/>
            <Kind Name="GreaterThanToken"/>
            <Kind Name="GreaterThanEqualsToken"/>
            <Kind Name="FalseKeyword"/>
            <Kind Name="TrueKeyword"/>
        </Field>
        <Field Name="Parameters" Type="CrefParameterListSyntax" Optional="true"/>
    </Node>
    <Node Name="ConversionOperatorMemberCrefSyntax" Base="MemberCrefSyntax">
        <TypeComment>
            <summary>
                A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination
                type, and an optional parameter list.
                For example, "implicit operator int" or "explicit operator MyType(int)".
            </summary>
        </TypeComment>
        <Kind Name="ConversionOperatorMemberCref"/>
        <Field Name="ImplicitOrExplicitKeyword" Type="SyntaxToken">
            <Kind Name="ImplicitKeyword"/>
            <Kind Name="ExplicitKeyword"/>
        </Field>
        <Field Name="OperatorKeyword" Type="SyntaxToken">
            <Kind Name="OperatorKeyword"/>
        </Field>
        <Field Name="Type" Type="TypeEx"/>
        <Field Name="Parameters" Type="CrefParameterListSyntax" Optional="true"/>
    </Node>
    <AbstractNode Name="BaseCrefParameterListSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>
                A list of cref parameters with surrounding punctuation.
                Unlike regular parameters, cref parameters do not have names.
            </summary>
        </TypeComment>
        <Field Name="Parameters" Type="SeparatedSyntaxList&lt;CrefParameterSyntax&gt;">
            <PropertyComment>
                <summary>Gets the parameter list.</summary>
            </PropertyComment>
        </Field>
    </AbstractNode>
    <Node Name="CrefParameterListSyntax" Base="BaseCrefParameterListSyntax">
        <TypeComment>
            <summary>
                A parenthesized list of cref parameters.
            </summary>
        </TypeComment>
        <Kind Name="CrefParameterList"/>
        <Field Name="OpenParenToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the open paren token.</summary>
            </PropertyComment>
            <Kind Name="OpenParenToken"/>
        </Field>
        <Field Name="Parameters" Type="SeparatedSyntaxList&lt;CrefParameterSyntax&gt;" Override="true"/>
        <Field Name="CloseParenToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the close paren token.</summary>
            </PropertyComment>
            <Kind Name="CloseParenToken"/>
        </Field>
    </Node>
    <Node Name="CrefBracketedParameterListSyntax" Base="BaseCrefParameterListSyntax">
        <TypeComment>
            <summary>
                A bracketed list of cref parameters.
            </summary>
        </TypeComment>
        <Kind Name="CrefBracketedParameterList"/>
        <Field Name="OpenBracketToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the open bracket token.</summary>
            </PropertyComment>
            <Kind Name="OpenBracketToken"/>
        </Field>
        <Field Name="Parameters" Type="SeparatedSyntaxList&lt;CrefParameterSyntax&gt;" Override="true" MinCount="1"/>
        <Field Name="CloseBracketToken" Type="SyntaxToken">
            <PropertyComment>
                <summary>Gets the close bracket token.</summary>
            </PropertyComment>
            <Kind Name="CloseBracketToken"/>
        </Field>
    </Node>
    <Node Name="CrefParameterSyntax" Base="CSharpSyntaxNode">
        <TypeComment>
            <summary>
                An element of a BaseCrefParameterListSyntax.
                Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
                there is no name and there are no attributes or other modifiers.
            </summary>
        </TypeComment>
        <Kind Name="CrefParameter"/>
        <Field Name="RefKindKeyword" Type="SyntaxToken" Optional="true">
            <Kind Name="RefKeyword"/>
            <Kind Name="OutKeyword"/>
            <Kind Name="InKeyword"/>
        </Field>
        <Field Name="Type" Type="TypeEx"/>
    </Node>
    <AbstractNode Name="XmlNodeSyntax" Base="CSharpSyntaxNode">
    </AbstractNode>
    <Node Name="XmlElementSyntax" Base="XmlNodeSyntax">
        <Kind Name="XmlElement"/>
        <Field Name="StartTag" Type="XmlElementStartTagSyntax"/>
        <Field Name="Content" Type="SyntaxList&lt;XmlNodeSyntax&gt;"/>
        <Field Name="EndTag" Type="XmlElementEndTagSyntax"/>
    </Node>
    <Node Name="XmlElementStartTagSyntax" Base="CSharpSyntaxNode">
        <Kind Name="XmlElementStartTag"/>
        <Field Name="LessThanToken" Type="SyntaxToken">
            <Kind Name="LessThanToken"/>
        </Field>
        <Field Name="Name" Type="XmlNameSyntax"/>
        <Field Name="Attributes" Type="SyntaxList&lt;XmlAttributeSyntax&gt;"/>
        <Field Name="GreaterThanToken" Type="SyntaxToken">
            <Kind Name="GreaterThanToken"/>
        </Field>
    </Node>
    <Node Name="XmlElementEndTagSyntax" Base="CSharpSyntaxNode">
        <Kind Name="XmlElementEndTag"/>
        <Field Name="LessThanSlashToken" Type="SyntaxToken">
            <Kind Name="LessThanSlashToken"/>
        </Field>
        <Field Name="Name" Type="XmlNameSyntax"/>
        <Field Name="GreaterThanToken" Type="SyntaxToken">
            <Kind Name="GreaterThanToken"/>
        </Field>
    </Node>
    <Node Name="XmlEmptyElementSyntax" Base="XmlNodeSyntax">
        <Kind Name="XmlEmptyElement"/>
        <Field Name="LessThanToken" Type="SyntaxToken">
            <Kind Name="LessThanToken"/>
        </Field>
        <Field Name="Name" Type="XmlNameSyntax"/>
        <Field Name="Attributes" Type="SyntaxList&lt;XmlAttributeSyntax&gt;"/>
        <Field Name="SlashGreaterThanToken" Type="SyntaxToken">
            <Kind Name="SlashGreaterThanToken"/>
        </Field>
    </Node>
    <Node Name="XmlNameSyntax" Base="CSharpSyntaxNode">
        <Kind Name="XmlName"/>
        <Field Name="Prefix" Type="XmlPrefixSyntax" Optional="true"/>
        <Field Name="LocalName" Type="SyntaxToken">
            <Kind Name="IdentifierToken"/>
        </Field>
    </Node>
    <Node Name="XmlPrefixSyntax" Base="CSharpSyntaxNode">
        <Kind Name="XmlPrefix"/>
        <Field Name="Prefix" Type="SyntaxToken">
            <Kind Name="IdentifierToken"/>
        </Field>
        <Field Name="ColonToken" Type="SyntaxToken">
            <Kind Name="ColonToken"/>
        </Field>
    </Node>
    <AbstractNode Name="XmlAttributeSyntax" Base="CSharpSyntaxNode">
        <Field Name="Name" Type="XmlNameSyntax"/>
        <Field Name="EqualsToken" Type="SyntaxToken">
            <Kind Name="EqualsToken"/>
        </Field>
        <Field Name="StartQuoteToken" Type="SyntaxToken">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
        <Field Name="EndQuoteToken" Type="SyntaxToken">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
    </AbstractNode>
    <Node Name="XmlTextAttributeSyntax" Base="XmlAttributeSyntax">
        <Kind Name="XmlTextAttribute"/>
        <Field Name="Name" Type="XmlNameSyntax" Override="true"/>
        <Field Name="EqualsToken" Type="SyntaxToken" Override="true">
            <Kind Name="EqualsToken"/>
        </Field>
        <Field Name="StartQuoteToken" Type="SyntaxToken" Override="true">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
        <Field Name="TextTokens" Type="SyntaxList&lt;SyntaxToken&gt;"/>
        <!-- XmlTextLiteralToken or XmlEntityLiteralToken-->
        <Field Name="EndQuoteToken" Type="SyntaxToken" Override="true">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
    </Node>
    <Node Name="XmlCrefAttributeSyntax" Base="XmlAttributeSyntax">
        <Kind Name="XmlCrefAttribute"/>
        <Field Name="Name" Type="XmlNameSyntax" Override="true"/>
        <Field Name="EqualsToken" Type="SyntaxToken" Override="true">
            <Kind Name="EqualsToken"/>
        </Field>
        <Field Name="StartQuoteToken" Type="SyntaxToken" Override="true">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
        <Field Name="Cref" Type="CrefSyntax"/>
        <Field Name="EndQuoteToken" Type="SyntaxToken" Override="true">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
    </Node>
    <Node Name="XmlNameAttributeSyntax" Base="XmlAttributeSyntax">
        <Kind Name="XmlNameAttribute"/>
        <Field Name="Name" Type="XmlNameSyntax" Override="true"/>
        <Field Name="EqualsToken" Type="SyntaxToken" Override="true">
            <Kind Name="EqualsToken"/>
        </Field>
        <Field Name="StartQuoteToken" Type="SyntaxToken" Override="true">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
        <Field Name="Identifier" Type="IdentifierEx"/>
        <Field Name="EndQuoteToken" Type="SyntaxToken" Override="true">
            <Kind Name="SingleQuoteToken"/>
            <Kind Name="DoubleQuoteToken"/>
        </Field>
    </Node>
    <Node Name="XmlTextSyntax" Base="XmlNodeSyntax">
        <Kind Name="XmlText"/>
        <Field Name="TextTokens" Type="SyntaxList&lt;SyntaxToken&gt;"/>
        <!-- XmlTextLiteralToken or XmlEntityLiteralToken-->
    </Node>
    <Node Name="XmlCDataSectionSyntax" Base="XmlNodeSyntax">
        <Kind Name="XmlCDataSection"/>
        <Field Name="StartCDataToken" Type="SyntaxToken">
            <Kind Name="XmlCDataStartToken"/>
        </Field>
        <Field Name="TextTokens" Type="SyntaxList&lt;SyntaxToken&gt;"/>
        <!-- XmlTextLiteralToken only -->
        <Field Name="EndCDataToken" Type="SyntaxToken">
            <Kind Name="XmlCDataEndToken"/>
        </Field>
    </Node>
    <Node Name="XmlProcessingInstructionSyntax" Base="XmlNodeSyntax">
        <Kind Name="XmlProcessingInstruction"/>
        <Field Name="StartProcessingInstructionToken" Type="SyntaxToken">
            <Kind Name="XmlProcessingInstructionStartToken"/>
        </Field>
        <Field Name="Name" Type="XmlNameSyntax"/>
        <Field Name="TextTokens" Type="SyntaxList&lt;SyntaxToken&gt;"/>
        <!-- XmlTextLiteralToken only -->
        <Field Name="EndProcessingInstructionToken" Type="SyntaxToken">
            <Kind Name="XmlProcessingInstructionEndToken"/>
        </Field>
    </Node>
    <Node Name="XmlCommentSyntax" Base="XmlNodeSyntax">
        <Kind Name="XmlComment"/>
        <Field Name="LessThanExclamationMinusMinusToken" Type="SyntaxToken">
            <Kind Name="XmlCommentStartToken"/>
        </Field>
        <Field Name="TextTokens" Type="SyntaxList&lt;SyntaxToken&gt;"/>
        <!-- XmlTextLiteralToken only -->
        <Field Name="MinusMinusGreaterThanToken" Type="SyntaxToken">
            <Kind Name="XmlCommentEndToken"/>
        </Field>
    </Node>

    <!--endregion Xml-->
</Tree>
