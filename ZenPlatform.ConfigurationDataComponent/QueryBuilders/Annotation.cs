/*
 * Тезисы - как должны работать запросы и роадмап по ним
 *
 *
 * 1) У нас есть описание объектов из этого следует несколько основных принципов
 *  - Мы можем по описанию объекта сгенерировать структуру в которой он будет храниться
 *  - Мы можем делать инструкции выборки и измененения данных исходя из описания
 * 2) После того, как мы успешно реализовали менеджер, необходимо продумать
 * собственный язык запросов на основе SQL. Т.е. нужен парсер, который это всё дело
 * ложит в стуктуры, а затем раскидывает на компоменты задания, чтобы те сгенерировали
 * свою часть запроса, что-то вроде построителя запроса с крутой возможностью распределить
 * компиляцию запроса на компоненты
 *
 * 3) БД не может иметь ключи, никаких. Это реально гемор поддерживать все эксепшены от БД, вроде (not reference ex)
 *    это также нас спасает от бесконечной связанности с другими компонентами
 * 4) Единственная вещь которая помогает бороться с перформансом - это индексы
 *
 * Про билдер, у нас есть запрос:
 *
 * FROM Document.Invoice i
 *      JOIN Reference.Nomneclature n on i.Nomenclature = n.Entity
 * SELECT
 *      i.Date, n.Name
 *
 *
 * Он должен преобразоваться в такое вот чудо:
 *
 * SELECT exp1._f1892, exp2._f1234
 * FROM [dbo]._t1123 exp1 JOIN [dbo]._t1111 ON exp1._fr1122 = exp2_fk1234
 *
 * Для этого необходимо, чтобы компилятор запросов сделал дерево получениия значения.
 *
 * Из Document.Invoice мы берём i.Nomenclature и i.Date
 * Из Reference.Nomneclature мы берём n.Entity и n.Name
 *
 */

/*
 * Сценарии выборки:
 * 1) Выбрать одиночный объект (SelectSingleObject)
 * 2) Выбрать несколько объектов (SelectMultiplyObjects)
 * 3) Обновить одиночный объект (UpdateSingleObject)
 * 4) Обновить несколько объектов (UpdateMultiplyObjects)
 * 5) Вставить объект (InsertObject)
 * 6) Удалить одиночный объект (DeleteSingleObject)
 * 7) Удалить несколько объектов (DeleteMultiplyObjects)
 */