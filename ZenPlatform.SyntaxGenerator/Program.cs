using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ZenPlatform.SyntaxGenerator
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
                Console.WriteLine($"Invalid using. Use {nameof(ZenPlatform.SyntaxGenerator)} [PathToXmlScheme]");

            using (TextReader tr = new StreamReader(args[0]))
            {
                XmlSerializer xs = new XmlSerializer(typeof(Config));
                var root = (Config) xs.Deserialize(tr);


                StringBuilder sb = new StringBuilder();


                sb.AppendLine("/// <auto-generated />\n\n");


                foreach (var syntax in root.Syntaxes)
                {
                    List<MemberDeclarationSyntax> members = new List<MemberDeclarationSyntax>();

                    var slot = SyntaxFactory.ParseStatement("var slot = 0;");

                    var publicToken = SyntaxFactory.Token(SyntaxKind.PublicKeyword);

                    var constructor = SyntaxFactory.ConstructorDeclaration(syntax.Name)
                        .WithParameterList(SyntaxFactory.ParameterList()
                            .AddParameters(SyntaxFactory.Parameter(
                                SyntaxFactory.Identifier("lineInfo")).WithType(SyntaxFactory.ParseName("ILineInfo"))))
                        .WithBody(SyntaxFactory.Block())
                        .WithModifiers(SyntaxTokenList.Create(publicToken));

                    var initializer = SyntaxFactory.ConstructorInitializer(SyntaxKind.BaseConstructorInitializer,
                        SyntaxFactory.ArgumentList()
                            .AddArguments(SyntaxFactory.Argument(SyntaxFactory.ParseName("lineInfo"))));

                    constructor = constructor.WithInitializer(initializer);


                    if (syntax.Arguments.Count > 0)
                    {
                        constructor = constructor.AddBodyStatements(slot);
                    }

                    foreach (var argument in syntax.Arguments)
                    {
                        constructor = constructor.AddParameterListParameters(SyntaxFactory
                            .Parameter(SyntaxFactory.Identifier(argument.Name.ToCamelCase()))
                            .WithType(SyntaxFactory.ParseName(argument.Type)));


                        var ae = SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                            SyntaxFactory.ParseName(argument.Name),
                            SyntaxFactory.ParseName(argument.Name.ToCamelCase()));

                        constructor = constructor.AddBodyStatements(SyntaxFactory.ExpressionStatement(ae));

                        members.Add(SyntaxFactory.PropertyDeclaration(SyntaxFactory.ParseTypeName(argument.Type),
                                argument.Name).AddModifiers(publicToken)
                            .WithAccessorList(SyntaxFactory.AccessorList()
                                .AddAccessors(SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                    .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)))));

                        if (!argument.DenyChildrenFill)
                        {
                            StatementSyntax fillStmt;
                            // fill childrens
                            if (argument is SyntaxArgumentList)
                                fillStmt =
                                    SyntaxFactory.ParseStatement(
                                        $"foreach(var item in {argument.Name}) {{Children.Add(item);}}");
                            else if (argument is SyntaxArgumentSingle)
                            {
                                fillStmt =
                                    SyntaxFactory.ParseStatement(
                                        $"Children.Add({argument.Name});");
                            }
                            else
                            {
                                throw new Exception();
                            }

                            constructor = constructor.AddBodyStatements(fillStmt);
                        }
                    }

                    var cls = SyntaxFactory.ClassDeclaration(syntax.Name)
                        .WithModifiers(SyntaxTokenList.Create(publicToken)
                            .Add(SyntaxFactory.Token(SyntaxKind.PartialKeyword)))
                        .WithBaseList(SyntaxFactory.BaseList().AddTypes(SyntaxFactory
                            .SimpleBaseType(SyntaxFactory.ParseTypeName(syntax.Base))))
                        .AddMembers(constructor)
                        .AddMembers(members.ToArray());


                    if (syntax.IsScoped)
                    {
                        cls = cls.AddBaseListTypes(
                            SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName("IScoped")));

                        cls = cls.AddMembers(SyntaxFactory.PropertyDeclaration(
                                SyntaxFactory.ParseTypeName("SymbolTable"),
                                "SymbolTable").AddModifiers(publicToken)
                            .WithAccessorList(SyntaxFactory.AccessorList()
                                .AddAccessors(SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                    .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)))
                                .AddAccessors(SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                    .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken)))));
                    }

                    Console.WriteLine(cls.NormalizeWhitespace());
                }
            }
        }
    }

    public class Config
    {
        /// <summary>
        /// The syntax collection
        /// </summary>
        [XmlElement("Syntax")]
        public List<Syntax> Syntaxes { get; set; }
    }

    public static class StringExt
    {
        public static string ToCamelCase(this string str)
        {
            return char.ToLower(str[0]) + str[1..];
        }
    }


    public abstract class SyntaxArgument
    {
        [XmlAttribute] public string Name { get; set; }
        [XmlAttribute] public string Type { get; set; }

        [XmlAttribute] public bool DenyChildrenFill { get; set; }
    }

    public sealed class SyntaxArgumentList : SyntaxArgument
    {
    }

    public sealed class SyntaxArgumentSingle : SyntaxArgument
    {
    }

    public class Syntax
    {
        public Syntax()
        {
            Arguments = new List<SyntaxArgument>();
            Base = "AstNode";
        }

        /// <summary>
        /// The name of syntax node
        /// </summary>
        [XmlAttribute]
        public string Name { get; set; }

        /// <summary>
        /// Base of the current syntax by default it is AstNode
        /// </summary>
        [XmlAttribute]
        public string Base { get; set; }

        [XmlArrayItem("List", typeof(SyntaxArgumentList))]
        [XmlArrayItem("Single", typeof(SyntaxArgumentSingle))]
        public List<SyntaxArgument> Arguments { get; set; }

        /// <summary>
        /// Indicate that the syntax is abstract and only can be driven by another syntax
        /// </summary>
        [XmlAttribute]
        public bool IsAbstract { get; set; }

        /// <summary>
        /// Indicate that the syntax has scope
        /// </summary>
        [XmlAttribute]
        public bool IsScoped { get; set; }
    }
}