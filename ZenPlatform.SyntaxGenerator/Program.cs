using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

namespace ZenPlatform.SyntaxGenerator
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
                Console.WriteLine($"Invalid using. Use {nameof(ZenPlatform.SyntaxGenerator)} [PathToXmlScheme]");

            using (TextReader tr = new StreamReader(args[0]))
            {
                XmlSerializer xs = new XmlSerializer(typeof(Config));
                var root = (Config) xs.Deserialize(tr);


                StringBuilder sb = new StringBuilder();


                sb.AppendLine("/// <auto-generated />\n\n");


                foreach (var syntax in root.Syntaxes)
                {
                    sb.Append($"public partial class {syntax.Name}");

                    if (syntax.Base != null)
                        sb.Append($" : {syntax.Base}");

                    sb.AppendLine();
                    sb.AppendLine("{");

                    {
                        //constructor
                        sb.Append($"\tpublic {syntax.Name}(ILineInfo lineInfo");
                        {
                            //Build arguments
                            foreach (var arg in syntax.Arguments)
                            {
                                sb.Append(", ");
                                sb.Append($"{arg.Type} {arg.Name.ToLower()}");
                            }
                        }

                        sb.Append(")");

                        if (syntax.Base != null)
                            sb.Append(" : base(lineInfo)");

                        sb.AppendLine();

                        sb.AppendLine("\t{");

                        sb.AppendLine("\t}");
                    }

                    if (syntax.Base == null)
                    {
                        //line info
                        sb.AppendLine();
                        sb.AppendLine("\tpublic LineInfo LineInfo { get; }");
                    }


                    {
                        sb.AppendLine();
                        sb.Append($"\tpublic ");

                        if (syntax.Base != null)
                            sb.Append("override ");

                        sb.Append("T Accept<T>(AstVisitorBase<T> visitor)");

                        sb.AppendLine();

                        sb.AppendLine("\t{");

                        if (syntax.Base == null && syntax.IsAbstract)
                            sb.AppendLine($"\t\tthrow new NotImplementedException();");
                        else
                        {
                            sb.AppendLine($"\t\treturn visitor.Visit{syntax.Name}(this);");
                        }

                        sb.AppendLine("\t}");
                    }


                    sb.AppendLine("}");
                    sb.AppendLine();
                }


                Console.WriteLine(sb);
            }
        }
    }


    public class Config
    {
        /// <summary>
        /// The syntax collection
        /// </summary>
        [XmlElement("Syntax")]
        public List<Syntax> Syntaxes { get; set; }
    }


    public abstract class SyntaxArgument
    {
        [XmlAttribute] public string Name { get; set; }
        [XmlAttribute] public string Type { get; set; }
    }

    public sealed class SyntaxArgumentList : SyntaxArgument
    {
    }

    public sealed class SyntaxArgumentSingle : SyntaxArgument
    {
    }

    public class Syntax
    {
        public Syntax()
        {
            Arguments = new List<SyntaxArgument>();
            Base = "AstNode";
        }

        /// <summary>
        /// The name of syntax node
        /// </summary>
        [XmlAttribute]
        public string Name { get; set; }

        /// <summary>
        /// Base of the current syntax by default it is AstNode
        /// </summary>
        [XmlAttribute]
        public string Base { get; set; }

        [XmlArrayItem("List", typeof(SyntaxArgumentList))]
        public List<SyntaxArgument> Arguments { get; set; }

        /// <summary>
        /// Indicate that the syntax is abstract and only can be driven by another syntax
        /// </summary>
        [XmlAttribute]
        public bool IsAbstract { get; set; }
    }
}